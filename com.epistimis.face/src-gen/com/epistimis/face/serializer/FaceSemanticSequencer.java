/*
 * generated by Xtext 2.30.0
 */
/*
 * Copyright (c) 2022, 2023 Epistimis LLC (http://www.epistimis.com).
 */
package com.epistimis.face.serializer;

import com.epistimis.face.face.ArchitectureModel;
import com.epistimis.face.face.FacePackage;
import com.epistimis.face.face.IntegrationIntegrationContext;
import com.epistimis.face.face.IntegrationIntegrationModel;
import com.epistimis.face.face.IntegrationTSNodeConnection;
import com.epistimis.face.face.IntegrationTSNodeInputPort;
import com.epistimis.face.face.IntegrationTSNodeOutputPort;
import com.epistimis.face.face.IntegrationTransportChannel;
import com.epistimis.face.face.IntegrationUoPInputEndPoint;
import com.epistimis.face.face.IntegrationUoPInstance;
import com.epistimis.face.face.IntegrationUoPOutputEndPoint;
import com.epistimis.face.face.IntegrationViewAggregation;
import com.epistimis.face.face.IntegrationViewFilter;
import com.epistimis.face.face.IntegrationViewSink;
import com.epistimis.face.face.IntegrationViewSource;
import com.epistimis.face.face.IntegrationViewTransformation;
import com.epistimis.face.face.IntegrationViewTransporter;
import com.epistimis.face.face.UopAbstractConnection;
import com.epistimis.face.face.UopAbstractUoP;
import com.epistimis.face.face.UopClientServerConnection;
import com.epistimis.face.face.UopComponentFramework;
import com.epistimis.face.face.UopCompositeTemplate;
import com.epistimis.face.face.UopLanguageRuntime;
import com.epistimis.face.face.UopLifeCycleManagementPort;
import com.epistimis.face.face.UopPlatformSpecificComponent;
import com.epistimis.face.face.UopPortableComponent;
import com.epistimis.face.face.UopQueuingConnection;
import com.epistimis.face.face.UopRAMMemoryRequirements;
import com.epistimis.face.face.UopSingleInstanceMessageConnection;
import com.epistimis.face.face.UopTemplate;
import com.epistimis.face.face.UopTemplateComposition;
import com.epistimis.face.face.UopThread;
import com.epistimis.face.face.UopUoPModel;
import com.epistimis.face.services.FaceGrammarAccess;
import com.epistimis.uddl.serializer.UddlSemanticSequencer;
import com.epistimis.uddl.uddl.ConceptualAssociation;
import com.epistimis.uddl.uddl.ConceptualBasisEntity;
import com.epistimis.uddl.uddl.ConceptualCharacteristicPathNode;
import com.epistimis.uddl.uddl.ConceptualCompositeQuery;
import com.epistimis.uddl.uddl.ConceptualComposition;
import com.epistimis.uddl.uddl.ConceptualDataModel;
import com.epistimis.uddl.uddl.ConceptualDomain;
import com.epistimis.uddl.uddl.ConceptualEntity;
import com.epistimis.uddl.uddl.ConceptualObservable;
import com.epistimis.uddl.uddl.ConceptualParticipant;
import com.epistimis.uddl.uddl.ConceptualParticipantPathNode;
import com.epistimis.uddl.uddl.ConceptualQuery;
import com.epistimis.uddl.uddl.ConceptualQueryComposition;
import com.epistimis.uddl.uddl.DataModel;
import com.epistimis.uddl.uddl.Include;
import com.epistimis.uddl.uddl.LogicalAffineConversion;
import com.epistimis.uddl.uddl.LogicalAssociation;
import com.epistimis.uddl.uddl.LogicalBoolean;
import com.epistimis.uddl.uddl.LogicalCharacter;
import com.epistimis.uddl.uddl.LogicalCharacteristicPathNode;
import com.epistimis.uddl.uddl.LogicalCompositeQuery;
import com.epistimis.uddl.uddl.LogicalComposition;
import com.epistimis.uddl.uddl.LogicalConversion;
import com.epistimis.uddl.uddl.LogicalCoordinateSystem;
import com.epistimis.uddl.uddl.LogicalCoordinateSystemAxis;
import com.epistimis.uddl.uddl.LogicalDataModel;
import com.epistimis.uddl.uddl.LogicalEntity;
import com.epistimis.uddl.uddl.LogicalEnumerated;
import com.epistimis.uddl.uddl.LogicalEnumeratedSet;
import com.epistimis.uddl.uddl.LogicalEnumerationConstraint;
import com.epistimis.uddl.uddl.LogicalEnumerationLabel;
import com.epistimis.uddl.uddl.LogicalFixedLengthStringConstraint;
import com.epistimis.uddl.uddl.LogicalInteger;
import com.epistimis.uddl.uddl.LogicalIntegerRangeConstraint;
import com.epistimis.uddl.uddl.LogicalLandmark;
import com.epistimis.uddl.uddl.LogicalMeasurement;
import com.epistimis.uddl.uddl.LogicalMeasurementAttribute;
import com.epistimis.uddl.uddl.LogicalMeasurementAxis;
import com.epistimis.uddl.uddl.LogicalMeasurementConstraint;
import com.epistimis.uddl.uddl.LogicalMeasurementConversion;
import com.epistimis.uddl.uddl.LogicalMeasurementSystem;
import com.epistimis.uddl.uddl.LogicalMeasurementSystemAxis;
import com.epistimis.uddl.uddl.LogicalMeasurementSystemConversion;
import com.epistimis.uddl.uddl.LogicalNatural;
import com.epistimis.uddl.uddl.LogicalNonNegativeReal;
import com.epistimis.uddl.uddl.LogicalParticipant;
import com.epistimis.uddl.uddl.LogicalParticipantPathNode;
import com.epistimis.uddl.uddl.LogicalQuery;
import com.epistimis.uddl.uddl.LogicalQueryComposition;
import com.epistimis.uddl.uddl.LogicalReal;
import com.epistimis.uddl.uddl.LogicalRealRangeConstraint;
import com.epistimis.uddl.uddl.LogicalReferencePoint;
import com.epistimis.uddl.uddl.LogicalReferencePointPart;
import com.epistimis.uddl.uddl.LogicalRegularExpressionConstraint;
import com.epistimis.uddl.uddl.LogicalStandardMeasurementSystem;
import com.epistimis.uddl.uddl.LogicalString;
import com.epistimis.uddl.uddl.LogicalUnit;
import com.epistimis.uddl.uddl.LogicalValueTypeUnit;
import com.epistimis.uddl.uddl.PlatformArray;
import com.epistimis.uddl.uddl.PlatformAssociation;
import com.epistimis.uddl.uddl.PlatformBoolean;
import com.epistimis.uddl.uddl.PlatformBoundedString;
import com.epistimis.uddl.uddl.PlatformChar;
import com.epistimis.uddl.uddl.PlatformCharArray;
import com.epistimis.uddl.uddl.PlatformCharacteristicPathNode;
import com.epistimis.uddl.uddl.PlatformCompositeQuery;
import com.epistimis.uddl.uddl.PlatformComposition;
import com.epistimis.uddl.uddl.PlatformDataModel;
import com.epistimis.uddl.uddl.PlatformDouble;
import com.epistimis.uddl.uddl.PlatformEntity;
import com.epistimis.uddl.uddl.PlatformEnumeration;
import com.epistimis.uddl.uddl.PlatformFixed;
import com.epistimis.uddl.uddl.PlatformFloat;
import com.epistimis.uddl.uddl.PlatformLong;
import com.epistimis.uddl.uddl.PlatformLongDouble;
import com.epistimis.uddl.uddl.PlatformLongLong;
import com.epistimis.uddl.uddl.PlatformOctet;
import com.epistimis.uddl.uddl.PlatformParticipant;
import com.epistimis.uddl.uddl.PlatformParticipantPathNode;
import com.epistimis.uddl.uddl.PlatformQuery;
import com.epistimis.uddl.uddl.PlatformQueryComposition;
import com.epistimis.uddl.uddl.PlatformSequence;
import com.epistimis.uddl.uddl.PlatformShort;
import com.epistimis.uddl.uddl.PlatformString;
import com.epistimis.uddl.uddl.PlatformStruct;
import com.epistimis.uddl.uddl.PlatformStructMember;
import com.epistimis.uddl.uddl.PlatformULong;
import com.epistimis.uddl.uddl.PlatformULongLong;
import com.epistimis.uddl.uddl.PlatformUShort;
import com.epistimis.uddl.uddl.UddlPackage;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class FaceSemanticSequencer extends UddlSemanticSequencer {

	@Inject
	private FaceGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FacePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FacePackage.ARCHITECTURE_MODEL:
				sequence_ArchitectureModel(context, (ArchitectureModel) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_INTEGRATION_CONTEXT:
				sequence_IntegrationIntegrationContext(context, (IntegrationIntegrationContext) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_INTEGRATION_MODEL:
				sequence_IntegrationIntegrationModel(context, (IntegrationIntegrationModel) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_TS_NODE_CONNECTION:
				sequence_IntegrationTSNodeConnection(context, (IntegrationTSNodeConnection) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_TS_NODE_INPUT_PORT:
				sequence_IntegrationTSNodeInputPort(context, (IntegrationTSNodeInputPort) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_TS_NODE_OUTPUT_PORT:
				sequence_IntegrationTSNodeOutputPort(context, (IntegrationTSNodeOutputPort) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_TRANSPORT_CHANNEL:
				sequence_IntegrationTransportChannel(context, (IntegrationTransportChannel) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_UO_PINPUT_END_POINT:
				sequence_IntegrationUoPInputEndPoint(context, (IntegrationUoPInputEndPoint) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_UO_PINSTANCE:
				sequence_IntegrationUoPInstance(context, (IntegrationUoPInstance) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_UO_POUTPUT_END_POINT:
				sequence_IntegrationUoPOutputEndPoint(context, (IntegrationUoPOutputEndPoint) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_VIEW_AGGREGATION:
				sequence_IntegrationViewAggregation(context, (IntegrationViewAggregation) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_VIEW_FILTER:
				sequence_IntegrationViewFilter(context, (IntegrationViewFilter) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_VIEW_SINK:
				sequence_IntegrationViewSink(context, (IntegrationViewSink) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_VIEW_SOURCE:
				sequence_IntegrationViewSource(context, (IntegrationViewSource) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_VIEW_TRANSFORMATION:
				sequence_IntegrationViewTransformation(context, (IntegrationViewTransformation) semanticObject); 
				return; 
			case FacePackage.INTEGRATION_VIEW_TRANSPORTER:
				sequence_IntegrationViewTransporter(context, (IntegrationViewTransporter) semanticObject); 
				return; 
			case FacePackage.UOP_ABSTRACT_CONNECTION:
				sequence_UopAbstractConnection(context, (UopAbstractConnection) semanticObject); 
				return; 
			case FacePackage.UOP_ABSTRACT_UO_P:
				sequence_UopAbstractUoP(context, (UopAbstractUoP) semanticObject); 
				return; 
			case FacePackage.UOP_CLIENT_SERVER_CONNECTION:
				sequence_UopClientServerConnection(context, (UopClientServerConnection) semanticObject); 
				return; 
			case FacePackage.UOP_COMPONENT_FRAMEWORK:
				sequence_UopComponentFramework(context, (UopComponentFramework) semanticObject); 
				return; 
			case FacePackage.UOP_COMPOSITE_TEMPLATE:
				sequence_UopCompositeTemplate(context, (UopCompositeTemplate) semanticObject); 
				return; 
			case FacePackage.UOP_LANGUAGE_RUNTIME:
				sequence_UopLanguageRuntime(context, (UopLanguageRuntime) semanticObject); 
				return; 
			case FacePackage.UOP_LIFE_CYCLE_MANAGEMENT_PORT:
				sequence_UopLifeCycleManagementPort(context, (UopLifeCycleManagementPort) semanticObject); 
				return; 
			case FacePackage.UOP_PLATFORM_SPECIFIC_COMPONENT:
				sequence_UopPlatformSpecificComponent(context, (UopPlatformSpecificComponent) semanticObject); 
				return; 
			case FacePackage.UOP_PORTABLE_COMPONENT:
				sequence_UopPortableComponent(context, (UopPortableComponent) semanticObject); 
				return; 
			case FacePackage.UOP_QUEUING_CONNECTION:
				sequence_UopQueuingConnection(context, (UopQueuingConnection) semanticObject); 
				return; 
			case FacePackage.UOP_RAM_MEMORY_REQUIREMENTS:
				sequence_UopRAMMemoryRequirements(context, (UopRAMMemoryRequirements) semanticObject); 
				return; 
			case FacePackage.UOP_SINGLE_INSTANCE_MESSAGE_CONNECTION:
				sequence_UopSingleInstanceMessageConnection(context, (UopSingleInstanceMessageConnection) semanticObject); 
				return; 
			case FacePackage.UOP_TEMPLATE:
				sequence_UopTemplate(context, (UopTemplate) semanticObject); 
				return; 
			case FacePackage.UOP_TEMPLATE_COMPOSITION:
				sequence_UopTemplateComposition(context, (UopTemplateComposition) semanticObject); 
				return; 
			case FacePackage.UOP_THREAD:
				sequence_UopThread(context, (UopThread) semanticObject); 
				return; 
			case FacePackage.UOP_UO_PMODEL:
				sequence_UopUoPModel(context, (UopUoPModel) semanticObject); 
				return; 
			}
		else if (epackage == UddlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UddlPackage.CONCEPTUAL_ASSOCIATION:
				sequence_ConceptualAssociation(context, (ConceptualAssociation) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_BASIS_ENTITY:
				sequence_ConceptualBasisEntity(context, (ConceptualBasisEntity) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_CHARACTERISTIC_PATH_NODE:
				sequence_ConceptualCharacteristicPathNode(context, (ConceptualCharacteristicPathNode) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_COMPOSITE_QUERY:
				sequence_ConceptualCompositeQuery(context, (ConceptualCompositeQuery) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_COMPOSITION:
				sequence_ConceptualComposition(context, (ConceptualComposition) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_DATA_MODEL:
				sequence_ConceptualDataModel(context, (ConceptualDataModel) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_DOMAIN:
				sequence_ConceptualDomain(context, (ConceptualDomain) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_ENTITY:
				sequence_ConceptualEntity(context, (ConceptualEntity) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_OBSERVABLE:
				sequence_ConceptualObservable(context, (ConceptualObservable) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_PARTICIPANT:
				sequence_ConceptualParticipant(context, (ConceptualParticipant) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_PARTICIPANT_PATH_NODE:
				sequence_ConceptualParticipantPathNode(context, (ConceptualParticipantPathNode) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_QUERY:
				sequence_ConceptualQuery(context, (ConceptualQuery) semanticObject); 
				return; 
			case UddlPackage.CONCEPTUAL_QUERY_COMPOSITION:
				sequence_ConceptualQueryComposition(context, (ConceptualQueryComposition) semanticObject); 
				return; 
			case UddlPackage.DATA_MODEL:
				sequence_DataModel(context, (DataModel) semanticObject); 
				return; 
			case UddlPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_AFFINE_CONVERSION:
				sequence_LogicalAffineConversion(context, (LogicalAffineConversion) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_ASSOCIATION:
				sequence_LogicalAssociation(context, (LogicalAssociation) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_BOOLEAN:
				sequence_LogicalBoolean(context, (LogicalBoolean) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_CHARACTER:
				sequence_LogicalCharacter(context, (LogicalCharacter) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_CHARACTERISTIC_PATH_NODE:
				sequence_LogicalCharacteristicPathNode(context, (LogicalCharacteristicPathNode) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_COMPOSITE_QUERY:
				sequence_LogicalCompositeQuery(context, (LogicalCompositeQuery) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_COMPOSITION:
				sequence_LogicalComposition(context, (LogicalComposition) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_CONVERSION:
				sequence_LogicalConversion(context, (LogicalConversion) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_COORDINATE_SYSTEM:
				sequence_LogicalCoordinateSystem(context, (LogicalCoordinateSystem) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_COORDINATE_SYSTEM_AXIS:
				sequence_LogicalCoordinateSystemAxis(context, (LogicalCoordinateSystemAxis) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_DATA_MODEL:
				sequence_LogicalDataModel(context, (LogicalDataModel) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_ENTITY:
				sequence_LogicalEntity(context, (LogicalEntity) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_ENUMERATED:
				sequence_LogicalEnumerated(context, (LogicalEnumerated) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_ENUMERATED_SET:
				sequence_LogicalEnumeratedSet(context, (LogicalEnumeratedSet) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_ENUMERATION_CONSTRAINT:
				sequence_LogicalEnumerationConstraint(context, (LogicalEnumerationConstraint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_ENUMERATION_LABEL:
				sequence_LogicalEnumerationLabel(context, (LogicalEnumerationLabel) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_FIXED_LENGTH_STRING_CONSTRAINT:
				sequence_LogicalFixedLengthStringConstraint(context, (LogicalFixedLengthStringConstraint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_INTEGER:
				sequence_LogicalInteger(context, (LogicalInteger) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_INTEGER_RANGE_CONSTRAINT:
				sequence_LogicalIntegerRangeConstraint(context, (LogicalIntegerRangeConstraint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_LANDMARK:
				sequence_LogicalLandmark(context, (LogicalLandmark) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT:
				sequence_LogicalMeasurement(context, (LogicalMeasurement) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_ATTRIBUTE:
				sequence_LogicalMeasurementAttribute(context, (LogicalMeasurementAttribute) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_AXIS:
				sequence_LogicalMeasurementAxis(context, (LogicalMeasurementAxis) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_CONSTRAINT:
				sequence_LogicalMeasurementConstraint(context, (LogicalMeasurementConstraint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_CONVERSION:
				sequence_LogicalMeasurementConversion(context, (LogicalMeasurementConversion) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_SYSTEM:
				sequence_LogicalMeasurementSystem(context, (LogicalMeasurementSystem) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_SYSTEM_AXIS:
				sequence_LogicalMeasurementSystemAxis(context, (LogicalMeasurementSystemAxis) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_MEASUREMENT_SYSTEM_CONVERSION:
				sequence_LogicalMeasurementSystemConversion(context, (LogicalMeasurementSystemConversion) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_NATURAL:
				sequence_LogicalNatural(context, (LogicalNatural) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_NON_NEGATIVE_REAL:
				sequence_LogicalNonNegativeReal(context, (LogicalNonNegativeReal) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_PARTICIPANT:
				sequence_LogicalParticipant(context, (LogicalParticipant) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_PARTICIPANT_PATH_NODE:
				sequence_LogicalParticipantPathNode(context, (LogicalParticipantPathNode) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_QUERY:
				sequence_LogicalQuery(context, (LogicalQuery) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_QUERY_COMPOSITION:
				sequence_LogicalQueryComposition(context, (LogicalQueryComposition) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_REAL:
				sequence_LogicalReal(context, (LogicalReal) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_REAL_RANGE_CONSTRAINT:
				sequence_LogicalRealRangeConstraint(context, (LogicalRealRangeConstraint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_REFERENCE_POINT:
				sequence_LogicalReferencePoint(context, (LogicalReferencePoint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_REFERENCE_POINT_PART:
				sequence_LogicalReferencePointPart(context, (LogicalReferencePointPart) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_REGULAR_EXPRESSION_CONSTRAINT:
				sequence_LogicalRegularExpressionConstraint(context, (LogicalRegularExpressionConstraint) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_STANDARD_MEASUREMENT_SYSTEM:
				sequence_LogicalStandardMeasurementSystem(context, (LogicalStandardMeasurementSystem) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_STRING:
				sequence_LogicalString(context, (LogicalString) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_UNIT:
				sequence_LogicalUnit(context, (LogicalUnit) semanticObject); 
				return; 
			case UddlPackage.LOGICAL_VALUE_TYPE_UNIT:
				sequence_LogicalValueTypeUnit(context, (LogicalValueTypeUnit) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_ARRAY:
				sequence_PlatformArray(context, (PlatformArray) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_ASSOCIATION:
				sequence_PlatformAssociation(context, (PlatformAssociation) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_BOOLEAN:
				sequence_PlatformBoolean(context, (PlatformBoolean) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_BOUNDED_STRING:
				sequence_PlatformBoundedString(context, (PlatformBoundedString) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_CHAR:
				sequence_PlatformChar(context, (PlatformChar) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_CHAR_ARRAY:
				sequence_PlatformCharArray(context, (PlatformCharArray) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_CHARACTERISTIC_PATH_NODE:
				sequence_PlatformCharacteristicPathNode(context, (PlatformCharacteristicPathNode) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_COMPOSITE_QUERY:
				sequence_PlatformCompositeQuery(context, (PlatformCompositeQuery) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_COMPOSITION:
				sequence_PlatformComposition(context, (PlatformComposition) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_DATA_MODEL:
				sequence_PlatformDataModel(context, (PlatformDataModel) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_DOUBLE:
				sequence_PlatformDouble(context, (PlatformDouble) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_ENTITY:
				sequence_PlatformEntity(context, (PlatformEntity) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_ENUMERATION:
				sequence_PlatformEnumeration(context, (PlatformEnumeration) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_FIXED:
				sequence_PlatformFixed(context, (PlatformFixed) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_FLOAT:
				sequence_PlatformFloat(context, (PlatformFloat) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_LONG:
				sequence_PlatformLong(context, (PlatformLong) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_LONG_DOUBLE:
				sequence_PlatformLongDouble(context, (PlatformLongDouble) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_LONG_LONG:
				sequence_PlatformLongLong(context, (PlatformLongLong) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_OCTET:
				sequence_PlatformOctet(context, (PlatformOctet) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_PARTICIPANT:
				sequence_PlatformParticipant(context, (PlatformParticipant) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_PARTICIPANT_PATH_NODE:
				sequence_PlatformParticipantPathNode(context, (PlatformParticipantPathNode) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_QUERY:
				sequence_PlatformQuery(context, (PlatformQuery) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_QUERY_COMPOSITION:
				sequence_PlatformQueryComposition(context, (PlatformQueryComposition) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_SEQUENCE:
				sequence_PlatformSequence(context, (PlatformSequence) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_SHORT:
				sequence_PlatformShort(context, (PlatformShort) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_STRING:
				sequence_PlatformString(context, (PlatformString) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_STRUCT:
				sequence_PlatformStruct(context, (PlatformStruct) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_STRUCT_MEMBER:
				sequence_PlatformStructMember(context, (PlatformStructMember) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_ULONG:
				sequence_PlatformULong(context, (PlatformULong) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_ULONG_LONG:
				sequence_PlatformULongLong(context, (PlatformULongLong) semanticObject); 
				return; 
			case UddlPackage.PLATFORM_USHORT:
				sequence_PlatformUShort(context, (PlatformUShort) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArchitectureModel returns ArchitectureModel
	 *     FaceElement returns ArchitectureModel
	 *
	 * Constraint:
	 *     (name=ID description=STRING (dm+=DataModel | um+=UopUoPModel | im+=IntegrationIntegrationModel)+)
	 * </pre>
	 */
	protected void sequence_ArchitectureModel(ISerializationContext context, ArchitectureModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationIntegrationContext
	 *     IntegrationElement returns IntegrationIntegrationContext
	 *     IntegrationIntegrationContext returns IntegrationIntegrationContext
	 *
	 * Constraint:
	 *     (name=ID description=STRING node+=IntegrationTransportNode* connection+=IntegrationTSNodeConnection*)
	 * </pre>
	 */
	protected void sequence_IntegrationIntegrationContext(ISerializationContext context, IntegrationIntegrationContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationIntegrationModel
	 *     IntegrationIntegrationModel returns IntegrationIntegrationModel
	 *
	 * Constraint:
	 *     (name=ID description=STRING (im+=IntegrationIntegrationModel | element+=IntegrationElement)*)
	 * </pre>
	 */
	protected void sequence_IntegrationIntegrationModel(ISerializationContext context, IntegrationIntegrationModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegrationTSNodeConnection returns IntegrationTSNodeConnection
	 *
	 * Constraint:
	 *     (
	 *         (source=[IntegrationUoPOutputEndPoint|QN] destination=[IntegrationUoPInputEndPoint|QN]) | 
	 *         (source=[IntegrationUoPOutputEndPoint|QN] destination=[IntegrationTSNodeInputPort|QN]) | 
	 *         (source=[IntegrationTSNodeOutputPort|QN] destination=[IntegrationUoPInputEndPoint|QN]) | 
	 *         (source=[IntegrationTSNodeOutputPort|QN] destination=[IntegrationTSNodeInputPort|QN])
	 *     )
	 * </pre>
	 */
	protected void sequence_IntegrationTSNodeConnection(ISerializationContext context, IntegrationTSNodeConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegrationTSNodePortBase returns IntegrationTSNodeInputPort
	 *     IntegrationTSNodeInputPort returns IntegrationTSNodeInputPort
	 *
	 * Constraint:
	 *     view=[UopMessageType|QN]
	 * </pre>
	 */
	protected void sequence_IntegrationTSNodeInputPort(ISerializationContext context, IntegrationTSNodeInputPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.INTEGRATION_TS_NODE_INPUT_PORT__VIEW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.INTEGRATION_TS_NODE_INPUT_PORT__VIEW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegrationTSNodeInputPortAccess().getViewUopMessageTypeQNParserRuleCall_0_1(), semanticObject.eGet(FacePackage.Literals.INTEGRATION_TS_NODE_INPUT_PORT__VIEW, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegrationTSNodePortBase returns IntegrationTSNodeOutputPort
	 *     IntegrationTSNodeOutputPort returns IntegrationTSNodeOutputPort
	 *
	 * Constraint:
	 *     view=[UopMessageType|QN]
	 * </pre>
	 */
	protected void sequence_IntegrationTSNodeOutputPort(ISerializationContext context, IntegrationTSNodeOutputPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.INTEGRATION_TS_NODE_OUTPUT_PORT__VIEW) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.INTEGRATION_TS_NODE_OUTPUT_PORT__VIEW));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegrationTSNodeOutputPortAccess().getViewUopMessageTypeQNParserRuleCall_0_1(), semanticObject.eGet(FacePackage.Literals.INTEGRATION_TS_NODE_OUTPUT_PORT__VIEW, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationTransportChannel
	 *     IntegrationElement returns IntegrationTransportChannel
	 *     IntegrationTransportChannel returns IntegrationTransportChannel
	 *
	 * Constraint:
	 *     (name=ID description=STRING)
	 * </pre>
	 */
	protected void sequence_IntegrationTransportChannel(ISerializationContext context, IntegrationTransportChannel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.FACE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.FACE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.FACE_ELEMENT__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.FACE_ELEMENT__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegrationTransportChannelAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIntegrationTransportChannelAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegrationTSNodePortBase returns IntegrationUoPInputEndPoint
	 *     IntegrationUoPInputEndPoint returns IntegrationUoPInputEndPoint
	 *
	 * Constraint:
	 *     connection=[UopConnection|QN]
	 * </pre>
	 */
	protected void sequence_IntegrationUoPInputEndPoint(ISerializationContext context, IntegrationUoPInputEndPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.INTEGRATION_UO_PINPUT_END_POINT__CONNECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.INTEGRATION_UO_PINPUT_END_POINT__CONNECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegrationUoPInputEndPointAccess().getConnectionUopConnectionQNParserRuleCall_0_1(), semanticObject.eGet(FacePackage.Literals.INTEGRATION_UO_PINPUT_END_POINT__CONNECTION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationUoPInstance
	 *     IntegrationElement returns IntegrationUoPInstance
	 *     IntegrationUoPInstance returns IntegrationUoPInstance
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[UopUnitOfPortability|QN] 
	 *         configurationURI=STRING? 
	 *         input+=IntegrationUoPInputEndPoint* 
	 *         output+=IntegrationUoPOutputEndPoint*
	 *     )
	 * </pre>
	 */
	protected void sequence_IntegrationUoPInstance(ISerializationContext context, IntegrationUoPInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IntegrationTSNodePortBase returns IntegrationUoPOutputEndPoint
	 *     IntegrationUoPOutputEndPoint returns IntegrationUoPOutputEndPoint
	 *
	 * Constraint:
	 *     connection=[UopConnection|QN]
	 * </pre>
	 */
	protected void sequence_IntegrationUoPOutputEndPoint(ISerializationContext context, IntegrationUoPOutputEndPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.INTEGRATION_UO_POUTPUT_END_POINT__CONNECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.INTEGRATION_UO_POUTPUT_END_POINT__CONNECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegrationUoPOutputEndPointAccess().getConnectionUopConnectionQNParserRuleCall_0_1(), semanticObject.eGet(FacePackage.Literals.INTEGRATION_UO_POUTPUT_END_POINT__CONNECTION, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationViewAggregation
	 *     IntegrationTransportNode returns IntegrationViewAggregation
	 *     IntegrationViewAggregation returns IntegrationViewAggregation
	 *
	 * Constraint:
	 *     (name=ID description=STRING inPort+=IntegrationTSNodeInputPort+ outPort=IntegrationTSNodeOutputPort)
	 * </pre>
	 */
	protected void sequence_IntegrationViewAggregation(ISerializationContext context, IntegrationViewAggregation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationViewFilter
	 *     IntegrationTransportNode returns IntegrationViewFilter
	 *     IntegrationViewFilter returns IntegrationViewFilter
	 *
	 * Constraint:
	 *     (name=ID description=STRING inPort+=IntegrationTSNodeInputPort+ outPort=IntegrationTSNodeOutputPort?)
	 * </pre>
	 */
	protected void sequence_IntegrationViewFilter(ISerializationContext context, IntegrationViewFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationViewSink
	 *     IntegrationTransportNode returns IntegrationViewSink
	 *     IntegrationViewSink returns IntegrationViewSink
	 *
	 * Constraint:
	 *     (name=ID description=STRING inPort+=IntegrationTSNodeInputPort+ outPort=IntegrationTSNodeOutputPort?)
	 * </pre>
	 */
	protected void sequence_IntegrationViewSink(ISerializationContext context, IntegrationViewSink semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationViewSource
	 *     IntegrationTransportNode returns IntegrationViewSource
	 *     IntegrationViewSource returns IntegrationViewSource
	 *
	 * Constraint:
	 *     (name=ID description=STRING inPort+=IntegrationTSNodeInputPort* outPort=IntegrationTSNodeOutputPort)
	 * </pre>
	 */
	protected void sequence_IntegrationViewSource(ISerializationContext context, IntegrationViewSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationViewTransformation
	 *     IntegrationTransportNode returns IntegrationViewTransformation
	 *     IntegrationViewTransformation returns IntegrationViewTransformation
	 *
	 * Constraint:
	 *     (name=ID description=STRING inPort+=IntegrationTSNodeInputPort+ outPort=IntegrationTSNodeOutputPort)
	 * </pre>
	 */
	protected void sequence_IntegrationViewTransformation(ISerializationContext context, IntegrationViewTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns IntegrationViewTransporter
	 *     IntegrationTransportNode returns IntegrationViewTransporter
	 *     IntegrationViewTransporter returns IntegrationViewTransporter
	 *
	 * Constraint:
	 *     (name=ID description=STRING inPort+=IntegrationTSNodeInputPort+ outPort=IntegrationTSNodeOutputPort channel=[IntegrationTransportChannel|QN])
	 * </pre>
	 */
	protected void sequence_IntegrationViewTransporter(ISerializationContext context, IntegrationViewTransporter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopAbstractConnection returns UopAbstractConnection
	 *
	 * Constraint:
	 *     (name=ID description=STRING conceptualView=[ConceptualView|QN]? logicalView=[LogicalView|QN]?)
	 * </pre>
	 */
	protected void sequence_UopAbstractConnection(ISerializationContext context, UopAbstractConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopAbstractUoP
	 *     UopElement returns UopAbstractUoP
	 *     UopAbstractUoP returns UopAbstractUoP
	 *
	 * Constraint:
	 *     (name=ID description=STRING connection+=UopAbstractConnection*)
	 * </pre>
	 */
	protected void sequence_UopAbstractUoP(ISerializationContext context, UopAbstractUoP semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopConnection returns UopClientServerConnection
	 *     UopClientServerConnection returns UopClientServerConnection
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[UopAbstractConnection|QN]? 
	 *         requestType=[UopMessageType|QN] 
	 *         responseType=[UopMessageType|QN] 
	 *         synchronizationStyle=UopSynchronizationStyle? 
	 *         role=UoPClientServerRole 
	 *         period=FLOAT? 
	 *         mapsTo=[IntegrationTransportNode|QN]?
	 *     )
	 * </pre>
	 */
	protected void sequence_UopClientServerConnection(ISerializationContext context, UopClientServerConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopComponentFramework
	 *     UopElement returns UopComponentFramework
	 *     UopSupportingComponent returns UopComponentFramework
	 *     UopComponentFramework returns UopComponentFramework
	 *
	 * Constraint:
	 *     (name=ID version=ID description=STRING)
	 * </pre>
	 */
	protected void sequence_UopComponentFramework(ISerializationContext context, UopComponentFramework semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.FACE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.FACE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_SUPPORTING_COMPONENT__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_SUPPORTING_COMPONENT__VERSION));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.FACE_ELEMENT__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.FACE_ELEMENT__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUopComponentFrameworkAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUopComponentFrameworkAccess().getVersionIDTerminalRuleCall_3_0(), semanticObject.getVersion());
		feeder.accept(grammarAccess.getUopComponentFrameworkAccess().getDescriptionSTRINGTerminalRuleCall_4_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopCompositeTemplate
	 *     UopElement returns UopCompositeTemplate
	 *     UopMessageType returns UopCompositeTemplate
	 *     UopCompositeTemplate returns UopCompositeTemplate
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[LogicalCompositeQuery|QN]? 
	 *         isUnion?='isUnion' 
	 *         composition+=UopTemplateComposition 
	 *         composition+=UopTemplateComposition+
	 *     )
	 * </pre>
	 */
	protected void sequence_UopCompositeTemplate(ISerializationContext context, UopCompositeTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopLanguageRuntime
	 *     UopElement returns UopLanguageRuntime
	 *     UopSupportingComponent returns UopLanguageRuntime
	 *     UopLanguageRuntime returns UopLanguageRuntime
	 *
	 * Constraint:
	 *     (name=ID version=ID description=STRING)
	 * </pre>
	 */
	protected void sequence_UopLanguageRuntime(ISerializationContext context, UopLanguageRuntime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.FACE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.FACE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_SUPPORTING_COMPONENT__VERSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_SUPPORTING_COMPONENT__VERSION));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.FACE_ELEMENT__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.FACE_ELEMENT__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUopLanguageRuntimeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUopLanguageRuntimeAccess().getVersionIDTerminalRuleCall_3_0(), semanticObject.getVersion());
		feeder.accept(grammarAccess.getUopLanguageRuntimeAccess().getDescriptionSTRINGTerminalRuleCall_4_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopLifeCycleManagementPort returns UopLifeCycleManagementPort
	 *
	 * Constraint:
	 *     (messageExchangeType=UopMessageExchangeType lcmMessageType=[UopMessageType|QN])
	 * </pre>
	 */
	protected void sequence_UopLifeCycleManagementPort(ISerializationContext context, UopLifeCycleManagementPort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_LIFE_CYCLE_MANAGEMENT_PORT__MESSAGE_EXCHANGE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_LIFE_CYCLE_MANAGEMENT_PORT__MESSAGE_EXCHANGE_TYPE));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_LIFE_CYCLE_MANAGEMENT_PORT__LCM_MESSAGE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_LIFE_CYCLE_MANAGEMENT_PORT__LCM_MESSAGE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUopLifeCycleManagementPortAccess().getMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_1_0(), semanticObject.getMessageExchangeType());
		feeder.accept(grammarAccess.getUopLifeCycleManagementPortAccess().getLcmMessageTypeUopMessageTypeQNParserRuleCall_2_0_1(), semanticObject.eGet(FacePackage.Literals.UOP_LIFE_CYCLE_MANAGEMENT_PORT__LCM_MESSAGE_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopPlatformSpecificComponent
	 *     UopElement returns UopPlatformSpecificComponent
	 *     UopUnitOfPortability returns UopPlatformSpecificComponent
	 *     UopPlatformSpecificComponent returns UopPlatformSpecificComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[UopAbstractUoP|QN]? 
	 *         transportAPILanguage=UopProgrammingLanguage 
	 *         partitionType=UopPartitionType? 
	 *         faceProfile=UopFaceProfile? 
	 *         designAssuranceLevel=UopDesignAssuranceLevel? 
	 *         designAssuranceStandard=UopDesignAssuranceStandard? 
	 *         memoryRequirements=UopRAMMemoryRequirements? 
	 *         thread+=UopThread* 
	 *         supportingComponent+=[UopSupportingComponent|QN]* 
	 *         connection+=UopConnection+ 
	 *         (lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort?)? 
	 *         implementedBy=[IntegrationIntegrationContext|QN]?
	 *     )
	 * </pre>
	 */
	protected void sequence_UopPlatformSpecificComponent(ISerializationContext context, UopPlatformSpecificComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopPortableComponent
	 *     UopElement returns UopPortableComponent
	 *     UopUnitOfPortability returns UopPortableComponent
	 *     UopPortableComponent returns UopPortableComponent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[UopAbstractUoP|QN]? 
	 *         transportAPILanguage=UopProgrammingLanguage 
	 *         partitionType=UopPartitionType? 
	 *         faceProfile=UopFaceProfile? 
	 *         designAssuranceLevel=UopDesignAssuranceLevel? 
	 *         designAssuranceStandard=UopDesignAssuranceStandard? 
	 *         memoryRequirements=UopRAMMemoryRequirements? 
	 *         thread+=UopThread* 
	 *         supportingComponent+=[UopSupportingComponent|QN]* 
	 *         connection+=UopConnection+ 
	 *         (lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort?)? 
	 *         implementedBy=[IntegrationIntegrationContext|QN]?
	 *     )
	 * </pre>
	 */
	protected void sequence_UopPortableComponent(ISerializationContext context, UopPortableComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopConnection returns UopQueuingConnection
	 *     UopPubSubConnection returns UopQueuingConnection
	 *     UopQueuingConnection returns UopQueuingConnection
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[UopAbstractConnection|QN]? 
	 *         messageExchangeType=UopMessageExchangeType 
	 *         messageType=[UopMessageType|QN] 
	 *         synchronizationStyle=UopSynchronizationStyle? 
	 *         depth=INT? 
	 *         period=FLOAT? 
	 *         mapsTo=[IntegrationTransportNode|QN]?
	 *     )
	 * </pre>
	 */
	protected void sequence_UopQueuingConnection(ISerializationContext context, UopQueuingConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopRAMMemoryRequirements returns UopRAMMemoryRequirements
	 *
	 * Constraint:
	 *     (
	 *         heapStackMin=INT? 
	 *         heapStackTypical=INT? 
	 *         heapStackMax=INT? 
	 *         textMax=INT? 
	 *         roDataMax=INT? 
	 *         dataMax=INT? 
	 *         bssMax=INT?
	 *     )
	 * </pre>
	 */
	protected void sequence_UopRAMMemoryRequirements(ISerializationContext context, UopRAMMemoryRequirements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopConnection returns UopSingleInstanceMessageConnection
	 *     UopPubSubConnection returns UopSingleInstanceMessageConnection
	 *     UopSingleInstanceMessageConnection returns UopSingleInstanceMessageConnection
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         description=STRING 
	 *         realizes=[UopAbstractConnection|QN]? 
	 *         messageExchangeType=UopMessageExchangeType 
	 *         messageType=[UopMessageType|QN] 
	 *         synchronizationStyle=UopSynchronizationStyle? 
	 *         period=FLOAT? 
	 *         mapsTo=[IntegrationTransportNode|QN]?
	 *     )
	 * </pre>
	 */
	protected void sequence_UopSingleInstanceMessageConnection(ISerializationContext context, UopSingleInstanceMessageConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopTemplateComposition returns UopTemplateComposition
	 *
	 * Constraint:
	 *     (type=[UopMessageType|QN] rolename=STRING realizes=[LogicalQueryComposition|QN]?)
	 * </pre>
	 */
	protected void sequence_UopTemplateComposition(ISerializationContext context, UopTemplateComposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopTemplate
	 *     UopElement returns UopTemplate
	 *     UopMessageType returns UopTemplate
	 *     UopTemplate returns UopTemplate
	 *
	 * Constraint:
	 *     (name=ID description=STRING specification=STRING boundQuery=[PlatformQuery|QN] effectiveQuery=[PlatformQuery|QN]?)
	 * </pre>
	 */
	protected void sequence_UopTemplate(ISerializationContext context, UopTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UopThread returns UopThread
	 *
	 * Constraint:
	 *     (period=FLOAT timeCapacity=FLOAT relativePriority=INT relativeCoreAffinity=INT threadType=UopThreadType)
	 * </pre>
	 */
	protected void sequence_UopThread(ISerializationContext context, UopThread semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_THREAD__PERIOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_THREAD__PERIOD));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_THREAD__TIME_CAPACITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_THREAD__TIME_CAPACITY));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_THREAD__RELATIVE_PRIORITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_THREAD__RELATIVE_PRIORITY));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_THREAD__RELATIVE_CORE_AFFINITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_THREAD__RELATIVE_CORE_AFFINITY));
			if (transientValues.isValueTransient(semanticObject, FacePackage.Literals.UOP_THREAD__THREAD_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FacePackage.Literals.UOP_THREAD__THREAD_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUopThreadAccess().getPeriodFLOATTerminalRuleCall_2_0(), semanticObject.getPeriod());
		feeder.accept(grammarAccess.getUopThreadAccess().getTimeCapacityFLOATTerminalRuleCall_4_0(), semanticObject.getTimeCapacity());
		feeder.accept(grammarAccess.getUopThreadAccess().getRelativePriorityINTTerminalRuleCall_6_0(), semanticObject.getRelativePriority());
		feeder.accept(grammarAccess.getUopThreadAccess().getRelativeCoreAffinityINTTerminalRuleCall_8_0(), semanticObject.getRelativeCoreAffinity());
		feeder.accept(grammarAccess.getUopThreadAccess().getThreadTypeUopThreadTypeEnumRuleCall_10_0(), semanticObject.getThreadType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FaceElement returns UopUoPModel
	 *     UopUoPModel returns UopUoPModel
	 *
	 * Constraint:
	 *     (name=ID description=STRING (um+=UopUoPModel | element+=UopElement)+)
	 * </pre>
	 */
	protected void sequence_UopUoPModel(ISerializationContext context, UopUoPModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
