/*
 * generated by Xtext 2.30.0
 */
/*
 * Copyright (c) 2022, 2023 Epistimis LLC (http://www.epistimis.com).
 */
package com.epistimis.face.services;

import com.epistimis.uddl.services.UddlGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class FaceGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ArchitectureModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.ArchitectureModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAmKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cDmAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cDmDataModelParserRuleCall_4_0_0 = (RuleCall)cDmAssignment_4_0.eContents().get(0);
		private final Assignment cUmAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cUmUopUoPModelParserRuleCall_4_1_0 = (RuleCall)cUmAssignment_4_1.eContents().get(0);
		private final Assignment cImAssignment_4_2 = (Assignment)cAlternatives_4.eContents().get(2);
		private final RuleCall cImIntegrationIntegrationModelParserRuleCall_4_2_0 = (RuleCall)cImAssignment_4_2.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		////// Starter rule comes first
		////@Override
		////ModelFile:
		////    includes+=Include*
		////    archModel=ArchitectureModel
		////;
		///** An ArchitectureModel is a container for DataModels, UoPModels, IntegrationModels, and TraceabilityModels. */
		//ArchitectureModel:
		//    'am' name=ID description=STRING '{'
		//    (dm+=DataModel | um+=UopUoPModel | im+=IntegrationIntegrationModel)+
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'am' name=ID description=STRING '{'
		//(dm+=DataModel | um+=UopUoPModel | im+=IntegrationIntegrationModel)+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'am'
		public Keyword getAmKeyword_0() { return cAmKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(dm+=DataModel | um+=UopUoPModel | im+=IntegrationIntegrationModel)+
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//dm+=DataModel
		public Assignment getDmAssignment_4_0() { return cDmAssignment_4_0; }
		
		//DataModel
		public RuleCall getDmDataModelParserRuleCall_4_0_0() { return cDmDataModelParserRuleCall_4_0_0; }
		
		//um+=UopUoPModel
		public Assignment getUmAssignment_4_1() { return cUmAssignment_4_1; }
		
		//UopUoPModel
		public RuleCall getUmUopUoPModelParserRuleCall_4_1_0() { return cUmUopUoPModelParserRuleCall_4_1_0; }
		
		//im+=IntegrationIntegrationModel
		public Assignment getImAssignment_4_2() { return cImAssignment_4_2; }
		
		//IntegrationIntegrationModel
		public RuleCall getImIntegrationIntegrationModelParserRuleCall_4_2_0() { return cImIntegrationIntegrationModelParserRuleCall_4_2_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class FaceElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.FaceElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArchitectureModelParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopUoPModelParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegrationIntegrationModelParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUopElementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIntegrationElementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIntegrationTransportNodeParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		///** An Element is the root type for defining all named elements in the ArchitectureModel. The “name” attribute captures the name of the Element in the model. The “description” attribute captures a description for the element.
		// *  NOTE: Because of the way XText works, attributes bubble up from the bottom. So 'name' and 'description' are specified in leaf rules but show up in
		// *  the generated API for FaceElement
		// * */
		//FaceElement:
		//    ArchitectureModel |
		//    UopUoPModel |
		//    IntegrationIntegrationModel |
		//    UopElement |
		//    IntegrationElement |
		//    IntegrationTransportNode
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//ArchitectureModel |
		//UopUoPModel |
		//IntegrationIntegrationModel |
		//UopElement |
		//IntegrationElement |
		//IntegrationTransportNode
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ArchitectureModel
		public RuleCall getArchitectureModelParserRuleCall_0() { return cArchitectureModelParserRuleCall_0; }
		
		//UopUoPModel
		public RuleCall getUopUoPModelParserRuleCall_1() { return cUopUoPModelParserRuleCall_1; }
		
		//IntegrationIntegrationModel
		public RuleCall getIntegrationIntegrationModelParserRuleCall_2() { return cIntegrationIntegrationModelParserRuleCall_2; }
		
		//UopElement
		public RuleCall getUopElementParserRuleCall_3() { return cUopElementParserRuleCall_3; }
		
		//IntegrationElement
		public RuleCall getIntegrationElementParserRuleCall_4() { return cIntegrationElementParserRuleCall_4; }
		
		//IntegrationTransportNode
		public RuleCall getIntegrationTransportNodeParserRuleCall_5() { return cIntegrationTransportNodeParserRuleCall_5; }
	}
	public class UopUoPModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopUoPModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUmKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cUmAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cUmUopUoPModelParserRuleCall_4_0_0 = (RuleCall)cUmAssignment_4_0.eContents().get(0);
		private final Assignment cElementAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cElementUopElementParserRuleCall_4_1_0 = (RuleCall)cElementAssignment_4_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		///** A UoPModel is a container for UoC Elements. */
		//UopUoPModel:
		//    'um' name=ID description=STRING '{'
		//        (um+=UopUoPModel | element +=UopElement)+
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'um' name=ID description=STRING '{'
		//    (um+=UopUoPModel | element +=UopElement)+
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'um'
		public Keyword getUmKeyword_0() { return cUmKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(um+=UopUoPModel | element +=UopElement)+
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//um+=UopUoPModel
		public Assignment getUmAssignment_4_0() { return cUmAssignment_4_0; }
		
		//UopUoPModel
		public RuleCall getUmUopUoPModelParserRuleCall_4_0_0() { return cUmUopUoPModelParserRuleCall_4_0_0; }
		
		//element +=UopElement
		public Assignment getElementAssignment_4_1() { return cElementAssignment_4_1; }
		
		//UopElement
		public RuleCall getElementUopElementParserRuleCall_4_1_0() { return cElementUopElementParserRuleCall_4_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class UopElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUopSupportingComponentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopUnitOfPortabilityParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cUopAbstractUoPParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUopMessageTypeParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		///** A uop Element is the root type for defining the component elements of the ArchitectureModel. */
		//UopElement:
		//    UopSupportingComponent |
		//    UopUnitOfPortability |
		//    UopAbstractUoP |
		//    UopMessageType
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UopSupportingComponent |
		//UopUnitOfPortability |
		//UopAbstractUoP |
		//UopMessageType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UopSupportingComponent
		public RuleCall getUopSupportingComponentParserRuleCall_0() { return cUopSupportingComponentParserRuleCall_0; }
		
		//UopUnitOfPortability
		public RuleCall getUopUnitOfPortabilityParserRuleCall_1() { return cUopUnitOfPortabilityParserRuleCall_1; }
		
		//UopAbstractUoP
		public RuleCall getUopAbstractUoPParserRuleCall_2() { return cUopAbstractUoPParserRuleCall_2; }
		
		//UopMessageType
		public RuleCall getUopMessageTypeParserRuleCall_3() { return cUopMessageTypeParserRuleCall_3; }
	}
	public class UopSupportingComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopSupportingComponent");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUopComponentFrameworkParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopLanguageRuntimeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///** A SupportingComponent is a LanguageRunTime or ApplicationFramework. The “version” attribute is the version of the SupportingComponent. */
		//UopSupportingComponent:
		//    UopComponentFramework |
		//    UopLanguageRuntime
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UopComponentFramework |
		//UopLanguageRuntime
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UopComponentFramework
		public RuleCall getUopComponentFrameworkParserRuleCall_0() { return cUopComponentFrameworkParserRuleCall_0; }
		
		//UopLanguageRuntime
		public RuleCall getUopLanguageRuntimeParserRuleCall_1() { return cUopLanguageRuntimeParserRuleCall_1; }
	}
	public class UopLanguageRuntimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopLanguageRuntime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRuntimeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVersionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVersionIDTerminalRuleCall_3_0 = (RuleCall)cVersionAssignment_3.eContents().get(0);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		///** A LanguageRunTime is a language run-time as defined in Section 4.2.3. */
		//UopLanguageRuntime:
		//    'runtime' name=ID ':' version=ID description=STRING ';'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'runtime' name=ID ':' version=ID description=STRING ';'
		public Group getGroup() { return cGroup; }
		
		//'runtime'
		public Keyword getRuntimeKeyword_0() { return cRuntimeKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//version=ID
		public Assignment getVersionAssignment_3() { return cVersionAssignment_3; }
		
		//ID
		public RuleCall getVersionIDTerminalRuleCall_3_0() { return cVersionIDTerminalRuleCall_3_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_4_0() { return cDescriptionSTRINGTerminalRuleCall_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class UopComponentFrameworkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopComponentFramework");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFrameworkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVersionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVersionIDTerminalRuleCall_3_0 = (RuleCall)cVersionAssignment_3.eContents().get(0);
		private final Assignment cDescriptionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_4_0 = (RuleCall)cDescriptionAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		///** A ComponentFramework is an application framework as defined in Section 4.2.4. */
		//UopComponentFramework:
		//    'framework' name=ID ':' version=ID description=STRING ';'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'framework' name=ID ':' version=ID description=STRING ';'
		public Group getGroup() { return cGroup; }
		
		//'framework'
		public Keyword getFrameworkKeyword_0() { return cFrameworkKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//version=ID
		public Assignment getVersionAssignment_3() { return cVersionAssignment_3; }
		
		//ID
		public RuleCall getVersionIDTerminalRuleCall_3_0() { return cVersionIDTerminalRuleCall_3_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_4() { return cDescriptionAssignment_4; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_4_0() { return cDescriptionSTRINGTerminalRuleCall_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class UopAbstractUoPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopAbstractUoP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAUoPKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cConnectionAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cConnectionUopAbstractConnectionParserRuleCall_4_0 = (RuleCall)cConnectionAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		///** An AbstractUoP is used to capture the specification of a UoP. */
		//UopAbstractUoP:
		//    'aUoP' name=ID description=STRING '{'
		//        (connection+=UopAbstractConnection)*
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'aUoP' name=ID description=STRING '{'
		//    (connection+=UopAbstractConnection)*
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'aUoP'
		public Keyword getAUoPKeyword_0() { return cAUoPKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(connection+=UopAbstractConnection)*
		public Assignment getConnectionAssignment_4() { return cConnectionAssignment_4; }
		
		//UopAbstractConnection
		public RuleCall getConnectionUopAbstractConnectionParserRuleCall_4_0() { return cConnectionUopAbstractConnectionParserRuleCall_4_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_5() { return cRightCurlyBracketSemicolonKeyword_5; }
	}
	public class UopAbstractConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopAbstractConnection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAconnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cConceptualViewAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final CrossReference cConceptualViewConceptualViewCrossReference_4_1_0 = (CrossReference)cConceptualViewAssignment_4_1.eContents().get(0);
		private final RuleCall cConceptualViewConceptualViewQNParserRuleCall_4_1_0_1 = (RuleCall)cConceptualViewConceptualViewCrossReference_4_1_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cLKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cLogicalViewAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final CrossReference cLogicalViewLogicalViewCrossReference_5_1_0 = (CrossReference)cLogicalViewAssignment_5_1.eContents().get(0);
		private final RuleCall cLogicalViewLogicalViewQNParserRuleCall_5_1_0_1 = (RuleCall)cLogicalViewLogicalViewCrossReference_5_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketSemicolonKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///** An AbstractConnection captures the input and output characteristics of an AbstractUoP by specifying data at a Logical or Conceptual level. */
		//UopAbstractConnection:
		//    'aconn' name=ID description=STRING '{'
		//        ( 'c' conceptualView=[uddl::ConceptualView|QN])?
		//        ( 'l' logicalView=[uddl::LogicalView|QN])?
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'aconn' name=ID description=STRING '{'
		//    ( 'c' conceptualView=[uddl::ConceptualView|QN])?
		//    ( 'l' logicalView=[uddl::LogicalView|QN])?
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'aconn'
		public Keyword getAconnKeyword_0() { return cAconnKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//( 'c' conceptualView=[uddl::ConceptualView|QN])?
		public Group getGroup_4() { return cGroup_4; }
		
		//'c'
		public Keyword getCKeyword_4_0() { return cCKeyword_4_0; }
		
		//conceptualView=[uddl::ConceptualView|QN]
		public Assignment getConceptualViewAssignment_4_1() { return cConceptualViewAssignment_4_1; }
		
		//[uddl::ConceptualView|QN]
		public CrossReference getConceptualViewConceptualViewCrossReference_4_1_0() { return cConceptualViewConceptualViewCrossReference_4_1_0; }
		
		//QN
		public RuleCall getConceptualViewConceptualViewQNParserRuleCall_4_1_0_1() { return cConceptualViewConceptualViewQNParserRuleCall_4_1_0_1; }
		
		//( 'l' logicalView=[uddl::LogicalView|QN])?
		public Group getGroup_5() { return cGroup_5; }
		
		//'l'
		public Keyword getLKeyword_5_0() { return cLKeyword_5_0; }
		
		//logicalView=[uddl::LogicalView|QN]
		public Assignment getLogicalViewAssignment_5_1() { return cLogicalViewAssignment_5_1; }
		
		//[uddl::LogicalView|QN]
		public CrossReference getLogicalViewLogicalViewCrossReference_5_1_0() { return cLogicalViewLogicalViewCrossReference_5_1_0; }
		
		//QN
		public RuleCall getLogicalViewLogicalViewQNParserRuleCall_5_1_0_1() { return cLogicalViewLogicalViewQNParserRuleCall_5_1_0_1; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_6() { return cRightCurlyBracketSemicolonKeyword_6; }
	}
	public class UopUnitOfPortabilityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopUnitOfPortability");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUopPortableComponentParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopPlatformSpecificComponentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///** A UnitOfPortability is a FACE PlatformSpecificComponent or PortableComponent. */
		//UopUnitOfPortability:
		//    UopPortableComponent |
		//    UopPlatformSpecificComponent
		//    ;
		@Override public ParserRule getRule() { return rule; }
		
		//UopPortableComponent |
		//UopPlatformSpecificComponent
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UopPortableComponent
		public RuleCall getUopPortableComponentParserRuleCall_0() { return cUopPortableComponentParserRuleCall_0; }
		
		//UopPlatformSpecificComponent
		public RuleCall getUopPlatformSpecificComponentParserRuleCall_1() { return cUopPlatformSpecificComponentParserRuleCall_1; }
	}
	public class UopPortableComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopPortableComponent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPcKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRealizesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cRealizesUopAbstractUoPCrossReference_3_1_0 = (CrossReference)cRealizesAssignment_3_1.eContents().get(0);
		private final RuleCall cRealizesUopAbstractUoPQNParserRuleCall_3_1_0_1 = (RuleCall)cRealizesUopAbstractUoPCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLangKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTransportAPILanguageAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTransportAPILanguageUopProgrammingLanguageEnumRuleCall_6_0 = (RuleCall)cTransportAPILanguageAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cPartKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cPartitionTypeAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cPartitionTypeUopPartitionTypeEnumRuleCall_7_1_0 = (RuleCall)cPartitionTypeAssignment_7_1.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cProfKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cFaceProfileAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cFaceProfileUopFaceProfileEnumRuleCall_8_1_0 = (RuleCall)cFaceProfileAssignment_8_1.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cDALKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cDesignAssuranceLevelAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cDesignAssuranceLevelUopDesignAssuranceLevelEnumRuleCall_9_1_0 = (RuleCall)cDesignAssuranceLevelAssignment_9_1.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cDASKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cDesignAssuranceStandardAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cDesignAssuranceStandardUopDesignAssuranceStandardEnumRuleCall_10_1_0 = (RuleCall)cDesignAssuranceStandardAssignment_10_1.eContents().get(0);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cRAMKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMemoryRequirementsAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cMemoryRequirementsUopRAMMemoryRequirementsParserRuleCall_11_1_0 = (RuleCall)cMemoryRequirementsAssignment_11_1.eContents().get(0);
		private final Group cGroup_12 = (Group)cGroup.eContents().get(12);
		private final Keyword cThreadKeyword_12_0 = (Keyword)cGroup_12.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_12_1 = (Keyword)cGroup_12.eContents().get(1);
		private final Assignment cThreadAssignment_12_2 = (Assignment)cGroup_12.eContents().get(2);
		private final RuleCall cThreadUopThreadParserRuleCall_12_2_0 = (RuleCall)cThreadAssignment_12_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_12_3 = (Keyword)cGroup_12.eContents().get(3);
		private final Group cGroup_13 = (Group)cGroup.eContents().get(13);
		private final Keyword cSupportKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_13_1 = (Keyword)cGroup_13.eContents().get(1);
		private final Assignment cSupportingComponentAssignment_13_2 = (Assignment)cGroup_13.eContents().get(2);
		private final CrossReference cSupportingComponentUopSupportingComponentCrossReference_13_2_0 = (CrossReference)cSupportingComponentAssignment_13_2.eContents().get(0);
		private final RuleCall cSupportingComponentUopSupportingComponentQNParserRuleCall_13_2_0_1 = (RuleCall)cSupportingComponentUopSupportingComponentCrossReference_13_2_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_13_3 = (Keyword)cGroup_13.eContents().get(3);
		private final Keyword cConnKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cLeftSquareBracketKeyword_15 = (Keyword)cGroup.eContents().get(15);
		private final Assignment cConnectionAssignment_16 = (Assignment)cGroup.eContents().get(16);
		private final RuleCall cConnectionUopConnectionParserRuleCall_16_0 = (RuleCall)cConnectionAssignment_16.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_17 = (Keyword)cGroup.eContents().get(17);
		private final Group cGroup_18 = (Group)cGroup.eContents().get(18);
		private final Keyword cLcmKeyword_18_0 = (Keyword)cGroup_18.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_18_1 = (Keyword)cGroup_18.eContents().get(1);
		private final Assignment cLcmPortAssignment_18_2 = (Assignment)cGroup_18.eContents().get(2);
		private final RuleCall cLcmPortUopLifeCycleManagementPortParserRuleCall_18_2_0 = (RuleCall)cLcmPortAssignment_18_2.eContents().get(0);
		private final Assignment cLcmPortAssignment_18_3 = (Assignment)cGroup_18.eContents().get(3);
		private final RuleCall cLcmPortUopLifeCycleManagementPortParserRuleCall_18_3_0 = (RuleCall)cLcmPortAssignment_18_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_18_4 = (Keyword)cGroup_18.eContents().get(4);
		private final Group cGroup_19 = (Group)cGroup.eContents().get(19);
		private final Keyword cImplementedByKeyword_19_0 = (Keyword)cGroup_19.eContents().get(0);
		private final Assignment cImplementedByAssignment_19_1 = (Assignment)cGroup_19.eContents().get(1);
		private final CrossReference cImplementedByIntegrationIntegrationContextCrossReference_19_1_0 = (CrossReference)cImplementedByAssignment_19_1.eContents().get(0);
		private final RuleCall cImplementedByIntegrationIntegrationContextQNParserRuleCall_19_1_0_1 = (RuleCall)cImplementedByIntegrationIntegrationContextCrossReference_19_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketSemicolonKeyword_20 = (Keyword)cGroup.eContents().get(20);
		
		///** A PortableComponent is a software component as defined by the PCS. */
		//UopPortableComponent:
		//    'pc'  name=ID description=STRING ('->' realizes=[UopAbstractUoP|QN])? '{'
		//        'lang:' transportAPILanguage=UopProgrammingLanguage
		//        ('part:' partitionType=UopPartitionType)?     // EXTENSION: making partitionType optional
		//        ('prof:' faceProfile=UopFaceProfile)?          // EXTENSION: making faceProfile optional
		//        ('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
		//        ('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
		//        ('RAM:' memoryRequirements=UopRAMMemoryRequirements)? // EXTENSION: making memoryRequirements optional
		//        ('thread:' '[' thread+=UopThread+ ']')?        // EXTENSION: making thread optional
		//        ('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
		//        'conn:' '[' connection+=UopConnection+ ']'
		//        ('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
		//        ('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])? // EXTENSION: can supply a wiring diagram with implementation details
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'pc'  name=ID description=STRING ('->' realizes=[UopAbstractUoP|QN])? '{'
		//    'lang:' transportAPILanguage=UopProgrammingLanguage
		//    ('part:' partitionType=UopPartitionType)?     // EXTENSION: making partitionType optional
		//    ('prof:' faceProfile=UopFaceProfile)?          // EXTENSION: making faceProfile optional
		//    ('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
		//    ('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
		//    ('RAM:' memoryRequirements=UopRAMMemoryRequirements)? // EXTENSION: making memoryRequirements optional
		//    ('thread:' '[' thread+=UopThread+ ']')?        // EXTENSION: making thread optional
		//    ('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
		//    'conn:' '[' connection+=UopConnection+ ']'
		//    ('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
		//    ('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])? // EXTENSION: can supply a wiring diagram with implementation details
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'pc'
		public Keyword getPcKeyword_0() { return cPcKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//('->' realizes=[UopAbstractUoP|QN])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_0() { return cHyphenMinusGreaterThanSignKeyword_3_0; }
		
		//realizes=[UopAbstractUoP|QN]
		public Assignment getRealizesAssignment_3_1() { return cRealizesAssignment_3_1; }
		
		//[UopAbstractUoP|QN]
		public CrossReference getRealizesUopAbstractUoPCrossReference_3_1_0() { return cRealizesUopAbstractUoPCrossReference_3_1_0; }
		
		//QN
		public RuleCall getRealizesUopAbstractUoPQNParserRuleCall_3_1_0_1() { return cRealizesUopAbstractUoPQNParserRuleCall_3_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//'lang:'
		public Keyword getLangKeyword_5() { return cLangKeyword_5; }
		
		//transportAPILanguage=UopProgrammingLanguage
		public Assignment getTransportAPILanguageAssignment_6() { return cTransportAPILanguageAssignment_6; }
		
		//UopProgrammingLanguage
		public RuleCall getTransportAPILanguageUopProgrammingLanguageEnumRuleCall_6_0() { return cTransportAPILanguageUopProgrammingLanguageEnumRuleCall_6_0; }
		
		//('part:' partitionType=UopPartitionType)?
		public Group getGroup_7() { return cGroup_7; }
		
		//'part:'
		public Keyword getPartKeyword_7_0() { return cPartKeyword_7_0; }
		
		//partitionType=UopPartitionType
		public Assignment getPartitionTypeAssignment_7_1() { return cPartitionTypeAssignment_7_1; }
		
		//UopPartitionType
		public RuleCall getPartitionTypeUopPartitionTypeEnumRuleCall_7_1_0() { return cPartitionTypeUopPartitionTypeEnumRuleCall_7_1_0; }
		
		//// EXTENSION: making partitionType optional
		//   ('prof:' faceProfile=UopFaceProfile)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'prof:'
		public Keyword getProfKeyword_8_0() { return cProfKeyword_8_0; }
		
		//faceProfile=UopFaceProfile
		public Assignment getFaceProfileAssignment_8_1() { return cFaceProfileAssignment_8_1; }
		
		//UopFaceProfile
		public RuleCall getFaceProfileUopFaceProfileEnumRuleCall_8_1_0() { return cFaceProfileUopFaceProfileEnumRuleCall_8_1_0; }
		
		//  // EXTENSION: making faceProfile optional
		//('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
		public Group getGroup_9() { return cGroup_9; }
		
		//'DAL:'
		public Keyword getDALKeyword_9_0() { return cDALKeyword_9_0; }
		
		//designAssuranceLevel=UopDesignAssuranceLevel
		public Assignment getDesignAssuranceLevelAssignment_9_1() { return cDesignAssuranceLevelAssignment_9_1; }
		
		//UopDesignAssuranceLevel
		public RuleCall getDesignAssuranceLevelUopDesignAssuranceLevelEnumRuleCall_9_1_0() { return cDesignAssuranceLevelUopDesignAssuranceLevelEnumRuleCall_9_1_0; }
		
		//('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
		public Group getGroup_10() { return cGroup_10; }
		
		//'DAS:'
		public Keyword getDASKeyword_10_0() { return cDASKeyword_10_0; }
		
		//designAssuranceStandard=UopDesignAssuranceStandard
		public Assignment getDesignAssuranceStandardAssignment_10_1() { return cDesignAssuranceStandardAssignment_10_1; }
		
		//UopDesignAssuranceStandard
		public RuleCall getDesignAssuranceStandardUopDesignAssuranceStandardEnumRuleCall_10_1_0() { return cDesignAssuranceStandardUopDesignAssuranceStandardEnumRuleCall_10_1_0; }
		
		//('RAM:' memoryRequirements=UopRAMMemoryRequirements)?
		public Group getGroup_11() { return cGroup_11; }
		
		//'RAM:'
		public Keyword getRAMKeyword_11_0() { return cRAMKeyword_11_0; }
		
		//memoryRequirements=UopRAMMemoryRequirements
		public Assignment getMemoryRequirementsAssignment_11_1() { return cMemoryRequirementsAssignment_11_1; }
		
		//UopRAMMemoryRequirements
		public RuleCall getMemoryRequirementsUopRAMMemoryRequirementsParserRuleCall_11_1_0() { return cMemoryRequirementsUopRAMMemoryRequirementsParserRuleCall_11_1_0; }
		
		//// EXTENSION: making memoryRequirements optional
		//       ('thread:' '[' thread+=UopThread+ ']')?
		public Group getGroup_12() { return cGroup_12; }
		
		//'thread:'
		public Keyword getThreadKeyword_12_0() { return cThreadKeyword_12_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_12_1() { return cLeftSquareBracketKeyword_12_1; }
		
		//thread+=UopThread+
		public Assignment getThreadAssignment_12_2() { return cThreadAssignment_12_2; }
		
		//UopThread
		public RuleCall getThreadUopThreadParserRuleCall_12_2_0() { return cThreadUopThreadParserRuleCall_12_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_12_3() { return cRightSquareBracketKeyword_12_3; }
		
		//// EXTENSION: making thread optional
		//('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
		public Group getGroup_13() { return cGroup_13; }
		
		//'support:'
		public Keyword getSupportKeyword_13_0() { return cSupportKeyword_13_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_13_1() { return cLeftSquareBracketKeyword_13_1; }
		
		//supportingComponent+=[UopSupportingComponent|QN]+
		public Assignment getSupportingComponentAssignment_13_2() { return cSupportingComponentAssignment_13_2; }
		
		//[UopSupportingComponent|QN]
		public CrossReference getSupportingComponentUopSupportingComponentCrossReference_13_2_0() { return cSupportingComponentUopSupportingComponentCrossReference_13_2_0; }
		
		//QN
		public RuleCall getSupportingComponentUopSupportingComponentQNParserRuleCall_13_2_0_1() { return cSupportingComponentUopSupportingComponentQNParserRuleCall_13_2_0_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_13_3() { return cRightSquareBracketKeyword_13_3; }
		
		//'conn:'
		public Keyword getConnKeyword_14() { return cConnKeyword_14; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_15() { return cLeftSquareBracketKeyword_15; }
		
		//connection+=UopConnection+
		public Assignment getConnectionAssignment_16() { return cConnectionAssignment_16; }
		
		//UopConnection
		public RuleCall getConnectionUopConnectionParserRuleCall_16_0() { return cConnectionUopConnectionParserRuleCall_16_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_17() { return cRightSquareBracketKeyword_17; }
		
		//('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
		public Group getGroup_18() { return cGroup_18; }
		
		//'lcm:'
		public Keyword getLcmKeyword_18_0() { return cLcmKeyword_18_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_18_1() { return cLeftSquareBracketKeyword_18_1; }
		
		//lcmPort+=UopLifeCycleManagementPort
		public Assignment getLcmPortAssignment_18_2() { return cLcmPortAssignment_18_2; }
		
		//UopLifeCycleManagementPort
		public RuleCall getLcmPortUopLifeCycleManagementPortParserRuleCall_18_2_0() { return cLcmPortUopLifeCycleManagementPortParserRuleCall_18_2_0; }
		
		//lcmPort+=UopLifeCycleManagementPort?
		public Assignment getLcmPortAssignment_18_3() { return cLcmPortAssignment_18_3; }
		
		//UopLifeCycleManagementPort
		public RuleCall getLcmPortUopLifeCycleManagementPortParserRuleCall_18_3_0() { return cLcmPortUopLifeCycleManagementPortParserRuleCall_18_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_18_4() { return cRightSquareBracketKeyword_18_4; }
		
		//('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])?
		public Group getGroup_19() { return cGroup_19; }
		
		//'implementedBy:'
		public Keyword getImplementedByKeyword_19_0() { return cImplementedByKeyword_19_0; }
		
		//implementedBy=[IntegrationIntegrationContext|QN]
		public Assignment getImplementedByAssignment_19_1() { return cImplementedByAssignment_19_1; }
		
		//[IntegrationIntegrationContext|QN]
		public CrossReference getImplementedByIntegrationIntegrationContextCrossReference_19_1_0() { return cImplementedByIntegrationIntegrationContextCrossReference_19_1_0; }
		
		//QN
		public RuleCall getImplementedByIntegrationIntegrationContextQNParserRuleCall_19_1_0_1() { return cImplementedByIntegrationIntegrationContextQNParserRuleCall_19_1_0_1; }
		
		//// EXTENSION: can supply a wiring diagram with implementation details
		//   '};'
		public Keyword getRightCurlyBracketSemicolonKeyword_20() { return cRightCurlyBracketSemicolonKeyword_20; }
	}
	public class UopPlatformSpecificComponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopPlatformSpecificComponent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPscKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRealizesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cRealizesUopAbstractUoPCrossReference_3_1_0 = (CrossReference)cRealizesAssignment_3_1.eContents().get(0);
		private final RuleCall cRealizesUopAbstractUoPQNParserRuleCall_3_1_0_1 = (RuleCall)cRealizesUopAbstractUoPCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLangKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTransportAPILanguageAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTransportAPILanguageUopProgrammingLanguageEnumRuleCall_6_0 = (RuleCall)cTransportAPILanguageAssignment_6.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cPartKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Assignment cPartitionTypeAssignment_7_1 = (Assignment)cGroup_7.eContents().get(1);
		private final RuleCall cPartitionTypeUopPartitionTypeEnumRuleCall_7_1_0 = (RuleCall)cPartitionTypeAssignment_7_1.eContents().get(0);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cProfKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cFaceProfileAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cFaceProfileUopFaceProfileEnumRuleCall_8_1_0 = (RuleCall)cFaceProfileAssignment_8_1.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cDALKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cDesignAssuranceLevelAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cDesignAssuranceLevelUopDesignAssuranceLevelEnumRuleCall_9_1_0 = (RuleCall)cDesignAssuranceLevelAssignment_9_1.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cDASKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cDesignAssuranceStandardAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cDesignAssuranceStandardUopDesignAssuranceStandardEnumRuleCall_10_1_0 = (RuleCall)cDesignAssuranceStandardAssignment_10_1.eContents().get(0);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cRAMKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMemoryRequirementsAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final RuleCall cMemoryRequirementsUopRAMMemoryRequirementsParserRuleCall_11_1_0 = (RuleCall)cMemoryRequirementsAssignment_11_1.eContents().get(0);
		private final Group cGroup_12 = (Group)cGroup.eContents().get(12);
		private final Keyword cThreadKeyword_12_0 = (Keyword)cGroup_12.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_12_1 = (Keyword)cGroup_12.eContents().get(1);
		private final Assignment cThreadAssignment_12_2 = (Assignment)cGroup_12.eContents().get(2);
		private final RuleCall cThreadUopThreadParserRuleCall_12_2_0 = (RuleCall)cThreadAssignment_12_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_12_3 = (Keyword)cGroup_12.eContents().get(3);
		private final Group cGroup_13 = (Group)cGroup.eContents().get(13);
		private final Keyword cSupportKeyword_13_0 = (Keyword)cGroup_13.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_13_1 = (Keyword)cGroup_13.eContents().get(1);
		private final Assignment cSupportingComponentAssignment_13_2 = (Assignment)cGroup_13.eContents().get(2);
		private final CrossReference cSupportingComponentUopSupportingComponentCrossReference_13_2_0 = (CrossReference)cSupportingComponentAssignment_13_2.eContents().get(0);
		private final RuleCall cSupportingComponentUopSupportingComponentQNParserRuleCall_13_2_0_1 = (RuleCall)cSupportingComponentUopSupportingComponentCrossReference_13_2_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_13_3 = (Keyword)cGroup_13.eContents().get(3);
		private final Keyword cConnKeyword_14 = (Keyword)cGroup.eContents().get(14);
		private final Keyword cLeftSquareBracketKeyword_15 = (Keyword)cGroup.eContents().get(15);
		private final Assignment cConnectionAssignment_16 = (Assignment)cGroup.eContents().get(16);
		private final RuleCall cConnectionUopConnectionParserRuleCall_16_0 = (RuleCall)cConnectionAssignment_16.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_17 = (Keyword)cGroup.eContents().get(17);
		private final Group cGroup_18 = (Group)cGroup.eContents().get(18);
		private final Keyword cLcmKeyword_18_0 = (Keyword)cGroup_18.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_18_1 = (Keyword)cGroup_18.eContents().get(1);
		private final Assignment cLcmPortAssignment_18_2 = (Assignment)cGroup_18.eContents().get(2);
		private final RuleCall cLcmPortUopLifeCycleManagementPortParserRuleCall_18_2_0 = (RuleCall)cLcmPortAssignment_18_2.eContents().get(0);
		private final Assignment cLcmPortAssignment_18_3 = (Assignment)cGroup_18.eContents().get(3);
		private final RuleCall cLcmPortUopLifeCycleManagementPortParserRuleCall_18_3_0 = (RuleCall)cLcmPortAssignment_18_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_18_4 = (Keyword)cGroup_18.eContents().get(4);
		private final Group cGroup_19 = (Group)cGroup.eContents().get(19);
		private final Keyword cImplementedByKeyword_19_0 = (Keyword)cGroup_19.eContents().get(0);
		private final Assignment cImplementedByAssignment_19_1 = (Assignment)cGroup_19.eContents().get(1);
		private final CrossReference cImplementedByIntegrationIntegrationContextCrossReference_19_1_0 = (CrossReference)cImplementedByAssignment_19_1.eContents().get(0);
		private final RuleCall cImplementedByIntegrationIntegrationContextQNParserRuleCall_19_1_0_1 = (RuleCall)cImplementedByIntegrationIntegrationContextCrossReference_19_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketSemicolonKeyword_20 = (Keyword)cGroup.eContents().get(20);
		
		///** A PlatformSpecificComponent is a software component as defined by the PSSS. */
		//UopPlatformSpecificComponent:
		//     'psc' name=ID description=STRING ('->' realizes=[UopAbstractUoP|QN])? '{'
		//        'lang:' transportAPILanguage=UopProgrammingLanguage
		//        ('part:' partitionType=UopPartitionType)?     // EXTENSION: making partitionType optional
		//        ('prof:' faceProfile=UopFaceProfile)?          // EXTENSION: making faceProfile optional
		//        ('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
		//        ('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
		//        ('RAM:' memoryRequirements=UopRAMMemoryRequirements)? // EXTENSION: making memoryRequirements optional
		//        ('thread:' '[' thread+=UopThread+ ']')?        // EXTENSION: making thread optional
		//        ('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
		//        'conn:' '[' connection+=UopConnection+ ']'
		//        ('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
		//        ('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])? // EXTENSION: can supply a wiring diagram with implementation details
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		// 'psc' name=ID description=STRING ('->' realizes=[UopAbstractUoP|QN])? '{'
		//    'lang:' transportAPILanguage=UopProgrammingLanguage
		//    ('part:' partitionType=UopPartitionType)?     // EXTENSION: making partitionType optional
		//    ('prof:' faceProfile=UopFaceProfile)?          // EXTENSION: making faceProfile optional
		//    ('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
		//    ('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
		//    ('RAM:' memoryRequirements=UopRAMMemoryRequirements)? // EXTENSION: making memoryRequirements optional
		//    ('thread:' '[' thread+=UopThread+ ']')?        // EXTENSION: making thread optional
		//    ('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
		//    'conn:' '[' connection+=UopConnection+ ']'
		//    ('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
		//    ('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])? // EXTENSION: can supply a wiring diagram with implementation details
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'psc'
		public Keyword getPscKeyword_0() { return cPscKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//('->' realizes=[UopAbstractUoP|QN])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_0() { return cHyphenMinusGreaterThanSignKeyword_3_0; }
		
		//realizes=[UopAbstractUoP|QN]
		public Assignment getRealizesAssignment_3_1() { return cRealizesAssignment_3_1; }
		
		//[UopAbstractUoP|QN]
		public CrossReference getRealizesUopAbstractUoPCrossReference_3_1_0() { return cRealizesUopAbstractUoPCrossReference_3_1_0; }
		
		//QN
		public RuleCall getRealizesUopAbstractUoPQNParserRuleCall_3_1_0_1() { return cRealizesUopAbstractUoPQNParserRuleCall_3_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//'lang:'
		public Keyword getLangKeyword_5() { return cLangKeyword_5; }
		
		//transportAPILanguage=UopProgrammingLanguage
		public Assignment getTransportAPILanguageAssignment_6() { return cTransportAPILanguageAssignment_6; }
		
		//UopProgrammingLanguage
		public RuleCall getTransportAPILanguageUopProgrammingLanguageEnumRuleCall_6_0() { return cTransportAPILanguageUopProgrammingLanguageEnumRuleCall_6_0; }
		
		//('part:' partitionType=UopPartitionType)?
		public Group getGroup_7() { return cGroup_7; }
		
		//'part:'
		public Keyword getPartKeyword_7_0() { return cPartKeyword_7_0; }
		
		//partitionType=UopPartitionType
		public Assignment getPartitionTypeAssignment_7_1() { return cPartitionTypeAssignment_7_1; }
		
		//UopPartitionType
		public RuleCall getPartitionTypeUopPartitionTypeEnumRuleCall_7_1_0() { return cPartitionTypeUopPartitionTypeEnumRuleCall_7_1_0; }
		
		//// EXTENSION: making partitionType optional
		//   ('prof:' faceProfile=UopFaceProfile)?
		public Group getGroup_8() { return cGroup_8; }
		
		//'prof:'
		public Keyword getProfKeyword_8_0() { return cProfKeyword_8_0; }
		
		//faceProfile=UopFaceProfile
		public Assignment getFaceProfileAssignment_8_1() { return cFaceProfileAssignment_8_1; }
		
		//UopFaceProfile
		public RuleCall getFaceProfileUopFaceProfileEnumRuleCall_8_1_0() { return cFaceProfileUopFaceProfileEnumRuleCall_8_1_0; }
		
		//  // EXTENSION: making faceProfile optional
		//('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
		public Group getGroup_9() { return cGroup_9; }
		
		//'DAL:'
		public Keyword getDALKeyword_9_0() { return cDALKeyword_9_0; }
		
		//designAssuranceLevel=UopDesignAssuranceLevel
		public Assignment getDesignAssuranceLevelAssignment_9_1() { return cDesignAssuranceLevelAssignment_9_1; }
		
		//UopDesignAssuranceLevel
		public RuleCall getDesignAssuranceLevelUopDesignAssuranceLevelEnumRuleCall_9_1_0() { return cDesignAssuranceLevelUopDesignAssuranceLevelEnumRuleCall_9_1_0; }
		
		//('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
		public Group getGroup_10() { return cGroup_10; }
		
		//'DAS:'
		public Keyword getDASKeyword_10_0() { return cDASKeyword_10_0; }
		
		//designAssuranceStandard=UopDesignAssuranceStandard
		public Assignment getDesignAssuranceStandardAssignment_10_1() { return cDesignAssuranceStandardAssignment_10_1; }
		
		//UopDesignAssuranceStandard
		public RuleCall getDesignAssuranceStandardUopDesignAssuranceStandardEnumRuleCall_10_1_0() { return cDesignAssuranceStandardUopDesignAssuranceStandardEnumRuleCall_10_1_0; }
		
		//('RAM:' memoryRequirements=UopRAMMemoryRequirements)?
		public Group getGroup_11() { return cGroup_11; }
		
		//'RAM:'
		public Keyword getRAMKeyword_11_0() { return cRAMKeyword_11_0; }
		
		//memoryRequirements=UopRAMMemoryRequirements
		public Assignment getMemoryRequirementsAssignment_11_1() { return cMemoryRequirementsAssignment_11_1; }
		
		//UopRAMMemoryRequirements
		public RuleCall getMemoryRequirementsUopRAMMemoryRequirementsParserRuleCall_11_1_0() { return cMemoryRequirementsUopRAMMemoryRequirementsParserRuleCall_11_1_0; }
		
		//// EXTENSION: making memoryRequirements optional
		//       ('thread:' '[' thread+=UopThread+ ']')?
		public Group getGroup_12() { return cGroup_12; }
		
		//'thread:'
		public Keyword getThreadKeyword_12_0() { return cThreadKeyword_12_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_12_1() { return cLeftSquareBracketKeyword_12_1; }
		
		//thread+=UopThread+
		public Assignment getThreadAssignment_12_2() { return cThreadAssignment_12_2; }
		
		//UopThread
		public RuleCall getThreadUopThreadParserRuleCall_12_2_0() { return cThreadUopThreadParserRuleCall_12_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_12_3() { return cRightSquareBracketKeyword_12_3; }
		
		//// EXTENSION: making thread optional
		//('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
		public Group getGroup_13() { return cGroup_13; }
		
		//'support:'
		public Keyword getSupportKeyword_13_0() { return cSupportKeyword_13_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_13_1() { return cLeftSquareBracketKeyword_13_1; }
		
		//supportingComponent+=[UopSupportingComponent|QN]+
		public Assignment getSupportingComponentAssignment_13_2() { return cSupportingComponentAssignment_13_2; }
		
		//[UopSupportingComponent|QN]
		public CrossReference getSupportingComponentUopSupportingComponentCrossReference_13_2_0() { return cSupportingComponentUopSupportingComponentCrossReference_13_2_0; }
		
		//QN
		public RuleCall getSupportingComponentUopSupportingComponentQNParserRuleCall_13_2_0_1() { return cSupportingComponentUopSupportingComponentQNParserRuleCall_13_2_0_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_13_3() { return cRightSquareBracketKeyword_13_3; }
		
		//'conn:'
		public Keyword getConnKeyword_14() { return cConnKeyword_14; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_15() { return cLeftSquareBracketKeyword_15; }
		
		//connection+=UopConnection+
		public Assignment getConnectionAssignment_16() { return cConnectionAssignment_16; }
		
		//UopConnection
		public RuleCall getConnectionUopConnectionParserRuleCall_16_0() { return cConnectionUopConnectionParserRuleCall_16_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_17() { return cRightSquareBracketKeyword_17; }
		
		//('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
		public Group getGroup_18() { return cGroup_18; }
		
		//'lcm:'
		public Keyword getLcmKeyword_18_0() { return cLcmKeyword_18_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_18_1() { return cLeftSquareBracketKeyword_18_1; }
		
		//lcmPort+=UopLifeCycleManagementPort
		public Assignment getLcmPortAssignment_18_2() { return cLcmPortAssignment_18_2; }
		
		//UopLifeCycleManagementPort
		public RuleCall getLcmPortUopLifeCycleManagementPortParserRuleCall_18_2_0() { return cLcmPortUopLifeCycleManagementPortParserRuleCall_18_2_0; }
		
		//lcmPort+=UopLifeCycleManagementPort?
		public Assignment getLcmPortAssignment_18_3() { return cLcmPortAssignment_18_3; }
		
		//UopLifeCycleManagementPort
		public RuleCall getLcmPortUopLifeCycleManagementPortParserRuleCall_18_3_0() { return cLcmPortUopLifeCycleManagementPortParserRuleCall_18_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_18_4() { return cRightSquareBracketKeyword_18_4; }
		
		//('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])?
		public Group getGroup_19() { return cGroup_19; }
		
		//'implementedBy:'
		public Keyword getImplementedByKeyword_19_0() { return cImplementedByKeyword_19_0; }
		
		//implementedBy=[IntegrationIntegrationContext|QN]
		public Assignment getImplementedByAssignment_19_1() { return cImplementedByAssignment_19_1; }
		
		//[IntegrationIntegrationContext|QN]
		public CrossReference getImplementedByIntegrationIntegrationContextCrossReference_19_1_0() { return cImplementedByIntegrationIntegrationContextCrossReference_19_1_0; }
		
		//QN
		public RuleCall getImplementedByIntegrationIntegrationContextQNParserRuleCall_19_1_0_1() { return cImplementedByIntegrationIntegrationContextQNParserRuleCall_19_1_0_1; }
		
		//// EXTENSION: can supply a wiring diagram with implementation details
		//   '};'
		public Keyword getRightCurlyBracketSemicolonKeyword_20() { return cRightCurlyBracketSemicolonKeyword_20; }
	}
	public class UopThreadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopThread");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cPerKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPeriodAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPeriodFLOATTerminalRuleCall_2_0 = (RuleCall)cPeriodAssignment_2.eContents().get(0);
		private final Keyword cTimeCapKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTimeCapacityAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cTimeCapacityFLOATTerminalRuleCall_4_0 = (RuleCall)cTimeCapacityAssignment_4.eContents().get(0);
		private final Keyword cPrioKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cRelativePriorityAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cRelativePriorityINTTerminalRuleCall_6_0 = (RuleCall)cRelativePriorityAssignment_6.eContents().get(0);
		private final Keyword cCoreKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cRelativeCoreAffinityAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cRelativeCoreAffinityINTTerminalRuleCall_8_0 = (RuleCall)cRelativeCoreAffinityAssignment_8.eContents().get(0);
		private final Keyword cThreadKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Assignment cThreadTypeAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cThreadTypeUopThreadTypeEnumRuleCall_10_0 = (RuleCall)cThreadTypeAssignment_10.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		///** A Thread defines the properties for the scheduling of a thread. */
		//UopThread: '('
		//    'per:' period=FLOAT
		//    'timeCap:' timeCapacity=FLOAT
		//    'prio:' relativePriority=INT
		//    'core:' relativeCoreAffinity=INT
		//    'thread:' threadType=UopThreadType
		//    ')'
		//    ;
		@Override public ParserRule getRule() { return rule; }
		
		//'('
		//   'per:' period=FLOAT
		//   'timeCap:' timeCapacity=FLOAT
		//   'prio:' relativePriority=INT
		//   'core:' relativeCoreAffinity=INT
		//   'thread:' threadType=UopThreadType
		//   ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//'per:'
		public Keyword getPerKeyword_1() { return cPerKeyword_1; }
		
		//period=FLOAT
		public Assignment getPeriodAssignment_2() { return cPeriodAssignment_2; }
		
		//FLOAT
		public RuleCall getPeriodFLOATTerminalRuleCall_2_0() { return cPeriodFLOATTerminalRuleCall_2_0; }
		
		//'timeCap:'
		public Keyword getTimeCapKeyword_3() { return cTimeCapKeyword_3; }
		
		//timeCapacity=FLOAT
		public Assignment getTimeCapacityAssignment_4() { return cTimeCapacityAssignment_4; }
		
		//FLOAT
		public RuleCall getTimeCapacityFLOATTerminalRuleCall_4_0() { return cTimeCapacityFLOATTerminalRuleCall_4_0; }
		
		//'prio:'
		public Keyword getPrioKeyword_5() { return cPrioKeyword_5; }
		
		//relativePriority=INT
		public Assignment getRelativePriorityAssignment_6() { return cRelativePriorityAssignment_6; }
		
		//INT
		public RuleCall getRelativePriorityINTTerminalRuleCall_6_0() { return cRelativePriorityINTTerminalRuleCall_6_0; }
		
		//'core:'
		public Keyword getCoreKeyword_7() { return cCoreKeyword_7; }
		
		//relativeCoreAffinity=INT
		public Assignment getRelativeCoreAffinityAssignment_8() { return cRelativeCoreAffinityAssignment_8; }
		
		//INT
		public RuleCall getRelativeCoreAffinityINTTerminalRuleCall_8_0() { return cRelativeCoreAffinityINTTerminalRuleCall_8_0; }
		
		//'thread:'
		public Keyword getThreadKeyword_9() { return cThreadKeyword_9; }
		
		//threadType=UopThreadType
		public Assignment getThreadTypeAssignment_10() { return cThreadTypeAssignment_10; }
		
		//UopThreadType
		public RuleCall getThreadTypeUopThreadTypeEnumRuleCall_10_0() { return cThreadTypeUopThreadTypeEnumRuleCall_10_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_11() { return cRightParenthesisKeyword_11; }
	}
	public class UopRAMMemoryRequirementsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopRAMMemoryRequirements");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cUopRAMMemoryRequirementsAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cHeapKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cHeapStackMinAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cHeapStackMinINTTerminalRuleCall_2_2_0 = (RuleCall)cHeapStackMinAssignment_2_2.eContents().get(0);
		private final Keyword cColonKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cHeapStackTypicalAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final RuleCall cHeapStackTypicalINTTerminalRuleCall_2_4_0 = (RuleCall)cHeapStackTypicalAssignment_2_4.eContents().get(0);
		private final Keyword cColonKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		private final Assignment cHeapStackMaxAssignment_2_6 = (Assignment)cGroup_2.eContents().get(6);
		private final RuleCall cHeapStackMaxINTTerminalRuleCall_2_6_0 = (RuleCall)cHeapStackMaxAssignment_2_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_7 = (Keyword)cGroup_2.eContents().get(7);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cTextKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cTextMaxAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cTextMaxINTTerminalRuleCall_3_1_0 = (RuleCall)cTextMaxAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cRoDataKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cRoDataMaxAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRoDataMaxINTTerminalRuleCall_4_1_0 = (RuleCall)cRoDataMaxAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cDataKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cDataMaxAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cDataMaxINTTerminalRuleCall_5_1_0 = (RuleCall)cDataMaxAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cBssKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cBssMaxAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cBssMaxINTTerminalRuleCall_6_1_0 = (RuleCall)cBssMaxAssignment_6_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		///** A RAMMemoryRequirements defines memory resources required by a UoP. */
		//UopRAMMemoryRequirements:
		//    {UopRAMMemoryRequirements}
		//    '('
		//    ('heap:' '[' heapStackMin=INT? ':' heapStackTypical=INT? ':' heapStackMax=INT? ']')?
		//    ('text:'     textMax=INT)?
		//    ('roData:'     roDataMax=INT)?
		//    ('data:'     dataMax=INT)?
		//    ('bss:'     bssMax=INT)?
		//    ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{UopRAMMemoryRequirements}
		//'('
		//('heap:' '[' heapStackMin=INT? ':' heapStackTypical=INT? ':' heapStackMax=INT? ']')?
		//('text:'     textMax=INT)?
		//('roData:'     roDataMax=INT)?
		//('data:'     dataMax=INT)?
		//('bss:'     bssMax=INT)?
		//')'
		public Group getGroup() { return cGroup; }
		
		//{UopRAMMemoryRequirements}
		public Action getUopRAMMemoryRequirementsAction_0() { return cUopRAMMemoryRequirementsAction_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//('heap:' '[' heapStackMin=INT? ':' heapStackTypical=INT? ':' heapStackMax=INT? ']')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'heap:'
		public Keyword getHeapKeyword_2_0() { return cHeapKeyword_2_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2_1() { return cLeftSquareBracketKeyword_2_1; }
		
		//heapStackMin=INT?
		public Assignment getHeapStackMinAssignment_2_2() { return cHeapStackMinAssignment_2_2; }
		
		//INT
		public RuleCall getHeapStackMinINTTerminalRuleCall_2_2_0() { return cHeapStackMinINTTerminalRuleCall_2_2_0; }
		
		//':'
		public Keyword getColonKeyword_2_3() { return cColonKeyword_2_3; }
		
		//heapStackTypical=INT?
		public Assignment getHeapStackTypicalAssignment_2_4() { return cHeapStackTypicalAssignment_2_4; }
		
		//INT
		public RuleCall getHeapStackTypicalINTTerminalRuleCall_2_4_0() { return cHeapStackTypicalINTTerminalRuleCall_2_4_0; }
		
		//':'
		public Keyword getColonKeyword_2_5() { return cColonKeyword_2_5; }
		
		//heapStackMax=INT?
		public Assignment getHeapStackMaxAssignment_2_6() { return cHeapStackMaxAssignment_2_6; }
		
		//INT
		public RuleCall getHeapStackMaxINTTerminalRuleCall_2_6_0() { return cHeapStackMaxINTTerminalRuleCall_2_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2_7() { return cRightSquareBracketKeyword_2_7; }
		
		//('text:' 	textMax=INT)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'text:'
		public Keyword getTextKeyword_3_0() { return cTextKeyword_3_0; }
		
		//textMax=INT
		public Assignment getTextMaxAssignment_3_1() { return cTextMaxAssignment_3_1; }
		
		//INT
		public RuleCall getTextMaxINTTerminalRuleCall_3_1_0() { return cTextMaxINTTerminalRuleCall_3_1_0; }
		
		//('roData:' 	roDataMax=INT)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'roData:'
		public Keyword getRoDataKeyword_4_0() { return cRoDataKeyword_4_0; }
		
		//roDataMax=INT
		public Assignment getRoDataMaxAssignment_4_1() { return cRoDataMaxAssignment_4_1; }
		
		//INT
		public RuleCall getRoDataMaxINTTerminalRuleCall_4_1_0() { return cRoDataMaxINTTerminalRuleCall_4_1_0; }
		
		//('data:' 	dataMax=INT)?
		public Group getGroup_5() { return cGroup_5; }
		
		//'data:'
		public Keyword getDataKeyword_5_0() { return cDataKeyword_5_0; }
		
		//dataMax=INT
		public Assignment getDataMaxAssignment_5_1() { return cDataMaxAssignment_5_1; }
		
		//INT
		public RuleCall getDataMaxINTTerminalRuleCall_5_1_0() { return cDataMaxINTTerminalRuleCall_5_1_0; }
		
		//('bss:' 	bssMax=INT)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'bss:'
		public Keyword getBssKeyword_6_0() { return cBssKeyword_6_0; }
		
		//bssMax=INT
		public Assignment getBssMaxAssignment_6_1() { return cBssMaxAssignment_6_1; }
		
		//INT
		public RuleCall getBssMaxINTTerminalRuleCall_6_1_0() { return cBssMaxINTTerminalRuleCall_6_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }
	}
	public class UopConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopConnection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUopPubSubConnectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopClientServerConnectionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///** A Connection is a communication endpoint on a FACE UoP. A Connection is either a Publisher, Subscriber, Client, or Server. The “messageType” specifies the platform View that is transmitted through the endpoint. If “period” is not specified, the endpoint is aperiodic. If “period” is specified, the value is the period of the endpoint in seconds. */
		//UopConnection:
		//    UopPubSubConnection |
		//    UopClientServerConnection
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UopPubSubConnection |
		//UopClientServerConnection
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UopPubSubConnection
		public RuleCall getUopPubSubConnectionParserRuleCall_0() { return cUopPubSubConnectionParserRuleCall_0; }
		
		//UopClientServerConnection
		public RuleCall getUopClientServerConnectionParserRuleCall_1() { return cUopClientServerConnectionParserRuleCall_1; }
	}
	public class UopClientServerConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopClientServerConnection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCsconnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRealizesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cRealizesUopAbstractConnectionCrossReference_3_1_0 = (CrossReference)cRealizesAssignment_3_1.eContents().get(0);
		private final RuleCall cRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1 = (RuleCall)cRealizesUopAbstractConnectionCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cMsgKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cLeftSquareBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cRequestTypeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cRequestTypeUopMessageTypeCrossReference_7_0 = (CrossReference)cRequestTypeAssignment_7.eContents().get(0);
		private final RuleCall cRequestTypeUopMessageTypeQNParserRuleCall_7_0_1 = (RuleCall)cRequestTypeUopMessageTypeCrossReference_7_0.eContents().get(1);
		private final Keyword cSolidusKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cResponseTypeAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final CrossReference cResponseTypeUopMessageTypeCrossReference_9_0 = (CrossReference)cResponseTypeAssignment_9.eContents().get(0);
		private final RuleCall cResponseTypeUopMessageTypeQNParserRuleCall_9_0_1 = (RuleCall)cResponseTypeUopMessageTypeCrossReference_9_0.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Assignment cSynchronizationStyleAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cSynchronizationStyleUopSynchronizationStyleEnumRuleCall_11_0 = (RuleCall)cSynchronizationStyleAssignment_11.eContents().get(0);
		private final Keyword cRoleKeyword_12 = (Keyword)cGroup.eContents().get(12);
		private final Assignment cRoleAssignment_13 = (Assignment)cGroup.eContents().get(13);
		private final RuleCall cRoleUoPClientServerRoleEnumRuleCall_13_0 = (RuleCall)cRoleAssignment_13.eContents().get(0);
		private final Group cGroup_14 = (Group)cGroup.eContents().get(14);
		private final Keyword cPeriodKeyword_14_0 = (Keyword)cGroup_14.eContents().get(0);
		private final Assignment cPeriodAssignment_14_1 = (Assignment)cGroup_14.eContents().get(1);
		private final RuleCall cPeriodFLOATTerminalRuleCall_14_1_0 = (RuleCall)cPeriodAssignment_14_1.eContents().get(0);
		private final Group cGroup_15 = (Group)cGroup.eContents().get(15);
		private final Keyword cMapsToKeyword_15_0 = (Keyword)cGroup_15.eContents().get(0);
		private final Assignment cMapsToAssignment_15_1 = (Assignment)cGroup_15.eContents().get(1);
		private final CrossReference cMapsToIntegrationTransportNodeCrossReference_15_1_0 = (CrossReference)cMapsToAssignment_15_1.eContents().get(0);
		private final RuleCall cMapsToIntegrationTransportNodeQNParserRuleCall_15_1_0_1 = (RuleCall)cMapsToIntegrationTransportNodeCrossReference_15_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_16 = (Keyword)cGroup.eContents().get(16);
		
		///** A ClientServerConnection is a Request/Reply Connection as defined in Section 4.7. */
		//UopClientServerConnection:
		//    'csconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
		//         'msg:' '[' requestType=[UopMessageType|QN] '/' responseType=[UopMessageType|QN] ']'
		//                (synchronizationStyle=UopSynchronizationStyle)?
		//         'role:' role=UoPClientServerRole
		//         ('period:' period=FLOAT)?
		//        ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'csconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
		//     'msg:' '[' requestType=[UopMessageType|QN] '/' responseType=[UopMessageType|QN] ']'
		//            (synchronizationStyle=UopSynchronizationStyle)?
		//     'role:' role=UoPClientServerRole
		//     ('period:' period=FLOAT)?
		//    ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'csconn'
		public Keyword getCsconnKeyword_0() { return cCsconnKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//('->' realizes=[UopAbstractConnection|QN])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_0() { return cHyphenMinusGreaterThanSignKeyword_3_0; }
		
		//realizes=[UopAbstractConnection|QN]
		public Assignment getRealizesAssignment_3_1() { return cRealizesAssignment_3_1; }
		
		//[UopAbstractConnection|QN]
		public CrossReference getRealizesUopAbstractConnectionCrossReference_3_1_0() { return cRealizesUopAbstractConnectionCrossReference_3_1_0; }
		
		//QN
		public RuleCall getRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1() { return cRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//'msg:'
		public Keyword getMsgKeyword_5() { return cMsgKeyword_5; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_6() { return cLeftSquareBracketKeyword_6; }
		
		//requestType=[UopMessageType|QN]
		public Assignment getRequestTypeAssignment_7() { return cRequestTypeAssignment_7; }
		
		//[UopMessageType|QN]
		public CrossReference getRequestTypeUopMessageTypeCrossReference_7_0() { return cRequestTypeUopMessageTypeCrossReference_7_0; }
		
		//QN
		public RuleCall getRequestTypeUopMessageTypeQNParserRuleCall_7_0_1() { return cRequestTypeUopMessageTypeQNParserRuleCall_7_0_1; }
		
		//'/'
		public Keyword getSolidusKeyword_8() { return cSolidusKeyword_8; }
		
		//responseType=[UopMessageType|QN]
		public Assignment getResponseTypeAssignment_9() { return cResponseTypeAssignment_9; }
		
		//[UopMessageType|QN]
		public CrossReference getResponseTypeUopMessageTypeCrossReference_9_0() { return cResponseTypeUopMessageTypeCrossReference_9_0; }
		
		//QN
		public RuleCall getResponseTypeUopMessageTypeQNParserRuleCall_9_0_1() { return cResponseTypeUopMessageTypeQNParserRuleCall_9_0_1; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_10() { return cRightSquareBracketKeyword_10; }
		
		//(synchronizationStyle=UopSynchronizationStyle)?
		public Assignment getSynchronizationStyleAssignment_11() { return cSynchronizationStyleAssignment_11; }
		
		//UopSynchronizationStyle
		public RuleCall getSynchronizationStyleUopSynchronizationStyleEnumRuleCall_11_0() { return cSynchronizationStyleUopSynchronizationStyleEnumRuleCall_11_0; }
		
		//'role:'
		public Keyword getRoleKeyword_12() { return cRoleKeyword_12; }
		
		//role=UoPClientServerRole
		public Assignment getRoleAssignment_13() { return cRoleAssignment_13; }
		
		//UoPClientServerRole
		public RuleCall getRoleUoPClientServerRoleEnumRuleCall_13_0() { return cRoleUoPClientServerRoleEnumRuleCall_13_0; }
		
		//('period:' period=FLOAT)?
		public Group getGroup_14() { return cGroup_14; }
		
		//'period:'
		public Keyword getPeriodKeyword_14_0() { return cPeriodKeyword_14_0; }
		
		//period=FLOAT
		public Assignment getPeriodAssignment_14_1() { return cPeriodAssignment_14_1; }
		
		//FLOAT
		public RuleCall getPeriodFLOATTerminalRuleCall_14_1_0() { return cPeriodFLOATTerminalRuleCall_14_1_0; }
		
		//('mapsTo:' mapsTo=[IntegrationTransportNode|QN])?
		public Group getGroup_15() { return cGroup_15; }
		
		//'mapsTo:'
		public Keyword getMapsToKeyword_15_0() { return cMapsToKeyword_15_0; }
		
		//mapsTo=[IntegrationTransportNode|QN]
		public Assignment getMapsToAssignment_15_1() { return cMapsToAssignment_15_1; }
		
		//[IntegrationTransportNode|QN]
		public CrossReference getMapsToIntegrationTransportNodeCrossReference_15_1_0() { return cMapsToIntegrationTransportNodeCrossReference_15_1_0; }
		
		//QN
		public RuleCall getMapsToIntegrationTransportNodeQNParserRuleCall_15_1_0_1() { return cMapsToIntegrationTransportNodeQNParserRuleCall_15_1_0_1; }
		
		//// EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//   '}'
		public Keyword getRightCurlyBracketKeyword_16() { return cRightCurlyBracketKeyword_16; }
	}
	public class UopPubSubConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopPubSubConnection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUopQueuingConnectionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopSingleInstanceMessageConnectionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///** A PubSubConnection is a QueuingConnection or a SingleInstanceMessageConnection. The “messageExchangeType” attribute defines the direction of the message relative to the UoP. */
		//UopPubSubConnection:
		//    UopQueuingConnection |
		//    UopSingleInstanceMessageConnection
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UopQueuingConnection |
		//UopSingleInstanceMessageConnection
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UopQueuingConnection
		public RuleCall getUopQueuingConnectionParserRuleCall_0() { return cUopQueuingConnectionParserRuleCall_0; }
		
		//UopSingleInstanceMessageConnection
		public RuleCall getUopSingleInstanceMessageConnectionParserRuleCall_1() { return cUopSingleInstanceMessageConnectionParserRuleCall_1; }
	}
	public class UopQueuingConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopQueuingConnection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQconnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRealizesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cRealizesUopAbstractConnectionCrossReference_3_1_0 = (CrossReference)cRealizesAssignment_3_1.eContents().get(0);
		private final RuleCall cRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1 = (RuleCall)cRealizesUopAbstractConnectionCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cMsgKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cMessageExchangeTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_6_0 = (RuleCall)cMessageExchangeTypeAssignment_6.eContents().get(0);
		private final Assignment cMessageTypeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cMessageTypeUopMessageTypeCrossReference_7_0 = (CrossReference)cMessageTypeAssignment_7.eContents().get(0);
		private final RuleCall cMessageTypeUopMessageTypeQNParserRuleCall_7_0_1 = (RuleCall)cMessageTypeUopMessageTypeCrossReference_7_0.eContents().get(1);
		private final Assignment cSynchronizationStyleAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cSynchronizationStyleUopSynchronizationStyleEnumRuleCall_8_0 = (RuleCall)cSynchronizationStyleAssignment_8.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cDepthKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cDepthAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cDepthINTTerminalRuleCall_9_1_0 = (RuleCall)cDepthAssignment_9_1.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cPeriodKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cPeriodAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final RuleCall cPeriodFLOATTerminalRuleCall_10_1_0 = (RuleCall)cPeriodAssignment_10_1.eContents().get(0);
		private final Group cGroup_11 = (Group)cGroup.eContents().get(11);
		private final Keyword cMapsToKeyword_11_0 = (Keyword)cGroup_11.eContents().get(0);
		private final Assignment cMapsToAssignment_11_1 = (Assignment)cGroup_11.eContents().get(1);
		private final CrossReference cMapsToIntegrationTransportNodeCrossReference_11_1_0 = (CrossReference)cMapsToAssignment_11_1.eContents().get(0);
		private final RuleCall cMapsToIntegrationTransportNodeQNParserRuleCall_11_1_0_1 = (RuleCall)cMapsToIntegrationTransportNodeCrossReference_11_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_12 = (Keyword)cGroup.eContents().get(12);
		
		///** A QueuingConnection is a PubSubConnection that supports buffering/queuing as defined in Section 4.8.  */
		//UopQueuingConnection:
		//    'qconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
		//         'msg:'  messageExchangeType=UopMessageExchangeType
		//                 messageType=[UopMessageType|QN]
		//                 (synchronizationStyle=UopSynchronizationStyle)?
		//        ('depth:' depth=INT)?
		//         ('period:' period=FLOAT)?
		//        ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//        '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'qconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
		//     'msg:'  messageExchangeType=UopMessageExchangeType
		//             messageType=[UopMessageType|QN]
		//             (synchronizationStyle=UopSynchronizationStyle)?
		//    ('depth:' depth=INT)?
		//     ('period:' period=FLOAT)?
		//    ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//    '}'
		public Group getGroup() { return cGroup; }
		
		//'qconn'
		public Keyword getQconnKeyword_0() { return cQconnKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//('->' realizes=[UopAbstractConnection|QN])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_0() { return cHyphenMinusGreaterThanSignKeyword_3_0; }
		
		//realizes=[UopAbstractConnection|QN]
		public Assignment getRealizesAssignment_3_1() { return cRealizesAssignment_3_1; }
		
		//[UopAbstractConnection|QN]
		public CrossReference getRealizesUopAbstractConnectionCrossReference_3_1_0() { return cRealizesUopAbstractConnectionCrossReference_3_1_0; }
		
		//QN
		public RuleCall getRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1() { return cRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//'msg:'
		public Keyword getMsgKeyword_5() { return cMsgKeyword_5; }
		
		//messageExchangeType=UopMessageExchangeType
		public Assignment getMessageExchangeTypeAssignment_6() { return cMessageExchangeTypeAssignment_6; }
		
		//UopMessageExchangeType
		public RuleCall getMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_6_0() { return cMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_6_0; }
		
		//messageType=[UopMessageType|QN]
		public Assignment getMessageTypeAssignment_7() { return cMessageTypeAssignment_7; }
		
		//[UopMessageType|QN]
		public CrossReference getMessageTypeUopMessageTypeCrossReference_7_0() { return cMessageTypeUopMessageTypeCrossReference_7_0; }
		
		//QN
		public RuleCall getMessageTypeUopMessageTypeQNParserRuleCall_7_0_1() { return cMessageTypeUopMessageTypeQNParserRuleCall_7_0_1; }
		
		//(synchronizationStyle=UopSynchronizationStyle)?
		public Assignment getSynchronizationStyleAssignment_8() { return cSynchronizationStyleAssignment_8; }
		
		//UopSynchronizationStyle
		public RuleCall getSynchronizationStyleUopSynchronizationStyleEnumRuleCall_8_0() { return cSynchronizationStyleUopSynchronizationStyleEnumRuleCall_8_0; }
		
		//('depth:' depth=INT)?
		public Group getGroup_9() { return cGroup_9; }
		
		//'depth:'
		public Keyword getDepthKeyword_9_0() { return cDepthKeyword_9_0; }
		
		//depth=INT
		public Assignment getDepthAssignment_9_1() { return cDepthAssignment_9_1; }
		
		//INT
		public RuleCall getDepthINTTerminalRuleCall_9_1_0() { return cDepthINTTerminalRuleCall_9_1_0; }
		
		//('period:' period=FLOAT)?
		public Group getGroup_10() { return cGroup_10; }
		
		//'period:'
		public Keyword getPeriodKeyword_10_0() { return cPeriodKeyword_10_0; }
		
		//period=FLOAT
		public Assignment getPeriodAssignment_10_1() { return cPeriodAssignment_10_1; }
		
		//FLOAT
		public RuleCall getPeriodFLOATTerminalRuleCall_10_1_0() { return cPeriodFLOATTerminalRuleCall_10_1_0; }
		
		//('mapsTo:' mapsTo=[IntegrationTransportNode|QN])?
		public Group getGroup_11() { return cGroup_11; }
		
		//'mapsTo:'
		public Keyword getMapsToKeyword_11_0() { return cMapsToKeyword_11_0; }
		
		//mapsTo=[IntegrationTransportNode|QN]
		public Assignment getMapsToAssignment_11_1() { return cMapsToAssignment_11_1; }
		
		//[IntegrationTransportNode|QN]
		public CrossReference getMapsToIntegrationTransportNodeCrossReference_11_1_0() { return cMapsToIntegrationTransportNodeCrossReference_11_1_0; }
		
		//QN
		public RuleCall getMapsToIntegrationTransportNodeQNParserRuleCall_11_1_0_1() { return cMapsToIntegrationTransportNodeQNParserRuleCall_11_1_0_1; }
		
		//// EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//       '}'
		public Keyword getRightCurlyBracketKeyword_12() { return cRightCurlyBracketKeyword_12; }
	}
	public class UopSingleInstanceMessageConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopSingleInstanceMessageConnection");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSimconnKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRealizesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cRealizesUopAbstractConnectionCrossReference_3_1_0 = (CrossReference)cRealizesAssignment_3_1.eContents().get(0);
		private final RuleCall cRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1 = (RuleCall)cRealizesUopAbstractConnectionCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cMsgKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cMessageExchangeTypeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_6_0 = (RuleCall)cMessageExchangeTypeAssignment_6.eContents().get(0);
		private final Assignment cMessageTypeAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cMessageTypeUopMessageTypeCrossReference_7_0 = (CrossReference)cMessageTypeAssignment_7.eContents().get(0);
		private final RuleCall cMessageTypeUopMessageTypeQNParserRuleCall_7_0_1 = (RuleCall)cMessageTypeUopMessageTypeCrossReference_7_0.eContents().get(1);
		private final Assignment cSynchronizationStyleAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cSynchronizationStyleUopSynchronizationStyleEnumRuleCall_8_0 = (RuleCall)cSynchronizationStyleAssignment_8.eContents().get(0);
		private final Group cGroup_9 = (Group)cGroup.eContents().get(9);
		private final Keyword cPeriodKeyword_9_0 = (Keyword)cGroup_9.eContents().get(0);
		private final Assignment cPeriodAssignment_9_1 = (Assignment)cGroup_9.eContents().get(1);
		private final RuleCall cPeriodFLOATTerminalRuleCall_9_1_0 = (RuleCall)cPeriodAssignment_9_1.eContents().get(0);
		private final Group cGroup_10 = (Group)cGroup.eContents().get(10);
		private final Keyword cMapsToKeyword_10_0 = (Keyword)cGroup_10.eContents().get(0);
		private final Assignment cMapsToAssignment_10_1 = (Assignment)cGroup_10.eContents().get(1);
		private final CrossReference cMapsToIntegrationTransportNodeCrossReference_10_1_0 = (CrossReference)cMapsToAssignment_10_1.eContents().get(0);
		private final RuleCall cMapsToIntegrationTransportNodeQNParserRuleCall_10_1_0_1 = (RuleCall)cMapsToIntegrationTransportNodeCrossReference_10_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_11 = (Keyword)cGroup.eContents().get(11);
		
		///** A SingleInstanceMessageConnection is a PubSubConnection that supports single instance messaging as defined in Section 4.8.  */
		//UopSingleInstanceMessageConnection:
		//    'simconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
		//         'msg:'  messageExchangeType=UopMessageExchangeType
		//                 messageType=[UopMessageType|QN]
		//                 (synchronizationStyle=UopSynchronizationStyle )?
		//         ('period:' period=FLOAT)?
		//        ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//        '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'simconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
		//     'msg:'  messageExchangeType=UopMessageExchangeType
		//             messageType=[UopMessageType|QN]
		//             (synchronizationStyle=UopSynchronizationStyle )?
		//     ('period:' period=FLOAT)?
		//    ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//    '}'
		public Group getGroup() { return cGroup; }
		
		//'simconn'
		public Keyword getSimconnKeyword_0() { return cSimconnKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//('->' realizes=[UopAbstractConnection|QN])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_0() { return cHyphenMinusGreaterThanSignKeyword_3_0; }
		
		//realizes=[UopAbstractConnection|QN]
		public Assignment getRealizesAssignment_3_1() { return cRealizesAssignment_3_1; }
		
		//[UopAbstractConnection|QN]
		public CrossReference getRealizesUopAbstractConnectionCrossReference_3_1_0() { return cRealizesUopAbstractConnectionCrossReference_3_1_0; }
		
		//QN
		public RuleCall getRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1() { return cRealizesUopAbstractConnectionQNParserRuleCall_3_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//'msg:'
		public Keyword getMsgKeyword_5() { return cMsgKeyword_5; }
		
		//messageExchangeType=UopMessageExchangeType
		public Assignment getMessageExchangeTypeAssignment_6() { return cMessageExchangeTypeAssignment_6; }
		
		//UopMessageExchangeType
		public RuleCall getMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_6_0() { return cMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_6_0; }
		
		//messageType=[UopMessageType|QN]
		public Assignment getMessageTypeAssignment_7() { return cMessageTypeAssignment_7; }
		
		//[UopMessageType|QN]
		public CrossReference getMessageTypeUopMessageTypeCrossReference_7_0() { return cMessageTypeUopMessageTypeCrossReference_7_0; }
		
		//QN
		public RuleCall getMessageTypeUopMessageTypeQNParserRuleCall_7_0_1() { return cMessageTypeUopMessageTypeQNParserRuleCall_7_0_1; }
		
		//(synchronizationStyle=UopSynchronizationStyle )?
		public Assignment getSynchronizationStyleAssignment_8() { return cSynchronizationStyleAssignment_8; }
		
		//UopSynchronizationStyle
		public RuleCall getSynchronizationStyleUopSynchronizationStyleEnumRuleCall_8_0() { return cSynchronizationStyleUopSynchronizationStyleEnumRuleCall_8_0; }
		
		//('period:' period=FLOAT)?
		public Group getGroup_9() { return cGroup_9; }
		
		//'period:'
		public Keyword getPeriodKeyword_9_0() { return cPeriodKeyword_9_0; }
		
		//period=FLOAT
		public Assignment getPeriodAssignment_9_1() { return cPeriodAssignment_9_1; }
		
		//FLOAT
		public RuleCall getPeriodFLOATTerminalRuleCall_9_1_0() { return cPeriodFLOATTerminalRuleCall_9_1_0; }
		
		//('mapsTo:' mapsTo=[IntegrationTransportNode|QN])?
		public Group getGroup_10() { return cGroup_10; }
		
		//'mapsTo:'
		public Keyword getMapsToKeyword_10_0() { return cMapsToKeyword_10_0; }
		
		//mapsTo=[IntegrationTransportNode|QN]
		public Assignment getMapsToAssignment_10_1() { return cMapsToAssignment_10_1; }
		
		//[IntegrationTransportNode|QN]
		public CrossReference getMapsToIntegrationTransportNodeCrossReference_10_1_0() { return cMapsToIntegrationTransportNodeCrossReference_10_1_0; }
		
		//QN
		public RuleCall getMapsToIntegrationTransportNodeQNParserRuleCall_10_1_0_1() { return cMapsToIntegrationTransportNodeQNParserRuleCall_10_1_0_1; }
		
		//// EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
		//       '}'
		public Keyword getRightCurlyBracketKeyword_11() { return cRightCurlyBracketKeyword_11; }
	}
	public class UopLifeCycleManagementPortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopLifeCycleManagementPort");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMessageExchangeTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_1_0 = (RuleCall)cMessageExchangeTypeAssignment_1.eContents().get(0);
		private final Assignment cLcmMessageTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cLcmMessageTypeUopMessageTypeCrossReference_2_0 = (CrossReference)cLcmMessageTypeAssignment_2.eContents().get(0);
		private final RuleCall cLcmMessageTypeUopMessageTypeQNParserRuleCall_2_0_1 = (RuleCall)cLcmMessageTypeUopMessageTypeCrossReference_2_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///** A LifeCycleManagementPort is used to define the life-cycle interface for the component. The “messageExchangeType” attribute defines the direction of the life-cycle message relative to the UoP.  */
		//UopLifeCycleManagementPort:
		//    '(' messageExchangeType=UopMessageExchangeType lcmMessageType=[UopMessageType|QN] ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'(' messageExchangeType=UopMessageExchangeType lcmMessageType=[UopMessageType|QN] ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//messageExchangeType=UopMessageExchangeType
		public Assignment getMessageExchangeTypeAssignment_1() { return cMessageExchangeTypeAssignment_1; }
		
		//UopMessageExchangeType
		public RuleCall getMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_1_0() { return cMessageExchangeTypeUopMessageExchangeTypeEnumRuleCall_1_0; }
		
		//lcmMessageType=[UopMessageType|QN]
		public Assignment getLcmMessageTypeAssignment_2() { return cLcmMessageTypeAssignment_2; }
		
		//[UopMessageType|QN]
		public CrossReference getLcmMessageTypeUopMessageTypeCrossReference_2_0() { return cLcmMessageTypeUopMessageTypeCrossReference_2_0; }
		
		//QN
		public RuleCall getLcmMessageTypeUopMessageTypeQNParserRuleCall_2_0_1() { return cLcmMessageTypeUopMessageTypeQNParserRuleCall_2_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class UopMessageTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopMessageType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUopTemplateParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUopCompositeTemplateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///** A MessageType is a Template or a CompositeTemplate. */
		//UopMessageType:
		//    UopTemplate |
		//    UopCompositeTemplate
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//UopTemplate |
		//UopCompositeTemplate
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UopTemplate
		public RuleCall getUopTemplateParserRuleCall_0() { return cUopTemplateParserRuleCall_0; }
		
		//UopCompositeTemplate
		public RuleCall getUopCompositeTemplateParserRuleCall_1() { return cUopCompositeTemplateParserRuleCall_1; }
	}
	public class UopCompositeTemplateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopCompositeTemplate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCtemplKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cRealizesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cRealizesLogicalCompositeQueryCrossReference_3_1_0 = (CrossReference)cRealizesAssignment_3_1.eContents().get(0);
		private final RuleCall cRealizesLogicalCompositeQueryQNParserRuleCall_3_1_0_1 = (RuleCall)cRealizesLogicalCompositeQueryCrossReference_3_1_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cIsUnionAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cIsUnionIsUnionKeyword_5_0 = (Keyword)cIsUnionAssignment_5.eContents().get(0);
		private final Assignment cCompositionAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cCompositionUopTemplateCompositionParserRuleCall_6_0 = (RuleCall)cCompositionAssignment_6.eContents().get(0);
		private final Assignment cCompositionAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cCompositionUopTemplateCompositionParserRuleCall_7_0 = (RuleCall)cCompositionAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		///** A CompositeTemplate is a collection of two or more Templates. The “isUnion” attribute specifies whether the composed Templates are to be represented as cases in an IDL union or as members of an IDL struct. */
		//UopCompositeTemplate:
		//    'ctempl' name=ID description=STRING ('->' realizes=[uddl::LogicalCompositeQuery|QN])? '{'
		//        isUnion?='isUnion'
		//        composition+=UopTemplateComposition (composition+=UopTemplateComposition)+
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'ctempl' name=ID description=STRING ('->' realizes=[uddl::LogicalCompositeQuery|QN])? '{'
		//    isUnion?='isUnion'
		//    composition+=UopTemplateComposition (composition+=UopTemplateComposition)+
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'ctempl'
		public Keyword getCtemplKeyword_0() { return cCtemplKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//('->' realizes=[uddl::LogicalCompositeQuery|QN])?
		public Group getGroup_3() { return cGroup_3; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_0() { return cHyphenMinusGreaterThanSignKeyword_3_0; }
		
		//realizes=[uddl::LogicalCompositeQuery|QN]
		public Assignment getRealizesAssignment_3_1() { return cRealizesAssignment_3_1; }
		
		//[uddl::LogicalCompositeQuery|QN]
		public CrossReference getRealizesLogicalCompositeQueryCrossReference_3_1_0() { return cRealizesLogicalCompositeQueryCrossReference_3_1_0; }
		
		//QN
		public RuleCall getRealizesLogicalCompositeQueryQNParserRuleCall_3_1_0_1() { return cRealizesLogicalCompositeQueryQNParserRuleCall_3_1_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//isUnion?='isUnion'
		public Assignment getIsUnionAssignment_5() { return cIsUnionAssignment_5; }
		
		//'isUnion'
		public Keyword getIsUnionIsUnionKeyword_5_0() { return cIsUnionIsUnionKeyword_5_0; }
		
		//composition+=UopTemplateComposition
		public Assignment getCompositionAssignment_6() { return cCompositionAssignment_6; }
		
		//UopTemplateComposition
		public RuleCall getCompositionUopTemplateCompositionParserRuleCall_6_0() { return cCompositionUopTemplateCompositionParserRuleCall_6_0; }
		
		//(composition+=UopTemplateComposition)+
		public Assignment getCompositionAssignment_7() { return cCompositionAssignment_7; }
		
		//UopTemplateComposition
		public RuleCall getCompositionUopTemplateCompositionParserRuleCall_7_0() { return cCompositionUopTemplateCompositionParserRuleCall_7_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_8() { return cRightCurlyBracketSemicolonKeyword_8; }
	}
	public class UopTemplateCompositionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopTemplateComposition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeUopMessageTypeCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeUopMessageTypeQNParserRuleCall_0_0_1 = (RuleCall)cTypeUopMessageTypeCrossReference_0_0.eContents().get(1);
		private final Assignment cRolenameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cRolenameSTRINGTerminalRuleCall_1_0 = (RuleCall)cRolenameAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cRealizesAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final CrossReference cRealizesLogicalQueryCompositionCrossReference_2_1_0 = (CrossReference)cRealizesAssignment_2_1.eContents().get(0);
		private final RuleCall cRealizesLogicalQueryCompositionQNParserRuleCall_2_1_0_1 = (RuleCall)cRealizesLogicalQueryCompositionCrossReference_2_1_0.eContents().get(1);
		
		///** A TemplateComposition is the mechanism that allows a CompositeTemplate to be constructed from Templates and other CompositeTemplates. The “rolename” attribute defines the name of the composed platform View within the scope of the composing CompositeTemplate. The “type” of a TemplateComposition is the platform View being used to construct the CompositeTemplate. */
		//UopTemplateComposition:
		//    type=[UopMessageType|QN] rolename=STRING ('->' realizes=[uddl::LogicalQueryComposition|QN])?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//type=[UopMessageType|QN] rolename=STRING ('->' realizes=[uddl::LogicalQueryComposition|QN])?
		public Group getGroup() { return cGroup; }
		
		//type=[UopMessageType|QN]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[UopMessageType|QN]
		public CrossReference getTypeUopMessageTypeCrossReference_0_0() { return cTypeUopMessageTypeCrossReference_0_0; }
		
		//QN
		public RuleCall getTypeUopMessageTypeQNParserRuleCall_0_0_1() { return cTypeUopMessageTypeQNParserRuleCall_0_0_1; }
		
		//rolename=STRING
		public Assignment getRolenameAssignment_1() { return cRolenameAssignment_1; }
		
		//STRING
		public RuleCall getRolenameSTRINGTerminalRuleCall_1_0() { return cRolenameSTRINGTerminalRuleCall_1_0; }
		
		//('->' realizes=[uddl::LogicalQueryComposition|QN])?
		public Group getGroup_2() { return cGroup_2; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2_0() { return cHyphenMinusGreaterThanSignKeyword_2_0; }
		
		//realizes=[uddl::LogicalQueryComposition|QN]
		public Assignment getRealizesAssignment_2_1() { return cRealizesAssignment_2_1; }
		
		//[uddl::LogicalQueryComposition|QN]
		public CrossReference getRealizesLogicalQueryCompositionCrossReference_2_1_0() { return cRealizesLogicalQueryCompositionCrossReference_2_1_0; }
		
		//QN
		public RuleCall getRealizesLogicalQueryCompositionQNParserRuleCall_2_1_0_1() { return cRealizesLogicalQueryCompositionQNParserRuleCall_2_1_0_1; }
	}
	public class UopTemplateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopTemplate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTemplKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cSpecKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cSpecificationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cSpecificationSTRINGTerminalRuleCall_5_0 = (RuleCall)cSpecificationAssignment_5.eContents().get(0);
		private final Keyword cBoundKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Assignment cBoundQueryAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final CrossReference cBoundQueryPlatformQueryCrossReference_7_0 = (CrossReference)cBoundQueryAssignment_7.eContents().get(0);
		private final RuleCall cBoundQueryPlatformQueryQNParserRuleCall_7_0_1 = (RuleCall)cBoundQueryPlatformQueryCrossReference_7_0.eContents().get(1);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cEffectiveKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cEffectiveQueryAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final CrossReference cEffectiveQueryPlatformQueryCrossReference_8_1_0 = (CrossReference)cEffectiveQueryAssignment_8_1.eContents().get(0);
		private final RuleCall cEffectiveQueryPlatformQueryQNParserRuleCall_8_1_0_1 = (RuleCall)cEffectiveQueryPlatformQueryCrossReference_8_1_0.eContents().get(1);
		private final Keyword cRightCurlyBracketSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///** A Template is a specification that defines a structure for Characteristics projected by its “boundQuery” or its “effectiveQuery”. The “specification” attribute captures the specification of a Template as defined by the Template grammar in Section J.4.  */
		//UopTemplate:
		//    'templ' name=ID description=STRING  '{'
		//        'spec:' specification=STRING
		//        'bound:' boundQuery=[uddl::PlatformQuery|QN]
		//        ('effective:' effectiveQuery=[uddl::PlatformQuery|QN])?
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'templ' name=ID description=STRING  '{'
		//    'spec:' specification=STRING
		//    'bound:' boundQuery=[uddl::PlatformQuery|QN]
		//    ('effective:' effectiveQuery=[uddl::PlatformQuery|QN])?
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'templ'
		public Keyword getTemplKeyword_0() { return cTemplKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'spec:'
		public Keyword getSpecKeyword_4() { return cSpecKeyword_4; }
		
		//specification=STRING
		public Assignment getSpecificationAssignment_5() { return cSpecificationAssignment_5; }
		
		//STRING
		public RuleCall getSpecificationSTRINGTerminalRuleCall_5_0() { return cSpecificationSTRINGTerminalRuleCall_5_0; }
		
		//'bound:'
		public Keyword getBoundKeyword_6() { return cBoundKeyword_6; }
		
		//boundQuery=[uddl::PlatformQuery|QN]
		public Assignment getBoundQueryAssignment_7() { return cBoundQueryAssignment_7; }
		
		//[uddl::PlatformQuery|QN]
		public CrossReference getBoundQueryPlatformQueryCrossReference_7_0() { return cBoundQueryPlatformQueryCrossReference_7_0; }
		
		//QN
		public RuleCall getBoundQueryPlatformQueryQNParserRuleCall_7_0_1() { return cBoundQueryPlatformQueryQNParserRuleCall_7_0_1; }
		
		//('effective:' effectiveQuery=[uddl::PlatformQuery|QN])?
		public Group getGroup_8() { return cGroup_8; }
		
		//'effective:'
		public Keyword getEffectiveKeyword_8_0() { return cEffectiveKeyword_8_0; }
		
		//effectiveQuery=[uddl::PlatformQuery|QN]
		public Assignment getEffectiveQueryAssignment_8_1() { return cEffectiveQueryAssignment_8_1; }
		
		//[uddl::PlatformQuery|QN]
		public CrossReference getEffectiveQueryPlatformQueryCrossReference_8_1_0() { return cEffectiveQueryPlatformQueryCrossReference_8_1_0; }
		
		//QN
		public RuleCall getEffectiveQueryPlatformQueryQNParserRuleCall_8_1_0_1() { return cEffectiveQueryPlatformQueryQNParserRuleCall_8_1_0_1; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_9() { return cRightCurlyBracketSemicolonKeyword_9; }
	}
	public class IntegrationIntegrationModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationIntegrationModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Alternatives cAlternatives_4 = (Alternatives)cGroup.eContents().get(4);
		private final Assignment cImAssignment_4_0 = (Assignment)cAlternatives_4.eContents().get(0);
		private final RuleCall cImIntegrationIntegrationModelParserRuleCall_4_0_0 = (RuleCall)cImAssignment_4_0.eContents().get(0);
		private final Assignment cElementAssignment_4_1 = (Assignment)cAlternatives_4.eContents().get(1);
		private final RuleCall cElementIntegrationElementParserRuleCall_4_1_0 = (RuleCall)cElementAssignment_4_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//// -------------- Integration -----------
		//// ----
		///** An IntegrationModel is a container for integration Elements.  */
		//IntegrationIntegrationModel:
		//    'im' name=ID description=STRING '{'
		//        (im+=IntegrationIntegrationModel | element+=IntegrationElement)*
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'im' name=ID description=STRING '{'
		//    (im+=IntegrationIntegrationModel | element+=IntegrationElement)*
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'im'
		public Keyword getImKeyword_0() { return cImKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//(im+=IntegrationIntegrationModel | element+=IntegrationElement)*
		public Alternatives getAlternatives_4() { return cAlternatives_4; }
		
		//im+=IntegrationIntegrationModel
		public Assignment getImAssignment_4_0() { return cImAssignment_4_0; }
		
		//IntegrationIntegrationModel
		public RuleCall getImIntegrationIntegrationModelParserRuleCall_4_0_0() { return cImIntegrationIntegrationModelParserRuleCall_4_0_0; }
		
		//element+=IntegrationElement
		public Assignment getElementAssignment_4_1() { return cElementAssignment_4_1; }
		
		//IntegrationElement
		public RuleCall getElementIntegrationElementParserRuleCall_4_1_0() { return cElementIntegrationElementParserRuleCall_4_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}
	public class IntegrationElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationElement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegrationUoPInstanceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntegrationTransportChannelParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegrationIntegrationContextParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		///** An integration Element is the root type for defining the integration elements of the ArchitectureModel. */
		//IntegrationElement:
		//    IntegrationUoPInstance |
		//    IntegrationTransportChannel |
		//    IntegrationIntegrationContext
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//IntegrationUoPInstance |
		//IntegrationTransportChannel |
		//IntegrationIntegrationContext
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntegrationUoPInstance
		public RuleCall getIntegrationUoPInstanceParserRuleCall_0() { return cIntegrationUoPInstanceParserRuleCall_0; }
		
		//IntegrationTransportChannel
		public RuleCall getIntegrationTransportChannelParserRuleCall_1() { return cIntegrationTransportChannelParserRuleCall_1; }
		
		//IntegrationIntegrationContext
		public RuleCall getIntegrationIntegrationContextParserRuleCall_2() { return cIntegrationIntegrationContextParserRuleCall_2; }
	}
	public class IntegrationIntegrationContextElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationIntegrationContext");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIcKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cXportKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cNodeAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cNodeIntegrationTransportNodeParserRuleCall_4_2_0 = (RuleCall)cNodeAssignment_4_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4_3 = (Keyword)cGroup_4.eContents().get(3);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cConnKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_5_1 = (Keyword)cGroup_5.eContents().get(1);
		private final Assignment cConnectionAssignment_5_2 = (Assignment)cGroup_5.eContents().get(2);
		private final RuleCall cConnectionIntegrationTSNodeConnectionParserRuleCall_5_2_0 = (RuleCall)cConnectionAssignment_5_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_5_3 = (Keyword)cGroup_5.eContents().get(3);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		///** An IntegrationContext is a container used to group a set of TransportNodes and TSNodeConnections related to each other by a common, integrator defined context (e.g., collection and distribution of navigation data). */
		//IntegrationIntegrationContext:
		//    'ic' name=ID description=STRING '{'
		//        ('xport:''[' node+=IntegrationTransportNode+ ']')?
		//        ('conn:' '['connection+=IntegrationTSNodeConnection+ ']')?
		//    '}'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'ic' name=ID description=STRING '{'
		//    ('xport:''[' node+=IntegrationTransportNode+ ']')?
		//    ('conn:' '['connection+=IntegrationTSNodeConnection+ ']')?
		//'}'
		public Group getGroup() { return cGroup; }
		
		//'ic'
		public Keyword getIcKeyword_0() { return cIcKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//('xport:''[' node+=IntegrationTransportNode+ ']')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'xport:'
		public Keyword getXportKeyword_4_0() { return cXportKeyword_4_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4_1() { return cLeftSquareBracketKeyword_4_1; }
		
		//node+=IntegrationTransportNode+
		public Assignment getNodeAssignment_4_2() { return cNodeAssignment_4_2; }
		
		//IntegrationTransportNode
		public RuleCall getNodeIntegrationTransportNodeParserRuleCall_4_2_0() { return cNodeIntegrationTransportNodeParserRuleCall_4_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4_3() { return cRightSquareBracketKeyword_4_3; }
		
		//('conn:' '['connection+=IntegrationTSNodeConnection+ ']')?
		public Group getGroup_5() { return cGroup_5; }
		
		//'conn:'
		public Keyword getConnKeyword_5_0() { return cConnKeyword_5_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_5_1() { return cLeftSquareBracketKeyword_5_1; }
		
		//connection+=IntegrationTSNodeConnection+
		public Assignment getConnectionAssignment_5_2() { return cConnectionAssignment_5_2; }
		
		//IntegrationTSNodeConnection
		public RuleCall getConnectionIntegrationTSNodeConnectionParserRuleCall_5_2_0() { return cConnectionIntegrationTSNodeConnectionParserRuleCall_5_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_5_3() { return cRightSquareBracketKeyword_5_3; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class IntegrationTSNodeConnectionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationTSNodeConnection");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cU2UKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cSourceAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final CrossReference cSourceIntegrationUoPOutputEndPointCrossReference_0_2_0 = (CrossReference)cSourceAssignment_0_2.eContents().get(0);
		private final RuleCall cSourceIntegrationUoPOutputEndPointQNParserRuleCall_0_2_0_1 = (RuleCall)cSourceIntegrationUoPOutputEndPointCrossReference_0_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Assignment cDestinationAssignment_0_4 = (Assignment)cGroup_0.eContents().get(4);
		private final CrossReference cDestinationIntegrationUoPInputEndPointCrossReference_0_4_0 = (CrossReference)cDestinationAssignment_0_4.eContents().get(0);
		private final RuleCall cDestinationIntegrationUoPInputEndPointQNParserRuleCall_0_4_0_1 = (RuleCall)cDestinationIntegrationUoPInputEndPointCrossReference_0_4_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_5 = (Keyword)cGroup_0.eContents().get(5);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cU2TKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cSourceAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final CrossReference cSourceIntegrationUoPOutputEndPointCrossReference_1_2_0 = (CrossReference)cSourceAssignment_1_2.eContents().get(0);
		private final RuleCall cSourceIntegrationUoPOutputEndPointQNParserRuleCall_1_2_0_1 = (RuleCall)cSourceIntegrationUoPOutputEndPointCrossReference_1_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cDestinationAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final CrossReference cDestinationIntegrationTSNodeInputPortCrossReference_1_4_0 = (CrossReference)cDestinationAssignment_1_4.eContents().get(0);
		private final RuleCall cDestinationIntegrationTSNodeInputPortQNParserRuleCall_1_4_0_1 = (RuleCall)cDestinationIntegrationTSNodeInputPortCrossReference_1_4_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cLeftParenthesisKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Keyword cT2UKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cSourceAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final CrossReference cSourceIntegrationTSNodeOutputPortCrossReference_2_2_0 = (CrossReference)cSourceAssignment_2_2.eContents().get(0);
		private final RuleCall cSourceIntegrationTSNodeOutputPortQNParserRuleCall_2_2_0_1 = (RuleCall)cSourceIntegrationTSNodeOutputPortCrossReference_2_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cDestinationAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final CrossReference cDestinationIntegrationUoPInputEndPointCrossReference_2_4_0 = (CrossReference)cDestinationAssignment_2_4.eContents().get(0);
		private final RuleCall cDestinationIntegrationUoPInputEndPointQNParserRuleCall_2_4_0_1 = (RuleCall)cDestinationIntegrationUoPInputEndPointCrossReference_2_4_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2_5 = (Keyword)cGroup_2.eContents().get(5);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cLeftParenthesisKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Keyword cT2TKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cSourceAssignment_3_2 = (Assignment)cGroup_3.eContents().get(2);
		private final CrossReference cSourceIntegrationTSNodeOutputPortCrossReference_3_2_0 = (CrossReference)cSourceAssignment_3_2.eContents().get(0);
		private final RuleCall cSourceIntegrationTSNodeOutputPortQNParserRuleCall_3_2_0_1 = (RuleCall)cSourceIntegrationTSNodeOutputPortCrossReference_3_2_0.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3_3 = (Keyword)cGroup_3.eContents().get(3);
		private final Assignment cDestinationAssignment_3_4 = (Assignment)cGroup_3.eContents().get(4);
		private final CrossReference cDestinationIntegrationTSNodeInputPortCrossReference_3_4_0 = (CrossReference)cDestinationAssignment_3_4.eContents().get(0);
		private final RuleCall cDestinationIntegrationTSNodeInputPortQNParserRuleCall_3_4_0_1 = (RuleCall)cDestinationIntegrationTSNodeInputPortCrossReference_3_4_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_3_5 = (Keyword)cGroup_3.eContents().get(5);
		
		///** A TSNodeConnection represents a connection between two TransportNodes.
		// * NOTE: This rule as defined subsumes the functionality of the derived classes from the spec.
		// */
		//IntegrationTSNodeConnection:
		//    // Could make U2U the default
		//    '(' ('U2U')? source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')' |
		//    '(' 'U2T' source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')' |
		//    '(' 'T2U' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')' |
		//    '(' 'T2T' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//// Could make U2U the default
		//'(' ('U2U')? source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')' |
		//'(' 'U2T' source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')' |
		//'(' 'T2U' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')' |
		//'(' 'T2T' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//// Could make U2U the default
		//'(' ('U2U')? source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//// Could make U2U the default
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//('U2U')?
		public Keyword getU2UKeyword_0_1() { return cU2UKeyword_0_1; }
		
		//source=[IntegrationUoPOutputEndPoint|QN]
		public Assignment getSourceAssignment_0_2() { return cSourceAssignment_0_2; }
		
		//[IntegrationUoPOutputEndPoint|QN]
		public CrossReference getSourceIntegrationUoPOutputEndPointCrossReference_0_2_0() { return cSourceIntegrationUoPOutputEndPointCrossReference_0_2_0; }
		
		//QN
		public RuleCall getSourceIntegrationUoPOutputEndPointQNParserRuleCall_0_2_0_1() { return cSourceIntegrationUoPOutputEndPointQNParserRuleCall_0_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0_3() { return cHyphenMinusGreaterThanSignKeyword_0_3; }
		
		//destination=[IntegrationUoPInputEndPoint|QN]
		public Assignment getDestinationAssignment_0_4() { return cDestinationAssignment_0_4; }
		
		//[IntegrationUoPInputEndPoint|QN]
		public CrossReference getDestinationIntegrationUoPInputEndPointCrossReference_0_4_0() { return cDestinationIntegrationUoPInputEndPointCrossReference_0_4_0; }
		
		//QN
		public RuleCall getDestinationIntegrationUoPInputEndPointQNParserRuleCall_0_4_0_1() { return cDestinationIntegrationUoPInputEndPointQNParserRuleCall_0_4_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_5() { return cRightParenthesisKeyword_0_5; }
		
		//'(' 'U2T' source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')'
		public Group getGroup_1() { return cGroup_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }
		
		//'U2T'
		public Keyword getU2TKeyword_1_1() { return cU2TKeyword_1_1; }
		
		//source=[IntegrationUoPOutputEndPoint|QN]
		public Assignment getSourceAssignment_1_2() { return cSourceAssignment_1_2; }
		
		//[IntegrationUoPOutputEndPoint|QN]
		public CrossReference getSourceIntegrationUoPOutputEndPointCrossReference_1_2_0() { return cSourceIntegrationUoPOutputEndPointCrossReference_1_2_0; }
		
		//QN
		public RuleCall getSourceIntegrationUoPOutputEndPointQNParserRuleCall_1_2_0_1() { return cSourceIntegrationUoPOutputEndPointQNParserRuleCall_1_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_3() { return cHyphenMinusGreaterThanSignKeyword_1_3; }
		
		//destination=[IntegrationTSNodeInputPort|QN]
		public Assignment getDestinationAssignment_1_4() { return cDestinationAssignment_1_4; }
		
		//[IntegrationTSNodeInputPort|QN]
		public CrossReference getDestinationIntegrationTSNodeInputPortCrossReference_1_4_0() { return cDestinationIntegrationTSNodeInputPortCrossReference_1_4_0; }
		
		//QN
		public RuleCall getDestinationIntegrationTSNodeInputPortQNParserRuleCall_1_4_0_1() { return cDestinationIntegrationTSNodeInputPortQNParserRuleCall_1_4_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_1_5() { return cRightParenthesisKeyword_1_5; }
		
		//'(' 'T2U' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')'
		public Group getGroup_2() { return cGroup_2; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_0() { return cLeftParenthesisKeyword_2_0; }
		
		//'T2U'
		public Keyword getT2UKeyword_2_1() { return cT2UKeyword_2_1; }
		
		//source=[IntegrationTSNodeOutputPort|QN]
		public Assignment getSourceAssignment_2_2() { return cSourceAssignment_2_2; }
		
		//[IntegrationTSNodeOutputPort|QN]
		public CrossReference getSourceIntegrationTSNodeOutputPortCrossReference_2_2_0() { return cSourceIntegrationTSNodeOutputPortCrossReference_2_2_0; }
		
		//QN
		public RuleCall getSourceIntegrationTSNodeOutputPortQNParserRuleCall_2_2_0_1() { return cSourceIntegrationTSNodeOutputPortQNParserRuleCall_2_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2_3() { return cHyphenMinusGreaterThanSignKeyword_2_3; }
		
		//destination=[IntegrationUoPInputEndPoint|QN]
		public Assignment getDestinationAssignment_2_4() { return cDestinationAssignment_2_4; }
		
		//[IntegrationUoPInputEndPoint|QN]
		public CrossReference getDestinationIntegrationUoPInputEndPointCrossReference_2_4_0() { return cDestinationIntegrationUoPInputEndPointCrossReference_2_4_0; }
		
		//QN
		public RuleCall getDestinationIntegrationUoPInputEndPointQNParserRuleCall_2_4_0_1() { return cDestinationIntegrationUoPInputEndPointQNParserRuleCall_2_4_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_5() { return cRightParenthesisKeyword_2_5; }
		
		//'(' 'T2T' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')'
		public Group getGroup_3() { return cGroup_3; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_0() { return cLeftParenthesisKeyword_3_0; }
		
		//'T2T'
		public Keyword getT2TKeyword_3_1() { return cT2TKeyword_3_1; }
		
		//source=[IntegrationTSNodeOutputPort|QN]
		public Assignment getSourceAssignment_3_2() { return cSourceAssignment_3_2; }
		
		//[IntegrationTSNodeOutputPort|QN]
		public CrossReference getSourceIntegrationTSNodeOutputPortCrossReference_3_2_0() { return cSourceIntegrationTSNodeOutputPortCrossReference_3_2_0; }
		
		//QN
		public RuleCall getSourceIntegrationTSNodeOutputPortQNParserRuleCall_3_2_0_1() { return cSourceIntegrationTSNodeOutputPortQNParserRuleCall_3_2_0_1; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3_3() { return cHyphenMinusGreaterThanSignKeyword_3_3; }
		
		//destination=[IntegrationTSNodeInputPort|QN]
		public Assignment getDestinationAssignment_3_4() { return cDestinationAssignment_3_4; }
		
		//[IntegrationTSNodeInputPort|QN]
		public CrossReference getDestinationIntegrationTSNodeInputPortCrossReference_3_4_0() { return cDestinationIntegrationTSNodeInputPortCrossReference_3_4_0; }
		
		//QN
		public RuleCall getDestinationIntegrationTSNodeInputPortQNParserRuleCall_3_4_0_1() { return cDestinationIntegrationTSNodeInputPortQNParserRuleCall_3_4_0_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_5() { return cRightParenthesisKeyword_3_5; }
	}
	public class IntegrationTSNodePortBaseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationTSNodePortBase");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegrationUoPInputEndPointParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntegrationUoPOutputEndPointParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegrationTSNodeInputPortParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIntegrationTSNodeOutputPortParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		///** A TSNodePortBase is a port that can be used to connect a TransportNode and a UoPEndPoint together using a TSNodeConnection. */
		//IntegrationTSNodePortBase:
		////    IntegrationUoPEndPoint |
		////    IntegrationTSNodePort
		//// Directly insert these rules because the intermediate rules lead to a grammar ambiguity
		//    IntegrationUoPInputEndPoint |
		//    IntegrationUoPOutputEndPoint |
		//    IntegrationTSNodeInputPort |
		//    IntegrationTSNodeOutputPort
		//;
		@Override public ParserRule getRule() { return rule; }
		
		////    IntegrationUoPEndPoint |
		////    IntegrationTSNodePort
		//// Directly insert these rules because the intermediate rules lead to a grammar ambiguity
		//    IntegrationUoPInputEndPoint |
		//    IntegrationUoPOutputEndPoint |
		//    IntegrationTSNodeInputPort |
		//    IntegrationTSNodeOutputPort
		public Alternatives getAlternatives() { return cAlternatives; }
		
		////    IntegrationUoPEndPoint |
		////    IntegrationTSNodePort
		//// Directly insert these rules because the intermediate rules lead to a grammar ambiguity
		//    IntegrationUoPInputEndPoint
		public RuleCall getIntegrationUoPInputEndPointParserRuleCall_0() { return cIntegrationUoPInputEndPointParserRuleCall_0; }
		
		//IntegrationUoPOutputEndPoint
		public RuleCall getIntegrationUoPOutputEndPointParserRuleCall_1() { return cIntegrationUoPOutputEndPointParserRuleCall_1; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getIntegrationTSNodeInputPortParserRuleCall_2() { return cIntegrationTSNodeInputPortParserRuleCall_2; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getIntegrationTSNodeOutputPortParserRuleCall_3() { return cIntegrationTSNodeOutputPortParserRuleCall_3; }
	}
	public class IntegrationUoPInstanceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationUoPInstance");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUinstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRealizesAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cRealizesUopUnitOfPortabilityCrossReference_4_0 = (CrossReference)cRealizesAssignment_4.eContents().get(0);
		private final RuleCall cRealizesUopUnitOfPortabilityQNParserRuleCall_4_0_1 = (RuleCall)cRealizesUopUnitOfPortabilityCrossReference_4_0.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cUriKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cConfigurationURIAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cConfigurationURISTRINGTerminalRuleCall_6_1_0 = (RuleCall)cConfigurationURIAssignment_6_1.eContents().get(0);
		private final Group cGroup_7 = (Group)cGroup.eContents().get(7);
		private final Keyword cInputKeyword_7_0 = (Keyword)cGroup_7.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_7_1 = (Keyword)cGroup_7.eContents().get(1);
		private final Assignment cInputAssignment_7_2 = (Assignment)cGroup_7.eContents().get(2);
		private final RuleCall cInputIntegrationUoPInputEndPointParserRuleCall_7_2_0 = (RuleCall)cInputAssignment_7_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7_3 = (Keyword)cGroup_7.eContents().get(3);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cOutputKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_8_1 = (Keyword)cGroup_8.eContents().get(1);
		private final Assignment cOutputAssignment_8_2 = (Assignment)cGroup_8.eContents().get(2);
		private final RuleCall cOutputIntegrationUoPOutputEndPointParserRuleCall_8_2_0 = (RuleCall)cOutputAssignment_8_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_8_3 = (Keyword)cGroup_8.eContents().get(3);
		private final Keyword cRightCurlyBracketSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///** A UoPInstance represents an instance of a specific UoP within the system bounded by an integration model. An integration model can contain multiple instances of the same UoP. */
		//IntegrationUoPInstance:
		//    'uinst' name=ID description=STRING '->' realizes=[UopUnitOfPortability|QN]  '{'
		//        ('uri:' configurationURI=STRING)?
		//        ('input:' '[' input+=IntegrationUoPInputEndPoint+ ']')?
		//        ('output:' '[' output+=IntegrationUoPOutputEndPoint+ ']')?
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'uinst' name=ID description=STRING '->' realizes=[UopUnitOfPortability|QN]  '{'
		//    ('uri:' configurationURI=STRING)?
		//    ('input:' '[' input+=IntegrationUoPInputEndPoint+ ']')?
		//    ('output:' '[' output+=IntegrationUoPOutputEndPoint+ ']')?
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'uinst'
		public Keyword getUinstKeyword_0() { return cUinstKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_3() { return cHyphenMinusGreaterThanSignKeyword_3; }
		
		//realizes=[UopUnitOfPortability|QN]
		public Assignment getRealizesAssignment_4() { return cRealizesAssignment_4; }
		
		//[UopUnitOfPortability|QN]
		public CrossReference getRealizesUopUnitOfPortabilityCrossReference_4_0() { return cRealizesUopUnitOfPortabilityCrossReference_4_0; }
		
		//QN
		public RuleCall getRealizesUopUnitOfPortabilityQNParserRuleCall_4_0_1() { return cRealizesUopUnitOfPortabilityQNParserRuleCall_4_0_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//('uri:' configurationURI=STRING)?
		public Group getGroup_6() { return cGroup_6; }
		
		//'uri:'
		public Keyword getUriKeyword_6_0() { return cUriKeyword_6_0; }
		
		//configurationURI=STRING
		public Assignment getConfigurationURIAssignment_6_1() { return cConfigurationURIAssignment_6_1; }
		
		//STRING
		public RuleCall getConfigurationURISTRINGTerminalRuleCall_6_1_0() { return cConfigurationURISTRINGTerminalRuleCall_6_1_0; }
		
		//('input:' '[' input+=IntegrationUoPInputEndPoint+ ']')?
		public Group getGroup_7() { return cGroup_7; }
		
		//'input:'
		public Keyword getInputKeyword_7_0() { return cInputKeyword_7_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_7_1() { return cLeftSquareBracketKeyword_7_1; }
		
		//input+=IntegrationUoPInputEndPoint+
		public Assignment getInputAssignment_7_2() { return cInputAssignment_7_2; }
		
		//IntegrationUoPInputEndPoint
		public RuleCall getInputIntegrationUoPInputEndPointParserRuleCall_7_2_0() { return cInputIntegrationUoPInputEndPointParserRuleCall_7_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7_3() { return cRightSquareBracketKeyword_7_3; }
		
		//('output:' '[' output+=IntegrationUoPOutputEndPoint+ ']')?
		public Group getGroup_8() { return cGroup_8; }
		
		//'output:'
		public Keyword getOutputKeyword_8_0() { return cOutputKeyword_8_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_8_1() { return cLeftSquareBracketKeyword_8_1; }
		
		//output+=IntegrationUoPOutputEndPoint+
		public Assignment getOutputAssignment_8_2() { return cOutputAssignment_8_2; }
		
		//IntegrationUoPOutputEndPoint
		public RuleCall getOutputIntegrationUoPOutputEndPointParserRuleCall_8_2_0() { return cOutputIntegrationUoPOutputEndPointParserRuleCall_8_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_8_3() { return cRightSquareBracketKeyword_8_3; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_9() { return cRightCurlyBracketSemicolonKeyword_9; }
	}
	public class IntegrationUoPInputEndPointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationUoPInputEndPoint");
		private final Assignment cConnectionAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cConnectionUopConnectionCrossReference_0 = (CrossReference)cConnectionAssignment.eContents().get(0);
		private final RuleCall cConnectionUopConnectionQNParserRuleCall_0_1 = (RuleCall)cConnectionUopConnectionCrossReference_0.eContents().get(1);
		
		//// EXTENSION: Technically, the IntegrationTSNodeConnection rule sidesteps any need for this rule.
		///** A UoPEndPoint is a specialization of a TSNodePortBase that allows connections in a UoPInstance to be part of a TSNodeConnection. This supports connecting UOP input and output endpoints to each other and to transport node input and output ports. */
		////IntegrationUoPEndPoint:
		////    IntegrationUoPInputEndPoint |
		////    IntegrationUoPOutputEndPoint
		////;
		///** A UoPInputEndPoint is a specialization of a UoPEndPoint providing an endpoint which is used to input data to a UoP. */
		//IntegrationUoPInputEndPoint:
		//    connection=[UopConnection|QN]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//connection=[UopConnection|QN]
		public Assignment getConnectionAssignment() { return cConnectionAssignment; }
		
		//[UopConnection|QN]
		public CrossReference getConnectionUopConnectionCrossReference_0() { return cConnectionUopConnectionCrossReference_0; }
		
		//QN
		public RuleCall getConnectionUopConnectionQNParserRuleCall_0_1() { return cConnectionUopConnectionQNParserRuleCall_0_1; }
	}
	public class IntegrationUoPOutputEndPointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationUoPOutputEndPoint");
		private final Assignment cConnectionAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cConnectionUopConnectionCrossReference_0 = (CrossReference)cConnectionAssignment.eContents().get(0);
		private final RuleCall cConnectionUopConnectionQNParserRuleCall_0_1 = (RuleCall)cConnectionUopConnectionCrossReference_0.eContents().get(1);
		
		///** A UoPOutputEndPoint is a specialization of a UoPEndPoint providing an endpoint which is used to output data from a UoP. */
		//IntegrationUoPOutputEndPoint:
		//     connection=[UopConnection|QN]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//connection=[UopConnection|QN]
		public Assignment getConnectionAssignment() { return cConnectionAssignment; }
		
		//[UopConnection|QN]
		public CrossReference getConnectionUopConnectionCrossReference_0() { return cConnectionUopConnectionCrossReference_0; }
		
		//QN
		public RuleCall getConnectionUopConnectionQNParserRuleCall_0_1() { return cConnectionUopConnectionQNParserRuleCall_0_1; }
	}
	public class IntegrationTransportNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationTransportNode");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegrationViewTransporterParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cIntegrationViewAggregationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegrationViewTransformationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cIntegrationViewFilterParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIntegrationViewSinkParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cIntegrationViewSourceParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		///** A TransportNode is an abstraction of a node that performs a function along a path of communication from source UoPs to destination UoPs.  */
		//IntegrationTransportNode:
		//    IntegrationViewTransporter |
		//    IntegrationViewAggregation |
		//    IntegrationViewTransformation |
		//    IntegrationViewFilter |
		//    IntegrationViewSink |
		//    IntegrationViewSource
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//IntegrationViewTransporter |
		//IntegrationViewAggregation |
		//IntegrationViewTransformation |
		//IntegrationViewFilter |
		//IntegrationViewSink |
		//IntegrationViewSource
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntegrationViewTransporter
		public RuleCall getIntegrationViewTransporterParserRuleCall_0() { return cIntegrationViewTransporterParserRuleCall_0; }
		
		//IntegrationViewAggregation
		public RuleCall getIntegrationViewAggregationParserRuleCall_1() { return cIntegrationViewAggregationParserRuleCall_1; }
		
		//IntegrationViewTransformation
		public RuleCall getIntegrationViewTransformationParserRuleCall_2() { return cIntegrationViewTransformationParserRuleCall_2; }
		
		//IntegrationViewFilter
		public RuleCall getIntegrationViewFilterParserRuleCall_3() { return cIntegrationViewFilterParserRuleCall_3; }
		
		//IntegrationViewSink
		public RuleCall getIntegrationViewSinkParserRuleCall_4() { return cIntegrationViewSinkParserRuleCall_4; }
		
		//IntegrationViewSource
		public RuleCall getIntegrationViewSourceParserRuleCall_5() { return cIntegrationViewSourceParserRuleCall_5; }
	}
	public class IntegrationTSNodeInputPortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationTSNodeInputPort");
		private final Assignment cViewAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cViewUopMessageTypeCrossReference_0 = (CrossReference)cViewAssignment.eContents().get(0);
		private final RuleCall cViewUopMessageTypeQNParserRuleCall_0_1 = (RuleCall)cViewUopMessageTypeCrossReference_0.eContents().get(1);
		
		//// EXTENSION: Technically, the IntegrationTSNodeConnection rule sidesteps any need for this rule.
		///** A TSNodePort is a port that provides a connection point to a TransportNode. A TSNodePort is typed by the “view” it references. */
		////IntegrationTSNodePort:
		////    IntegrationTSNodeOutputPort |
		////    IntegrationTSNodeInputPort
		////;
		///** A TSNodeInputPort is a specialization of a TSNodePort providing an endpoint which is used to input data to a TransportNode. */
		//IntegrationTSNodeInputPort:
		//     view=[UopMessageType|QN]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//view=[UopMessageType|QN]
		public Assignment getViewAssignment() { return cViewAssignment; }
		
		//[UopMessageType|QN]
		public CrossReference getViewUopMessageTypeCrossReference_0() { return cViewUopMessageTypeCrossReference_0; }
		
		//QN
		public RuleCall getViewUopMessageTypeQNParserRuleCall_0_1() { return cViewUopMessageTypeQNParserRuleCall_0_1; }
	}
	public class IntegrationTSNodeOutputPortElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationTSNodeOutputPort");
		private final Assignment cViewAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cViewUopMessageTypeCrossReference_0 = (CrossReference)cViewAssignment.eContents().get(0);
		private final RuleCall cViewUopMessageTypeQNParserRuleCall_0_1 = (RuleCall)cViewUopMessageTypeCrossReference_0.eContents().get(1);
		
		///** A TSNodeOutputPort is a specialization of a TSNodePort providing an endpoint which is used to output data from a TransportNode. */
		//IntegrationTSNodeOutputPort:
		//     view=[UopMessageType|QN]
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//view=[UopMessageType|QN]
		public Assignment getViewAssignment() { return cViewAssignment; }
		
		//[UopMessageType|QN]
		public CrossReference getViewUopMessageTypeCrossReference_0() { return cViewUopMessageTypeCrossReference_0; }
		
		//QN
		public RuleCall getViewUopMessageTypeQNParserRuleCall_0_1() { return cViewUopMessageTypeQNParserRuleCall_0_1; }
	}
	public class IntegrationViewAggregationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationViewAggregation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAggKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cInPortAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cInPortIntegrationTSNodeInputPortParserRuleCall_6_0 = (RuleCall)cInPortAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cOutKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cOutPortAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0 = (RuleCall)cOutPortAssignment_9.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		///** A ViewAggregation represents of an instance of aggregation of data from multiple incoming views into a single outgoing view type, including transformation of input data to that required by the output view type. */
		//IntegrationViewAggregation:
		//    'agg' name=ID description=STRING '{'
		//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//        'out:'  outPort=IntegrationTSNodeOutputPort
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'agg' name=ID description=STRING '{'
		//    'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//    'out:'  outPort=IntegrationTSNodeOutputPort
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'agg'
		public Keyword getAggKeyword_0() { return cAggKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'in:'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_5() { return cLeftSquareBracketKeyword_5; }
		
		//inPort+=IntegrationTSNodeInputPort+
		public Assignment getInPortAssignment_6() { return cInPortAssignment_6; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getInPortIntegrationTSNodeInputPortParserRuleCall_6_0() { return cInPortIntegrationTSNodeInputPortParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
		
		//'out:'
		public Keyword getOutKeyword_8() { return cOutKeyword_8; }
		
		//outPort=IntegrationTSNodeOutputPort
		public Assignment getOutPortAssignment_9() { return cOutPortAssignment_9; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0() { return cOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_10() { return cRightCurlyBracketSemicolonKeyword_10; }
	}
	public class IntegrationViewFilterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationViewFilter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFilterKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cInPortAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cInPortIntegrationTSNodeInputPortParserRuleCall_6_0 = (RuleCall)cInPortAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cOutKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cOutPortAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cOutPortIntegrationTSNodeOutputPortParserRuleCall_8_1_0 = (RuleCall)cOutPortAssignment_8_1.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///** A ViewFilter represents of an instance of a filter of data allowing a view to either pass through a filter, or to be filtered out (i.e., not passed through). A ViewFilter performs no transformation of data. */
		//IntegrationViewFilter:
		//    'filter' name=ID description=STRING '{'
		//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//        ('out:'  outPort=IntegrationTSNodeOutputPort )?
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'filter' name=ID description=STRING '{'
		//    'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//    ('out:'  outPort=IntegrationTSNodeOutputPort )?
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'filter'
		public Keyword getFilterKeyword_0() { return cFilterKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'in:'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_5() { return cLeftSquareBracketKeyword_5; }
		
		//inPort+=IntegrationTSNodeInputPort+
		public Assignment getInPortAssignment_6() { return cInPortAssignment_6; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getInPortIntegrationTSNodeInputPortParserRuleCall_6_0() { return cInPortIntegrationTSNodeInputPortParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
		
		//('out:'  outPort=IntegrationTSNodeOutputPort )?
		public Group getGroup_8() { return cGroup_8; }
		
		//'out:'
		public Keyword getOutKeyword_8_0() { return cOutKeyword_8_0; }
		
		//outPort=IntegrationTSNodeOutputPort
		public Assignment getOutPortAssignment_8_1() { return cOutPortAssignment_8_1; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getOutPortIntegrationTSNodeOutputPortParserRuleCall_8_1_0() { return cOutPortIntegrationTSNodeOutputPortParserRuleCall_8_1_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_9() { return cRightCurlyBracketSemicolonKeyword_9; }
	}
	public class IntegrationViewSourceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationViewSource");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSrcKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cInKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Assignment cInPortAssignment_4_2 = (Assignment)cGroup_4.eContents().get(2);
		private final RuleCall cInPortIntegrationTSNodeInputPortParserRuleCall_4_2_0 = (RuleCall)cInPortAssignment_4_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4_3 = (Keyword)cGroup_4.eContents().get(3);
		private final Keyword cOutKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cOutPortAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cOutPortIntegrationTSNodeOutputPortParserRuleCall_6_0 = (RuleCall)cOutPortAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		///** A ViewSource is a TransportNode that only provides a View. */
		//IntegrationViewSource:
		//    'src' name=ID description=STRING '{'
		//        ('in:' '[' inPort+=IntegrationTSNodeInputPort+ ']')?
		//        'out:'  outPort=IntegrationTSNodeOutputPort
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'src' name=ID description=STRING '{'
		//    ('in:' '[' inPort+=IntegrationTSNodeInputPort+ ']')?
		//    'out:'  outPort=IntegrationTSNodeOutputPort
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'src'
		public Keyword getSrcKeyword_0() { return cSrcKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//('in:' '[' inPort+=IntegrationTSNodeInputPort+ ']')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'in:'
		public Keyword getInKeyword_4_0() { return cInKeyword_4_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4_1() { return cLeftSquareBracketKeyword_4_1; }
		
		//inPort+=IntegrationTSNodeInputPort+
		public Assignment getInPortAssignment_4_2() { return cInPortAssignment_4_2; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getInPortIntegrationTSNodeInputPortParserRuleCall_4_2_0() { return cInPortIntegrationTSNodeInputPortParserRuleCall_4_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4_3() { return cRightSquareBracketKeyword_4_3; }
		
		//'out:'
		public Keyword getOutKeyword_5() { return cOutKeyword_5; }
		
		//outPort=IntegrationTSNodeOutputPort
		public Assignment getOutPortAssignment_6() { return cOutPortAssignment_6; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getOutPortIntegrationTSNodeOutputPortParserRuleCall_6_0() { return cOutPortIntegrationTSNodeOutputPortParserRuleCall_6_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_7() { return cRightCurlyBracketSemicolonKeyword_7; }
	}
	public class IntegrationViewSinkElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationViewSink");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSinkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cInPortAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cInPortIntegrationTSNodeInputPortParserRuleCall_6_0 = (RuleCall)cInPortAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Group cGroup_8 = (Group)cGroup.eContents().get(8);
		private final Keyword cOutKeyword_8_0 = (Keyword)cGroup_8.eContents().get(0);
		private final Assignment cOutPortAssignment_8_1 = (Assignment)cGroup_8.eContents().get(1);
		private final RuleCall cOutPortIntegrationTSNodeOutputPortParserRuleCall_8_1_0 = (RuleCall)cOutPortAssignment_8_1.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_9 = (Keyword)cGroup.eContents().get(9);
		
		///** A ViewSink is a TransportNode that only receives a View. */
		//IntegrationViewSink:
		//    'sink' name=ID description=STRING '{'
		//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//        ('out:'  outPort=IntegrationTSNodeOutputPort )?
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'sink' name=ID description=STRING '{'
		//    'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//    ('out:'  outPort=IntegrationTSNodeOutputPort )?
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'sink'
		public Keyword getSinkKeyword_0() { return cSinkKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'in:'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_5() { return cLeftSquareBracketKeyword_5; }
		
		//inPort+=IntegrationTSNodeInputPort+
		public Assignment getInPortAssignment_6() { return cInPortAssignment_6; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getInPortIntegrationTSNodeInputPortParserRuleCall_6_0() { return cInPortIntegrationTSNodeInputPortParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
		
		//('out:'  outPort=IntegrationTSNodeOutputPort )?
		public Group getGroup_8() { return cGroup_8; }
		
		//'out:'
		public Keyword getOutKeyword_8_0() { return cOutKeyword_8_0; }
		
		//outPort=IntegrationTSNodeOutputPort
		public Assignment getOutPortAssignment_8_1() { return cOutPortAssignment_8_1; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getOutPortIntegrationTSNodeOutputPortParserRuleCall_8_1_0() { return cOutPortIntegrationTSNodeOutputPortParserRuleCall_8_1_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_9() { return cRightCurlyBracketSemicolonKeyword_9; }
	}
	public class IntegrationViewTransformationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationViewTransformation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cXformKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cInPortAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cInPortIntegrationTSNodeInputPortParserRuleCall_6_0 = (RuleCall)cInPortAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cOutKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cOutPortAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0 = (RuleCall)cOutPortAssignment_9.eContents().get(0);
		private final Keyword cRightCurlyBracketSemicolonKeyword_10 = (Keyword)cGroup.eContents().get(10);
		
		///** A ViewTransformation represents an instance of transformation of data from one view type to another. */
		//IntegrationViewTransformation:
		//    'xform' name=ID description=STRING '{'
		//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//        'out:'  outPort=IntegrationTSNodeOutputPort
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'xform' name=ID description=STRING '{'
		//    'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//    'out:'  outPort=IntegrationTSNodeOutputPort
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'xform'
		public Keyword getXformKeyword_0() { return cXformKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'in:'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_5() { return cLeftSquareBracketKeyword_5; }
		
		//inPort+=IntegrationTSNodeInputPort+
		public Assignment getInPortAssignment_6() { return cInPortAssignment_6; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getInPortIntegrationTSNodeInputPortParserRuleCall_6_0() { return cInPortIntegrationTSNodeInputPortParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
		
		//'out:'
		public Keyword getOutKeyword_8() { return cOutKeyword_8; }
		
		//outPort=IntegrationTSNodeOutputPort
		public Assignment getOutPortAssignment_9() { return cOutPortAssignment_9; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0() { return cOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_10() { return cRightCurlyBracketSemicolonKeyword_10; }
	}
	public class IntegrationViewTransporterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationViewTransporter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cXportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cInKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cInPortAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cInPortIntegrationTSNodeInputPortParserRuleCall_6_0 = (RuleCall)cInPortAssignment_6.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cOutKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Assignment cOutPortAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0 = (RuleCall)cOutPortAssignment_9.eContents().get(0);
		private final Keyword cChanKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Assignment cChannelAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final CrossReference cChannelIntegrationTransportChannelCrossReference_11_0 = (CrossReference)cChannelAssignment_11.eContents().get(0);
		private final RuleCall cChannelIntegrationTransportChannelQNParserRuleCall_11_0_1 = (RuleCall)cChannelIntegrationTransportChannelCrossReference_11_0.eContents().get(1);
		private final Keyword cRightCurlyBracketSemicolonKeyword_12 = (Keyword)cGroup.eContents().get(12);
		
		///** A ViewTransporter represents the use of a TransportChannel with the intent of moving a view over it. */
		//IntegrationViewTransporter:
		//    'xport' name=ID description=STRING '{'
		//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//        'out:'  outPort=IntegrationTSNodeOutputPort
		//        'chan:' channel=[IntegrationTransportChannel|QN]
		//    '};'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'xport' name=ID description=STRING '{'
		//    'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
		//    'out:'  outPort=IntegrationTSNodeOutputPort
		//    'chan:' channel=[IntegrationTransportChannel|QN]
		//'};'
		public Group getGroup() { return cGroup; }
		
		//'xport'
		public Keyword getXportKeyword_0() { return cXportKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }
		
		//'in:'
		public Keyword getInKeyword_4() { return cInKeyword_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_5() { return cLeftSquareBracketKeyword_5; }
		
		//inPort+=IntegrationTSNodeInputPort+
		public Assignment getInPortAssignment_6() { return cInPortAssignment_6; }
		
		//IntegrationTSNodeInputPort
		public RuleCall getInPortIntegrationTSNodeInputPortParserRuleCall_6_0() { return cInPortIntegrationTSNodeInputPortParserRuleCall_6_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_7() { return cRightSquareBracketKeyword_7; }
		
		//'out:'
		public Keyword getOutKeyword_8() { return cOutKeyword_8; }
		
		//outPort=IntegrationTSNodeOutputPort
		public Assignment getOutPortAssignment_9() { return cOutPortAssignment_9; }
		
		//IntegrationTSNodeOutputPort
		public RuleCall getOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0() { return cOutPortIntegrationTSNodeOutputPortParserRuleCall_9_0; }
		
		//'chan:'
		public Keyword getChanKeyword_10() { return cChanKeyword_10; }
		
		//channel=[IntegrationTransportChannel|QN]
		public Assignment getChannelAssignment_11() { return cChannelAssignment_11; }
		
		//[IntegrationTransportChannel|QN]
		public CrossReference getChannelIntegrationTransportChannelCrossReference_11_0() { return cChannelIntegrationTransportChannelCrossReference_11_0; }
		
		//QN
		public RuleCall getChannelIntegrationTransportChannelQNParserRuleCall_11_0_1() { return cChannelIntegrationTransportChannelQNParserRuleCall_11_0_1; }
		
		//'};'
		public Keyword getRightCurlyBracketSemicolonKeyword_12() { return cRightCurlyBracketSemicolonKeyword_12; }
	}
	public class IntegrationTransportChannelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.IntegrationTransportChannel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cItcKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cDescriptionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cDescriptionSTRINGTerminalRuleCall_2_0 = (RuleCall)cDescriptionAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		///** A TransportChannel is a placeholder for an integrator supplied configuration between transport endpoints. */
		//IntegrationTransportChannel:
		//    'itc' name=ID description=STRING ';'
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'itc' name=ID description=STRING ';'
		public Group getGroup() { return cGroup; }
		
		//'itc'
		public Keyword getItcKeyword_0() { return cItcKeyword_0; }
		
		//name=ID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_1_0() { return cNameIDTerminalRuleCall_1_0; }
		
		//description=STRING
		public Assignment getDescriptionAssignment_2() { return cDescriptionAssignment_2; }
		
		//STRING
		public RuleCall getDescriptionSTRINGTerminalRuleCall_2_0() { return cDescriptionSTRINGTerminalRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	
	public class UoPClientServerRoleElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UoPClientServerRole");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCLIENTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCLIENTClientKeyword_0_0 = (Keyword)cCLIENTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSERVEREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSERVERServerKeyword_1_0 = (Keyword)cSERVEREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UoPClientServerRole:
		//    CLIENT='client' | SERVER='server'
		//;
		public EnumRule getRule() { return rule; }
		
		//CLIENT='client' | SERVER='server'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CLIENT='client'
		public EnumLiteralDeclaration getCLIENTEnumLiteralDeclaration_0() { return cCLIENTEnumLiteralDeclaration_0; }
		
		//'client'
		public Keyword getCLIENTClientKeyword_0_0() { return cCLIENTClientKeyword_0_0; }
		
		//SERVER='server'
		public EnumLiteralDeclaration getSERVEREnumLiteralDeclaration_1() { return cSERVEREnumLiteralDeclaration_1; }
		
		//'server'
		public Keyword getSERVERServerKeyword_1_0() { return cSERVERServerKeyword_1_0; }
	}
	public class UopFaceProfileElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopFaceProfile");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGENERAL_PURPOSEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGENERAL_PURPOSEGeneralPurposeKeyword_0_0 = (Keyword)cGENERAL_PURPOSEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSECURITYEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSECURITYSecurityKeyword_1_0 = (Keyword)cSECURITYEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cSAFETY_BASEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cSAFETY_BASESafetyBaseKeyword_2_0 = (Keyword)cSAFETY_BASEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSAFETY_EXTENDEDEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSAFETY_EXTENDEDSafetyExtendedKeyword_3_0 = (Keyword)cSAFETY_EXTENDEDEnumLiteralDeclaration_3.eContents().get(0);
		
		///** The FaceProfile enumeration captures the OS API subsets for a UoP as defined by the OSS. */
		//enum UopFaceProfile:
		//    GENERAL_PURPOSE = 'GeneralPurpose' |
		//    SECURITY = 'Security' |
		//    SAFETY_BASE = 'SafetyBase' |
		//    SAFETY_EXTENDED = 'SafetyExtended'
		//;
		public EnumRule getRule() { return rule; }
		
		//GENERAL_PURPOSE = 'GeneralPurpose' |
		//SECURITY = 'Security' |
		//SAFETY_BASE = 'SafetyBase' |
		//SAFETY_EXTENDED = 'SafetyExtended'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GENERAL_PURPOSE = 'GeneralPurpose'
		public EnumLiteralDeclaration getGENERAL_PURPOSEEnumLiteralDeclaration_0() { return cGENERAL_PURPOSEEnumLiteralDeclaration_0; }
		
		//'GeneralPurpose'
		public Keyword getGENERAL_PURPOSEGeneralPurposeKeyword_0_0() { return cGENERAL_PURPOSEGeneralPurposeKeyword_0_0; }
		
		//SECURITY = 'Security'
		public EnumLiteralDeclaration getSECURITYEnumLiteralDeclaration_1() { return cSECURITYEnumLiteralDeclaration_1; }
		
		//'Security'
		public Keyword getSECURITYSecurityKeyword_1_0() { return cSECURITYSecurityKeyword_1_0; }
		
		//SAFETY_BASE = 'SafetyBase'
		public EnumLiteralDeclaration getSAFETY_BASEEnumLiteralDeclaration_2() { return cSAFETY_BASEEnumLiteralDeclaration_2; }
		
		//'SafetyBase'
		public Keyword getSAFETY_BASESafetyBaseKeyword_2_0() { return cSAFETY_BASESafetyBaseKeyword_2_0; }
		
		//SAFETY_EXTENDED = 'SafetyExtended'
		public EnumLiteralDeclaration getSAFETY_EXTENDEDEnumLiteralDeclaration_3() { return cSAFETY_EXTENDEDEnumLiteralDeclaration_3; }
		
		//'SafetyExtended'
		public Keyword getSAFETY_EXTENDEDSafetyExtendedKeyword_3_0() { return cSAFETY_EXTENDEDSafetyExtendedKeyword_3_0; }
	}
	public class UopDesignAssuranceLevelElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopDesignAssuranceLevel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAAKeyword_0_0 = (Keyword)cAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBBKeyword_1_0 = (Keyword)cBEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCCKeyword_2_0 = (Keyword)cCEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDDKeyword_3_0 = (Keyword)cDEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cEEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cEEKeyword_4_0 = (Keyword)cEEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum UopDesignAssuranceLevel:
		//    A='a' | B='b' | C='c' | D='d' | E='e'
		//;
		public EnumRule getRule() { return rule; }
		
		//A='a' | B='b' | C='c' | D='d' | E='e'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//A='a'
		public EnumLiteralDeclaration getAEnumLiteralDeclaration_0() { return cAEnumLiteralDeclaration_0; }
		
		//'a'
		public Keyword getAAKeyword_0_0() { return cAAKeyword_0_0; }
		
		//B='b'
		public EnumLiteralDeclaration getBEnumLiteralDeclaration_1() { return cBEnumLiteralDeclaration_1; }
		
		//'b'
		public Keyword getBBKeyword_1_0() { return cBBKeyword_1_0; }
		
		//C='c'
		public EnumLiteralDeclaration getCEnumLiteralDeclaration_2() { return cCEnumLiteralDeclaration_2; }
		
		//'c'
		public Keyword getCCKeyword_2_0() { return cCCKeyword_2_0; }
		
		//D='d'
		public EnumLiteralDeclaration getDEnumLiteralDeclaration_3() { return cDEnumLiteralDeclaration_3; }
		
		//'d'
		public Keyword getDDKeyword_3_0() { return cDDKeyword_3_0; }
		
		//E='e'
		public EnumLiteralDeclaration getEEnumLiteralDeclaration_4() { return cEEnumLiteralDeclaration_4; }
		
		//'e'
		public Keyword getEEKeyword_4_0() { return cEEKeyword_4_0; }
	}
	public class UopDesignAssuranceStandardElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopDesignAssuranceStandard");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cDO_178B_ED_12BEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cDO_178B_ED_12BDO_178B_ED_12BKeyword_0_0 = (Keyword)cDO_178B_ED_12BEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDO_178C_ED_12CEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDO_178C_ED_12CDO_178C_ED_12CKeyword_1_0 = (Keyword)cDO_178C_ED_12CEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UopDesignAssuranceStandard:
		//    DO_178B_ED_12B='DO_178B_ED_12B' |
		//    DO_178C_ED_12C='DO_178C_ED_12C'
		//;
		public EnumRule getRule() { return rule; }
		
		//DO_178B_ED_12B='DO_178B_ED_12B' |
		//DO_178C_ED_12C='DO_178C_ED_12C'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//DO_178B_ED_12B='DO_178B_ED_12B'
		public EnumLiteralDeclaration getDO_178B_ED_12BEnumLiteralDeclaration_0() { return cDO_178B_ED_12BEnumLiteralDeclaration_0; }
		
		//'DO_178B_ED_12B'
		public Keyword getDO_178B_ED_12BDO_178B_ED_12BKeyword_0_0() { return cDO_178B_ED_12BDO_178B_ED_12BKeyword_0_0; }
		
		//DO_178C_ED_12C='DO_178C_ED_12C'
		public EnumLiteralDeclaration getDO_178C_ED_12CEnumLiteralDeclaration_1() { return cDO_178C_ED_12CEnumLiteralDeclaration_1; }
		
		//'DO_178C_ED_12C'
		public Keyword getDO_178C_ED_12CDO_178C_ED_12CKeyword_1_0() { return cDO_178C_ED_12CDO_178C_ED_12CKeyword_1_0; }
	}
	public class UopMessageExchangeTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopMessageExchangeType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cINBOUND_MESSAGEEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cINBOUND_MESSAGEInboundMessageKeyword_0_0 = (Keyword)cINBOUND_MESSAGEEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOUTBOUND_MESSAGEEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cOUTBOUND_MESSAGEOutboundMessageKeyword_1_0 = (Keyword)cOUTBOUND_MESSAGEEnumLiteralDeclaration_1.eContents().get(0);
		
		///** The MessageExchangeType enumeration captures the options for the message exchange type of a UoP port as defined by the TS Interface. */
		//enum UopMessageExchangeType:
		//    INBOUND_MESSAGE='InboundMessage' |
		//    OUTBOUND_MESSAGE='OutboundMessage'
		//;
		public EnumRule getRule() { return rule; }
		
		//INBOUND_MESSAGE='InboundMessage' |
		//OUTBOUND_MESSAGE='OutboundMessage'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INBOUND_MESSAGE='InboundMessage'
		public EnumLiteralDeclaration getINBOUND_MESSAGEEnumLiteralDeclaration_0() { return cINBOUND_MESSAGEEnumLiteralDeclaration_0; }
		
		//'InboundMessage'
		public Keyword getINBOUND_MESSAGEInboundMessageKeyword_0_0() { return cINBOUND_MESSAGEInboundMessageKeyword_0_0; }
		
		//OUTBOUND_MESSAGE='OutboundMessage'
		public EnumLiteralDeclaration getOUTBOUND_MESSAGEEnumLiteralDeclaration_1() { return cOUTBOUND_MESSAGEEnumLiteralDeclaration_1; }
		
		//'OutboundMessage'
		public Keyword getOUTBOUND_MESSAGEOutboundMessageKeyword_1_0() { return cOUTBOUND_MESSAGEOutboundMessageKeyword_1_0; }
	}
	public class UopPartitionTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopPartitionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPOSIXEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPOSIXPOSIXKeyword_0_0 = (Keyword)cPOSIXEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cARINC653EnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cARINC653ARINC653Keyword_1_0 = (Keyword)cARINC653EnumLiteralDeclaration_1.eContents().get(0);
		
		///** The PartitionType enumeration captures the OS API types for a UoP as defined by the OSS. */
		//enum UopPartitionType:
		//    POSIX='POSIX' | ARINC653='ARINC653'
		//;
		public EnumRule getRule() { return rule; }
		
		//POSIX='POSIX' | ARINC653='ARINC653'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//POSIX='POSIX'
		public EnumLiteralDeclaration getPOSIXEnumLiteralDeclaration_0() { return cPOSIXEnumLiteralDeclaration_0; }
		
		//'POSIX'
		public Keyword getPOSIXPOSIXKeyword_0_0() { return cPOSIXPOSIXKeyword_0_0; }
		
		//ARINC653='ARINC653'
		public EnumLiteralDeclaration getARINC653EnumLiteralDeclaration_1() { return cARINC653EnumLiteralDeclaration_1; }
		
		//'ARINC653'
		public Keyword getARINC653ARINC653Keyword_1_0() { return cARINC653ARINC653Keyword_1_0; }
	}
	public class UopProgrammingLanguageElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopProgrammingLanguage");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cUNSPECIFIEDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cUNSPECIFIEDUnspecifiedKeyword_0_0 = (Keyword)cUNSPECIFIEDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cCEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cCCKeyword_1_0 = (Keyword)cCEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cCPPEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cCPPCppKeyword_2_0 = (Keyword)cCPPEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cJAVAEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cJAVAJavaKeyword_3_0 = (Keyword)cJAVAEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cADAEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cADAAdaKeyword_4_0 = (Keyword)cADAEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cGOEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cGOGoKeyword_5_0 = (Keyword)cGOEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cJSEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cJSJavascriptKeyword_6_0 = (Keyword)cJSEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cPYTHONEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cPYTHONPythonKeyword_7_0 = (Keyword)cPYTHONEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cRUSTEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cRUSTRustKeyword_8_0 = (Keyword)cRUSTEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cSCALAEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cSCALAScalaKeyword_9_0 = (Keyword)cSCALAEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cSQLEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cSQLSQLKeyword_10_0 = (Keyword)cSQLEnumLiteralDeclaration_10.eContents().get(0);
		private final EnumLiteralDeclaration cTSEnumLiteralDeclaration_11 = (EnumLiteralDeclaration)cAlternatives.eContents().get(11);
		private final Keyword cTSTypescriptKeyword_11_0 = (Keyword)cTSEnumLiteralDeclaration_11.eContents().get(0);
		
		///** The ProgrammingLanguage enumeration captures the options for programming language API bindings as defined by Section 4.14. */
		//enum UopProgrammingLanguage:
		//    UNSPECIFIED = 'Unspecified' | // EXTENSION: Make it possible to not specify a language - this is first so it gets the '0' value, so if no value is specified, this one will be assumed
		//    C='C' | CPP='cpp' | JAVA='Java' | ADA='Ada'
		//    // EXTENSION: Additional languages not supported by FACE
		//    | GO='Go' | JS='Javascript' | PYTHON='Python' | RUST = 'Rust' | SCALA='Scala' | SQL='SQL' | TS='Typescript'
		//;
		public EnumRule getRule() { return rule; }
		
		//UNSPECIFIED = 'Unspecified' | // EXTENSION: Make it possible to not specify a language - this is first so it gets the '0' value, so if no value is specified, this one will be assumed
		//C='C' | CPP='cpp' | JAVA='Java' | ADA='Ada'
		//// EXTENSION: Additional languages not supported by FACE
		//| GO='Go' | JS='Javascript' | PYTHON='Python' | RUST = 'Rust' | SCALA='Scala' | SQL='SQL' | TS='Typescript'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UNSPECIFIED = 'Unspecified'
		public EnumLiteralDeclaration getUNSPECIFIEDEnumLiteralDeclaration_0() { return cUNSPECIFIEDEnumLiteralDeclaration_0; }
		
		//'Unspecified'
		public Keyword getUNSPECIFIEDUnspecifiedKeyword_0_0() { return cUNSPECIFIEDUnspecifiedKeyword_0_0; }
		
		//// EXTENSION: Make it possible to not specify a language - this is first so it gets the '0' value, so if no value is specified, this one will be assumed
		//   C='C'
		public EnumLiteralDeclaration getCEnumLiteralDeclaration_1() { return cCEnumLiteralDeclaration_1; }
		
		//'C'
		public Keyword getCCKeyword_1_0() { return cCCKeyword_1_0; }
		
		//CPP='cpp'
		public EnumLiteralDeclaration getCPPEnumLiteralDeclaration_2() { return cCPPEnumLiteralDeclaration_2; }
		
		//'cpp'
		public Keyword getCPPCppKeyword_2_0() { return cCPPCppKeyword_2_0; }
		
		//JAVA='Java'
		public EnumLiteralDeclaration getJAVAEnumLiteralDeclaration_3() { return cJAVAEnumLiteralDeclaration_3; }
		
		//'Java'
		public Keyword getJAVAJavaKeyword_3_0() { return cJAVAJavaKeyword_3_0; }
		
		//ADA='Ada'
		public EnumLiteralDeclaration getADAEnumLiteralDeclaration_4() { return cADAEnumLiteralDeclaration_4; }
		
		//'Ada'
		public Keyword getADAAdaKeyword_4_0() { return cADAAdaKeyword_4_0; }
		
		//GO='Go'
		public EnumLiteralDeclaration getGOEnumLiteralDeclaration_5() { return cGOEnumLiteralDeclaration_5; }
		
		//'Go'
		public Keyword getGOGoKeyword_5_0() { return cGOGoKeyword_5_0; }
		
		//JS='Javascript'
		public EnumLiteralDeclaration getJSEnumLiteralDeclaration_6() { return cJSEnumLiteralDeclaration_6; }
		
		//'Javascript'
		public Keyword getJSJavascriptKeyword_6_0() { return cJSJavascriptKeyword_6_0; }
		
		//PYTHON='Python'
		public EnumLiteralDeclaration getPYTHONEnumLiteralDeclaration_7() { return cPYTHONEnumLiteralDeclaration_7; }
		
		//'Python'
		public Keyword getPYTHONPythonKeyword_7_0() { return cPYTHONPythonKeyword_7_0; }
		
		//RUST = 'Rust'
		public EnumLiteralDeclaration getRUSTEnumLiteralDeclaration_8() { return cRUSTEnumLiteralDeclaration_8; }
		
		//'Rust'
		public Keyword getRUSTRustKeyword_8_0() { return cRUSTRustKeyword_8_0; }
		
		//SCALA='Scala'
		public EnumLiteralDeclaration getSCALAEnumLiteralDeclaration_9() { return cSCALAEnumLiteralDeclaration_9; }
		
		//'Scala'
		public Keyword getSCALAScalaKeyword_9_0() { return cSCALAScalaKeyword_9_0; }
		
		//SQL='SQL'
		public EnumLiteralDeclaration getSQLEnumLiteralDeclaration_10() { return cSQLEnumLiteralDeclaration_10; }
		
		//'SQL'
		public Keyword getSQLSQLKeyword_10_0() { return cSQLSQLKeyword_10_0; }
		
		//TS='Typescript'
		public EnumLiteralDeclaration getTSEnumLiteralDeclaration_11() { return cTSEnumLiteralDeclaration_11; }
		
		//'Typescript'
		public Keyword getTSTypescriptKeyword_11_0() { return cTSTypescriptKeyword_11_0; }
	}
	public class UopSynchronizationStyleElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopSynchronizationStyle");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBLOCKINGEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBLOCKINGBlockingKeyword_0_0 = (Keyword)cBLOCKINGEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNON_BLOCKINGEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNON_BLOCKINGNonBlockingKeyword_1_0 = (Keyword)cNON_BLOCKINGEnumLiteralDeclaration_1.eContents().get(0);
		
		///** The SynchronizationStyle enumeration captures the options for the synchronization style of a UoP port as defined by the TS Interface. */
		//enum UopSynchronizationStyle:
		//    BLOCKING='Blocking' | NON_BLOCKING='NonBlocking'
		//;
		public EnumRule getRule() { return rule; }
		
		//BLOCKING='Blocking' | NON_BLOCKING='NonBlocking'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BLOCKING='Blocking'
		public EnumLiteralDeclaration getBLOCKINGEnumLiteralDeclaration_0() { return cBLOCKINGEnumLiteralDeclaration_0; }
		
		//'Blocking'
		public Keyword getBLOCKINGBlockingKeyword_0_0() { return cBLOCKINGBlockingKeyword_0_0; }
		
		//NON_BLOCKING='NonBlocking'
		public EnumLiteralDeclaration getNON_BLOCKINGEnumLiteralDeclaration_1() { return cNON_BLOCKINGEnumLiteralDeclaration_1; }
		
		//'NonBlocking'
		public Keyword getNON_BLOCKINGNonBlockingKeyword_1_0() { return cNON_BLOCKINGNonBlockingKeyword_1_0; }
	}
	public class UopThreadTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.face.Face.UopThreadType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFOREGROUNDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFOREGROUNDForegroundKeyword_0_0 = (Keyword)cFOREGROUNDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cBACKGROUNDEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cBACKGROUNDBackgroundKeyword_1_0 = (Keyword)cBACKGROUNDEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UopThreadType:
		//    FOREGROUND='Foreground'| BACKGROUND='Background'
		//;
		public EnumRule getRule() { return rule; }
		
		//FOREGROUND='Foreground'| BACKGROUND='Background'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//FOREGROUND='Foreground'
		public EnumLiteralDeclaration getFOREGROUNDEnumLiteralDeclaration_0() { return cFOREGROUNDEnumLiteralDeclaration_0; }
		
		//'Foreground'
		public Keyword getFOREGROUNDForegroundKeyword_0_0() { return cFOREGROUNDForegroundKeyword_0_0; }
		
		//BACKGROUND='Background'
		public EnumLiteralDeclaration getBACKGROUNDEnumLiteralDeclaration_1() { return cBACKGROUNDEnumLiteralDeclaration_1; }
		
		//'Background'
		public Keyword getBACKGROUNDBackgroundKeyword_1_0() { return cBACKGROUNDBackgroundKeyword_1_0; }
	}
	
	private final ArchitectureModelElements pArchitectureModel;
	private final FaceElementElements pFaceElement;
	private final UoPClientServerRoleElements eUoPClientServerRole;
	private final UopFaceProfileElements eUopFaceProfile;
	private final UopDesignAssuranceLevelElements eUopDesignAssuranceLevel;
	private final UopDesignAssuranceStandardElements eUopDesignAssuranceStandard;
	private final UopMessageExchangeTypeElements eUopMessageExchangeType;
	private final UopPartitionTypeElements eUopPartitionType;
	private final UopProgrammingLanguageElements eUopProgrammingLanguage;
	private final UopSynchronizationStyleElements eUopSynchronizationStyle;
	private final UopThreadTypeElements eUopThreadType;
	private final UopUoPModelElements pUopUoPModel;
	private final UopElementElements pUopElement;
	private final UopSupportingComponentElements pUopSupportingComponent;
	private final UopLanguageRuntimeElements pUopLanguageRuntime;
	private final UopComponentFrameworkElements pUopComponentFramework;
	private final UopAbstractUoPElements pUopAbstractUoP;
	private final UopAbstractConnectionElements pUopAbstractConnection;
	private final UopUnitOfPortabilityElements pUopUnitOfPortability;
	private final UopPortableComponentElements pUopPortableComponent;
	private final UopPlatformSpecificComponentElements pUopPlatformSpecificComponent;
	private final UopThreadElements pUopThread;
	private final UopRAMMemoryRequirementsElements pUopRAMMemoryRequirements;
	private final UopConnectionElements pUopConnection;
	private final UopClientServerConnectionElements pUopClientServerConnection;
	private final UopPubSubConnectionElements pUopPubSubConnection;
	private final UopQueuingConnectionElements pUopQueuingConnection;
	private final UopSingleInstanceMessageConnectionElements pUopSingleInstanceMessageConnection;
	private final UopLifeCycleManagementPortElements pUopLifeCycleManagementPort;
	private final UopMessageTypeElements pUopMessageType;
	private final UopCompositeTemplateElements pUopCompositeTemplate;
	private final UopTemplateCompositionElements pUopTemplateComposition;
	private final UopTemplateElements pUopTemplate;
	private final IntegrationIntegrationModelElements pIntegrationIntegrationModel;
	private final IntegrationElementElements pIntegrationElement;
	private final IntegrationIntegrationContextElements pIntegrationIntegrationContext;
	private final IntegrationTSNodeConnectionElements pIntegrationTSNodeConnection;
	private final IntegrationTSNodePortBaseElements pIntegrationTSNodePortBase;
	private final IntegrationUoPInstanceElements pIntegrationUoPInstance;
	private final IntegrationUoPInputEndPointElements pIntegrationUoPInputEndPoint;
	private final IntegrationUoPOutputEndPointElements pIntegrationUoPOutputEndPoint;
	private final IntegrationTransportNodeElements pIntegrationTransportNode;
	private final IntegrationTSNodeInputPortElements pIntegrationTSNodeInputPort;
	private final IntegrationTSNodeOutputPortElements pIntegrationTSNodeOutputPort;
	private final IntegrationViewAggregationElements pIntegrationViewAggregation;
	private final IntegrationViewFilterElements pIntegrationViewFilter;
	private final IntegrationViewSourceElements pIntegrationViewSource;
	private final IntegrationViewSinkElements pIntegrationViewSink;
	private final IntegrationViewTransformationElements pIntegrationViewTransformation;
	private final IntegrationViewTransporterElements pIntegrationViewTransporter;
	private final IntegrationTransportChannelElements pIntegrationTransportChannel;
	
	private final Grammar grammar;
	
	private final UddlGrammarAccess gaUddl;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public FaceGrammarAccess(GrammarProvider grammarProvider,
			UddlGrammarAccess gaUddl,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaUddl = gaUddl;
		this.gaTerminals = gaTerminals;
		this.pArchitectureModel = new ArchitectureModelElements();
		this.pFaceElement = new FaceElementElements();
		this.eUoPClientServerRole = new UoPClientServerRoleElements();
		this.eUopFaceProfile = new UopFaceProfileElements();
		this.eUopDesignAssuranceLevel = new UopDesignAssuranceLevelElements();
		this.eUopDesignAssuranceStandard = new UopDesignAssuranceStandardElements();
		this.eUopMessageExchangeType = new UopMessageExchangeTypeElements();
		this.eUopPartitionType = new UopPartitionTypeElements();
		this.eUopProgrammingLanguage = new UopProgrammingLanguageElements();
		this.eUopSynchronizationStyle = new UopSynchronizationStyleElements();
		this.eUopThreadType = new UopThreadTypeElements();
		this.pUopUoPModel = new UopUoPModelElements();
		this.pUopElement = new UopElementElements();
		this.pUopSupportingComponent = new UopSupportingComponentElements();
		this.pUopLanguageRuntime = new UopLanguageRuntimeElements();
		this.pUopComponentFramework = new UopComponentFrameworkElements();
		this.pUopAbstractUoP = new UopAbstractUoPElements();
		this.pUopAbstractConnection = new UopAbstractConnectionElements();
		this.pUopUnitOfPortability = new UopUnitOfPortabilityElements();
		this.pUopPortableComponent = new UopPortableComponentElements();
		this.pUopPlatformSpecificComponent = new UopPlatformSpecificComponentElements();
		this.pUopThread = new UopThreadElements();
		this.pUopRAMMemoryRequirements = new UopRAMMemoryRequirementsElements();
		this.pUopConnection = new UopConnectionElements();
		this.pUopClientServerConnection = new UopClientServerConnectionElements();
		this.pUopPubSubConnection = new UopPubSubConnectionElements();
		this.pUopQueuingConnection = new UopQueuingConnectionElements();
		this.pUopSingleInstanceMessageConnection = new UopSingleInstanceMessageConnectionElements();
		this.pUopLifeCycleManagementPort = new UopLifeCycleManagementPortElements();
		this.pUopMessageType = new UopMessageTypeElements();
		this.pUopCompositeTemplate = new UopCompositeTemplateElements();
		this.pUopTemplateComposition = new UopTemplateCompositionElements();
		this.pUopTemplate = new UopTemplateElements();
		this.pIntegrationIntegrationModel = new IntegrationIntegrationModelElements();
		this.pIntegrationElement = new IntegrationElementElements();
		this.pIntegrationIntegrationContext = new IntegrationIntegrationContextElements();
		this.pIntegrationTSNodeConnection = new IntegrationTSNodeConnectionElements();
		this.pIntegrationTSNodePortBase = new IntegrationTSNodePortBaseElements();
		this.pIntegrationUoPInstance = new IntegrationUoPInstanceElements();
		this.pIntegrationUoPInputEndPoint = new IntegrationUoPInputEndPointElements();
		this.pIntegrationUoPOutputEndPoint = new IntegrationUoPOutputEndPointElements();
		this.pIntegrationTransportNode = new IntegrationTransportNodeElements();
		this.pIntegrationTSNodeInputPort = new IntegrationTSNodeInputPortElements();
		this.pIntegrationTSNodeOutputPort = new IntegrationTSNodeOutputPortElements();
		this.pIntegrationViewAggregation = new IntegrationViewAggregationElements();
		this.pIntegrationViewFilter = new IntegrationViewFilterElements();
		this.pIntegrationViewSource = new IntegrationViewSourceElements();
		this.pIntegrationViewSink = new IntegrationViewSinkElements();
		this.pIntegrationViewTransformation = new IntegrationViewTransformationElements();
		this.pIntegrationViewTransporter = new IntegrationViewTransporterElements();
		this.pIntegrationTransportChannel = new IntegrationTransportChannelElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.epistimis.face.Face".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public UddlGrammarAccess getUddlGrammarAccess() {
		return gaUddl;
	}
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	////// Starter rule comes first
	////@Override
	////ModelFile:
	////    includes+=Include*
	////    archModel=ArchitectureModel
	////;
	///** An ArchitectureModel is a container for DataModels, UoPModels, IntegrationModels, and TraceabilityModels. */
	//ArchitectureModel:
	//    'am' name=ID description=STRING '{'
	//    (dm+=DataModel | um+=UopUoPModel | im+=IntegrationIntegrationModel)+
	//    '}'
	//;
	public ArchitectureModelElements getArchitectureModelAccess() {
		return pArchitectureModel;
	}
	
	public ParserRule getArchitectureModelRule() {
		return getArchitectureModelAccess().getRule();
	}
	
	///** An Element is the root type for defining all named elements in the ArchitectureModel. The “name” attribute captures the name of the Element in the model. The “description” attribute captures a description for the element.
	// *  NOTE: Because of the way XText works, attributes bubble up from the bottom. So 'name' and 'description' are specified in leaf rules but show up in
	// *  the generated API for FaceElement
	// * */
	//FaceElement:
	//    ArchitectureModel |
	//    UopUoPModel |
	//    IntegrationIntegrationModel |
	//    UopElement |
	//    IntegrationElement |
	//    IntegrationTransportNode
	//;
	public FaceElementElements getFaceElementAccess() {
		return pFaceElement;
	}
	
	public ParserRule getFaceElementRule() {
		return getFaceElementAccess().getRule();
	}
	
	//enum UoPClientServerRole:
	//    CLIENT='client' | SERVER='server'
	//;
	public UoPClientServerRoleElements getUoPClientServerRoleAccess() {
		return eUoPClientServerRole;
	}
	
	public EnumRule getUoPClientServerRoleRule() {
		return getUoPClientServerRoleAccess().getRule();
	}
	
	///** The FaceProfile enumeration captures the OS API subsets for a UoP as defined by the OSS. */
	//enum UopFaceProfile:
	//    GENERAL_PURPOSE = 'GeneralPurpose' |
	//    SECURITY = 'Security' |
	//    SAFETY_BASE = 'SafetyBase' |
	//    SAFETY_EXTENDED = 'SafetyExtended'
	//;
	public UopFaceProfileElements getUopFaceProfileAccess() {
		return eUopFaceProfile;
	}
	
	public EnumRule getUopFaceProfileRule() {
		return getUopFaceProfileAccess().getRule();
	}
	
	//enum UopDesignAssuranceLevel:
	//    A='a' | B='b' | C='c' | D='d' | E='e'
	//;
	public UopDesignAssuranceLevelElements getUopDesignAssuranceLevelAccess() {
		return eUopDesignAssuranceLevel;
	}
	
	public EnumRule getUopDesignAssuranceLevelRule() {
		return getUopDesignAssuranceLevelAccess().getRule();
	}
	
	//enum UopDesignAssuranceStandard:
	//    DO_178B_ED_12B='DO_178B_ED_12B' |
	//    DO_178C_ED_12C='DO_178C_ED_12C'
	//;
	public UopDesignAssuranceStandardElements getUopDesignAssuranceStandardAccess() {
		return eUopDesignAssuranceStandard;
	}
	
	public EnumRule getUopDesignAssuranceStandardRule() {
		return getUopDesignAssuranceStandardAccess().getRule();
	}
	
	///** The MessageExchangeType enumeration captures the options for the message exchange type of a UoP port as defined by the TS Interface. */
	//enum UopMessageExchangeType:
	//    INBOUND_MESSAGE='InboundMessage' |
	//    OUTBOUND_MESSAGE='OutboundMessage'
	//;
	public UopMessageExchangeTypeElements getUopMessageExchangeTypeAccess() {
		return eUopMessageExchangeType;
	}
	
	public EnumRule getUopMessageExchangeTypeRule() {
		return getUopMessageExchangeTypeAccess().getRule();
	}
	
	///** The PartitionType enumeration captures the OS API types for a UoP as defined by the OSS. */
	//enum UopPartitionType:
	//    POSIX='POSIX' | ARINC653='ARINC653'
	//;
	public UopPartitionTypeElements getUopPartitionTypeAccess() {
		return eUopPartitionType;
	}
	
	public EnumRule getUopPartitionTypeRule() {
		return getUopPartitionTypeAccess().getRule();
	}
	
	///** The ProgrammingLanguage enumeration captures the options for programming language API bindings as defined by Section 4.14. */
	//enum UopProgrammingLanguage:
	//    UNSPECIFIED = 'Unspecified' | // EXTENSION: Make it possible to not specify a language - this is first so it gets the '0' value, so if no value is specified, this one will be assumed
	//    C='C' | CPP='cpp' | JAVA='Java' | ADA='Ada'
	//    // EXTENSION: Additional languages not supported by FACE
	//    | GO='Go' | JS='Javascript' | PYTHON='Python' | RUST = 'Rust' | SCALA='Scala' | SQL='SQL' | TS='Typescript'
	//;
	public UopProgrammingLanguageElements getUopProgrammingLanguageAccess() {
		return eUopProgrammingLanguage;
	}
	
	public EnumRule getUopProgrammingLanguageRule() {
		return getUopProgrammingLanguageAccess().getRule();
	}
	
	///** The SynchronizationStyle enumeration captures the options for the synchronization style of a UoP port as defined by the TS Interface. */
	//enum UopSynchronizationStyle:
	//    BLOCKING='Blocking' | NON_BLOCKING='NonBlocking'
	//;
	public UopSynchronizationStyleElements getUopSynchronizationStyleAccess() {
		return eUopSynchronizationStyle;
	}
	
	public EnumRule getUopSynchronizationStyleRule() {
		return getUopSynchronizationStyleAccess().getRule();
	}
	
	//enum UopThreadType:
	//    FOREGROUND='Foreground'| BACKGROUND='Background'
	//;
	public UopThreadTypeElements getUopThreadTypeAccess() {
		return eUopThreadType;
	}
	
	public EnumRule getUopThreadTypeRule() {
		return getUopThreadTypeAccess().getRule();
	}
	
	///** A UoPModel is a container for UoC Elements. */
	//UopUoPModel:
	//    'um' name=ID description=STRING '{'
	//        (um+=UopUoPModel | element +=UopElement)+
	//    '}'
	//;
	public UopUoPModelElements getUopUoPModelAccess() {
		return pUopUoPModel;
	}
	
	public ParserRule getUopUoPModelRule() {
		return getUopUoPModelAccess().getRule();
	}
	
	///** A uop Element is the root type for defining the component elements of the ArchitectureModel. */
	//UopElement:
	//    UopSupportingComponent |
	//    UopUnitOfPortability |
	//    UopAbstractUoP |
	//    UopMessageType
	//;
	public UopElementElements getUopElementAccess() {
		return pUopElement;
	}
	
	public ParserRule getUopElementRule() {
		return getUopElementAccess().getRule();
	}
	
	///** A SupportingComponent is a LanguageRunTime or ApplicationFramework. The “version” attribute is the version of the SupportingComponent. */
	//UopSupportingComponent:
	//    UopComponentFramework |
	//    UopLanguageRuntime
	//;
	public UopSupportingComponentElements getUopSupportingComponentAccess() {
		return pUopSupportingComponent;
	}
	
	public ParserRule getUopSupportingComponentRule() {
		return getUopSupportingComponentAccess().getRule();
	}
	
	///** A LanguageRunTime is a language run-time as defined in Section 4.2.3. */
	//UopLanguageRuntime:
	//    'runtime' name=ID ':' version=ID description=STRING ';'
	//;
	public UopLanguageRuntimeElements getUopLanguageRuntimeAccess() {
		return pUopLanguageRuntime;
	}
	
	public ParserRule getUopLanguageRuntimeRule() {
		return getUopLanguageRuntimeAccess().getRule();
	}
	
	///** A ComponentFramework is an application framework as defined in Section 4.2.4. */
	//UopComponentFramework:
	//    'framework' name=ID ':' version=ID description=STRING ';'
	//;
	public UopComponentFrameworkElements getUopComponentFrameworkAccess() {
		return pUopComponentFramework;
	}
	
	public ParserRule getUopComponentFrameworkRule() {
		return getUopComponentFrameworkAccess().getRule();
	}
	
	///** An AbstractUoP is used to capture the specification of a UoP. */
	//UopAbstractUoP:
	//    'aUoP' name=ID description=STRING '{'
	//        (connection+=UopAbstractConnection)*
	//    '};'
	//;
	public UopAbstractUoPElements getUopAbstractUoPAccess() {
		return pUopAbstractUoP;
	}
	
	public ParserRule getUopAbstractUoPRule() {
		return getUopAbstractUoPAccess().getRule();
	}
	
	///** An AbstractConnection captures the input and output characteristics of an AbstractUoP by specifying data at a Logical or Conceptual level. */
	//UopAbstractConnection:
	//    'aconn' name=ID description=STRING '{'
	//        ( 'c' conceptualView=[uddl::ConceptualView|QN])?
	//        ( 'l' logicalView=[uddl::LogicalView|QN])?
	//    '};'
	//;
	public UopAbstractConnectionElements getUopAbstractConnectionAccess() {
		return pUopAbstractConnection;
	}
	
	public ParserRule getUopAbstractConnectionRule() {
		return getUopAbstractConnectionAccess().getRule();
	}
	
	///** A UnitOfPortability is a FACE PlatformSpecificComponent or PortableComponent. */
	//UopUnitOfPortability:
	//    UopPortableComponent |
	//    UopPlatformSpecificComponent
	//    ;
	public UopUnitOfPortabilityElements getUopUnitOfPortabilityAccess() {
		return pUopUnitOfPortability;
	}
	
	public ParserRule getUopUnitOfPortabilityRule() {
		return getUopUnitOfPortabilityAccess().getRule();
	}
	
	///** A PortableComponent is a software component as defined by the PCS. */
	//UopPortableComponent:
	//    'pc'  name=ID description=STRING ('->' realizes=[UopAbstractUoP|QN])? '{'
	//        'lang:' transportAPILanguage=UopProgrammingLanguage
	//        ('part:' partitionType=UopPartitionType)?     // EXTENSION: making partitionType optional
	//        ('prof:' faceProfile=UopFaceProfile)?          // EXTENSION: making faceProfile optional
	//        ('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
	//        ('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
	//        ('RAM:' memoryRequirements=UopRAMMemoryRequirements)? // EXTENSION: making memoryRequirements optional
	//        ('thread:' '[' thread+=UopThread+ ']')?        // EXTENSION: making thread optional
	//        ('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
	//        'conn:' '[' connection+=UopConnection+ ']'
	//        ('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
	//        ('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])? // EXTENSION: can supply a wiring diagram with implementation details
	//    '};'
	//;
	public UopPortableComponentElements getUopPortableComponentAccess() {
		return pUopPortableComponent;
	}
	
	public ParserRule getUopPortableComponentRule() {
		return getUopPortableComponentAccess().getRule();
	}
	
	///** A PlatformSpecificComponent is a software component as defined by the PSSS. */
	//UopPlatformSpecificComponent:
	//     'psc' name=ID description=STRING ('->' realizes=[UopAbstractUoP|QN])? '{'
	//        'lang:' transportAPILanguage=UopProgrammingLanguage
	//        ('part:' partitionType=UopPartitionType)?     // EXTENSION: making partitionType optional
	//        ('prof:' faceProfile=UopFaceProfile)?          // EXTENSION: making faceProfile optional
	//        ('DAL:' designAssuranceLevel=UopDesignAssuranceLevel)?
	//        ('DAS:' designAssuranceStandard=UopDesignAssuranceStandard)?
	//        ('RAM:' memoryRequirements=UopRAMMemoryRequirements)? // EXTENSION: making memoryRequirements optional
	//        ('thread:' '[' thread+=UopThread+ ']')?        // EXTENSION: making thread optional
	//        ('support:' '[' supportingComponent+=[UopSupportingComponent|QN]+ ']')?
	//        'conn:' '[' connection+=UopConnection+ ']'
	//        ('lcm:' '[' lcmPort+=UopLifeCycleManagementPort lcmPort+=UopLifeCycleManagementPort? ']' )?
	//        ('implementedBy:' implementedBy=[IntegrationIntegrationContext|QN])? // EXTENSION: can supply a wiring diagram with implementation details
	//    '};'
	//;
	public UopPlatformSpecificComponentElements getUopPlatformSpecificComponentAccess() {
		return pUopPlatformSpecificComponent;
	}
	
	public ParserRule getUopPlatformSpecificComponentRule() {
		return getUopPlatformSpecificComponentAccess().getRule();
	}
	
	///** A Thread defines the properties for the scheduling of a thread. */
	//UopThread: '('
	//    'per:' period=FLOAT
	//    'timeCap:' timeCapacity=FLOAT
	//    'prio:' relativePriority=INT
	//    'core:' relativeCoreAffinity=INT
	//    'thread:' threadType=UopThreadType
	//    ')'
	//    ;
	public UopThreadElements getUopThreadAccess() {
		return pUopThread;
	}
	
	public ParserRule getUopThreadRule() {
		return getUopThreadAccess().getRule();
	}
	
	///** A RAMMemoryRequirements defines memory resources required by a UoP. */
	//UopRAMMemoryRequirements:
	//    {UopRAMMemoryRequirements}
	//    '('
	//    ('heap:' '[' heapStackMin=INT? ':' heapStackTypical=INT? ':' heapStackMax=INT? ']')?
	//    ('text:'     textMax=INT)?
	//    ('roData:'     roDataMax=INT)?
	//    ('data:'     dataMax=INT)?
	//    ('bss:'     bssMax=INT)?
	//    ')'
	//;
	public UopRAMMemoryRequirementsElements getUopRAMMemoryRequirementsAccess() {
		return pUopRAMMemoryRequirements;
	}
	
	public ParserRule getUopRAMMemoryRequirementsRule() {
		return getUopRAMMemoryRequirementsAccess().getRule();
	}
	
	///** A Connection is a communication endpoint on a FACE UoP. A Connection is either a Publisher, Subscriber, Client, or Server. The “messageType” specifies the platform View that is transmitted through the endpoint. If “period” is not specified, the endpoint is aperiodic. If “period” is specified, the value is the period of the endpoint in seconds. */
	//UopConnection:
	//    UopPubSubConnection |
	//    UopClientServerConnection
	//;
	public UopConnectionElements getUopConnectionAccess() {
		return pUopConnection;
	}
	
	public ParserRule getUopConnectionRule() {
		return getUopConnectionAccess().getRule();
	}
	
	///** A ClientServerConnection is a Request/Reply Connection as defined in Section 4.7. */
	//UopClientServerConnection:
	//    'csconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
	//         'msg:' '[' requestType=[UopMessageType|QN] '/' responseType=[UopMessageType|QN] ']'
	//                (synchronizationStyle=UopSynchronizationStyle)?
	//         'role:' role=UoPClientServerRole
	//         ('period:' period=FLOAT)?
	//        ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
	//    '}'
	//;
	public UopClientServerConnectionElements getUopClientServerConnectionAccess() {
		return pUopClientServerConnection;
	}
	
	public ParserRule getUopClientServerConnectionRule() {
		return getUopClientServerConnectionAccess().getRule();
	}
	
	///** A PubSubConnection is a QueuingConnection or a SingleInstanceMessageConnection. The “messageExchangeType” attribute defines the direction of the message relative to the UoP. */
	//UopPubSubConnection:
	//    UopQueuingConnection |
	//    UopSingleInstanceMessageConnection
	//;
	public UopPubSubConnectionElements getUopPubSubConnectionAccess() {
		return pUopPubSubConnection;
	}
	
	public ParserRule getUopPubSubConnectionRule() {
		return getUopPubSubConnectionAccess().getRule();
	}
	
	///** A QueuingConnection is a PubSubConnection that supports buffering/queuing as defined in Section 4.8.  */
	//UopQueuingConnection:
	//    'qconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
	//         'msg:'  messageExchangeType=UopMessageExchangeType
	//                 messageType=[UopMessageType|QN]
	//                 (synchronizationStyle=UopSynchronizationStyle)?
	//        ('depth:' depth=INT)?
	//         ('period:' period=FLOAT)?
	//        ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
	//        '}'
	//;
	public UopQueuingConnectionElements getUopQueuingConnectionAccess() {
		return pUopQueuingConnection;
	}
	
	public ParserRule getUopQueuingConnectionRule() {
		return getUopQueuingConnectionAccess().getRule();
	}
	
	///** A SingleInstanceMessageConnection is a PubSubConnection that supports single instance messaging as defined in Section 4.8.  */
	//UopSingleInstanceMessageConnection:
	//    'simconn' name=ID description=STRING ('->' realizes=[UopAbstractConnection|QN])? '{'
	//         'msg:'  messageExchangeType=UopMessageExchangeType
	//                 messageType=[UopMessageType|QN]
	//                 (synchronizationStyle=UopSynchronizationStyle )?
	//         ('period:' period=FLOAT)?
	//        ('mapsTo:' mapsTo=[IntegrationTransportNode|QN])? // EXTENSION: If the owning UoPComponent has an implementing IC, this should map to a TransportNode in that IC
	//        '}'
	//;
	public UopSingleInstanceMessageConnectionElements getUopSingleInstanceMessageConnectionAccess() {
		return pUopSingleInstanceMessageConnection;
	}
	
	public ParserRule getUopSingleInstanceMessageConnectionRule() {
		return getUopSingleInstanceMessageConnectionAccess().getRule();
	}
	
	///** A LifeCycleManagementPort is used to define the life-cycle interface for the component. The “messageExchangeType” attribute defines the direction of the life-cycle message relative to the UoP.  */
	//UopLifeCycleManagementPort:
	//    '(' messageExchangeType=UopMessageExchangeType lcmMessageType=[UopMessageType|QN] ')'
	//;
	public UopLifeCycleManagementPortElements getUopLifeCycleManagementPortAccess() {
		return pUopLifeCycleManagementPort;
	}
	
	public ParserRule getUopLifeCycleManagementPortRule() {
		return getUopLifeCycleManagementPortAccess().getRule();
	}
	
	///** A MessageType is a Template or a CompositeTemplate. */
	//UopMessageType:
	//    UopTemplate |
	//    UopCompositeTemplate
	//;
	public UopMessageTypeElements getUopMessageTypeAccess() {
		return pUopMessageType;
	}
	
	public ParserRule getUopMessageTypeRule() {
		return getUopMessageTypeAccess().getRule();
	}
	
	///** A CompositeTemplate is a collection of two or more Templates. The “isUnion” attribute specifies whether the composed Templates are to be represented as cases in an IDL union or as members of an IDL struct. */
	//UopCompositeTemplate:
	//    'ctempl' name=ID description=STRING ('->' realizes=[uddl::LogicalCompositeQuery|QN])? '{'
	//        isUnion?='isUnion'
	//        composition+=UopTemplateComposition (composition+=UopTemplateComposition)+
	//    '};'
	//;
	public UopCompositeTemplateElements getUopCompositeTemplateAccess() {
		return pUopCompositeTemplate;
	}
	
	public ParserRule getUopCompositeTemplateRule() {
		return getUopCompositeTemplateAccess().getRule();
	}
	
	///** A TemplateComposition is the mechanism that allows a CompositeTemplate to be constructed from Templates and other CompositeTemplates. The “rolename” attribute defines the name of the composed platform View within the scope of the composing CompositeTemplate. The “type” of a TemplateComposition is the platform View being used to construct the CompositeTemplate. */
	//UopTemplateComposition:
	//    type=[UopMessageType|QN] rolename=STRING ('->' realizes=[uddl::LogicalQueryComposition|QN])?
	//;
	public UopTemplateCompositionElements getUopTemplateCompositionAccess() {
		return pUopTemplateComposition;
	}
	
	public ParserRule getUopTemplateCompositionRule() {
		return getUopTemplateCompositionAccess().getRule();
	}
	
	///** A Template is a specification that defines a structure for Characteristics projected by its “boundQuery” or its “effectiveQuery”. The “specification” attribute captures the specification of a Template as defined by the Template grammar in Section J.4.  */
	//UopTemplate:
	//    'templ' name=ID description=STRING  '{'
	//        'spec:' specification=STRING
	//        'bound:' boundQuery=[uddl::PlatformQuery|QN]
	//        ('effective:' effectiveQuery=[uddl::PlatformQuery|QN])?
	//    '};'
	//;
	public UopTemplateElements getUopTemplateAccess() {
		return pUopTemplate;
	}
	
	public ParserRule getUopTemplateRule() {
		return getUopTemplateAccess().getRule();
	}
	
	//// -------------- Integration -----------
	//// ----
	///** An IntegrationModel is a container for integration Elements.  */
	//IntegrationIntegrationModel:
	//    'im' name=ID description=STRING '{'
	//        (im+=IntegrationIntegrationModel | element+=IntegrationElement)*
	//    '}'
	//;
	public IntegrationIntegrationModelElements getIntegrationIntegrationModelAccess() {
		return pIntegrationIntegrationModel;
	}
	
	public ParserRule getIntegrationIntegrationModelRule() {
		return getIntegrationIntegrationModelAccess().getRule();
	}
	
	///** An integration Element is the root type for defining the integration elements of the ArchitectureModel. */
	//IntegrationElement:
	//    IntegrationUoPInstance |
	//    IntegrationTransportChannel |
	//    IntegrationIntegrationContext
	//;
	public IntegrationElementElements getIntegrationElementAccess() {
		return pIntegrationElement;
	}
	
	public ParserRule getIntegrationElementRule() {
		return getIntegrationElementAccess().getRule();
	}
	
	///** An IntegrationContext is a container used to group a set of TransportNodes and TSNodeConnections related to each other by a common, integrator defined context (e.g., collection and distribution of navigation data). */
	//IntegrationIntegrationContext:
	//    'ic' name=ID description=STRING '{'
	//        ('xport:''[' node+=IntegrationTransportNode+ ']')?
	//        ('conn:' '['connection+=IntegrationTSNodeConnection+ ']')?
	//    '}'
	//;
	public IntegrationIntegrationContextElements getIntegrationIntegrationContextAccess() {
		return pIntegrationIntegrationContext;
	}
	
	public ParserRule getIntegrationIntegrationContextRule() {
		return getIntegrationIntegrationContextAccess().getRule();
	}
	
	///** A TSNodeConnection represents a connection between two TransportNodes.
	// * NOTE: This rule as defined subsumes the functionality of the derived classes from the spec.
	// */
	//IntegrationTSNodeConnection:
	//    // Could make U2U the default
	//    '(' ('U2U')? source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')' |
	//    '(' 'U2T' source=[IntegrationUoPOutputEndPoint|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')' |
	//    '(' 'T2U' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationUoPInputEndPoint|QN] ')' |
	//    '(' 'T2T' source=[IntegrationTSNodeOutputPort|QN] '->' destination=[IntegrationTSNodeInputPort|QN] ')'
	//;
	public IntegrationTSNodeConnectionElements getIntegrationTSNodeConnectionAccess() {
		return pIntegrationTSNodeConnection;
	}
	
	public ParserRule getIntegrationTSNodeConnectionRule() {
		return getIntegrationTSNodeConnectionAccess().getRule();
	}
	
	///** A TSNodePortBase is a port that can be used to connect a TransportNode and a UoPEndPoint together using a TSNodeConnection. */
	//IntegrationTSNodePortBase:
	////    IntegrationUoPEndPoint |
	////    IntegrationTSNodePort
	//// Directly insert these rules because the intermediate rules lead to a grammar ambiguity
	//    IntegrationUoPInputEndPoint |
	//    IntegrationUoPOutputEndPoint |
	//    IntegrationTSNodeInputPort |
	//    IntegrationTSNodeOutputPort
	//;
	public IntegrationTSNodePortBaseElements getIntegrationTSNodePortBaseAccess() {
		return pIntegrationTSNodePortBase;
	}
	
	public ParserRule getIntegrationTSNodePortBaseRule() {
		return getIntegrationTSNodePortBaseAccess().getRule();
	}
	
	///** A UoPInstance represents an instance of a specific UoP within the system bounded by an integration model. An integration model can contain multiple instances of the same UoP. */
	//IntegrationUoPInstance:
	//    'uinst' name=ID description=STRING '->' realizes=[UopUnitOfPortability|QN]  '{'
	//        ('uri:' configurationURI=STRING)?
	//        ('input:' '[' input+=IntegrationUoPInputEndPoint+ ']')?
	//        ('output:' '[' output+=IntegrationUoPOutputEndPoint+ ']')?
	//    '};'
	//;
	public IntegrationUoPInstanceElements getIntegrationUoPInstanceAccess() {
		return pIntegrationUoPInstance;
	}
	
	public ParserRule getIntegrationUoPInstanceRule() {
		return getIntegrationUoPInstanceAccess().getRule();
	}
	
	//// EXTENSION: Technically, the IntegrationTSNodeConnection rule sidesteps any need for this rule.
	///** A UoPEndPoint is a specialization of a TSNodePortBase that allows connections in a UoPInstance to be part of a TSNodeConnection. This supports connecting UOP input and output endpoints to each other and to transport node input and output ports. */
	////IntegrationUoPEndPoint:
	////    IntegrationUoPInputEndPoint |
	////    IntegrationUoPOutputEndPoint
	////;
	///** A UoPInputEndPoint is a specialization of a UoPEndPoint providing an endpoint which is used to input data to a UoP. */
	//IntegrationUoPInputEndPoint:
	//    connection=[UopConnection|QN]
	//;
	public IntegrationUoPInputEndPointElements getIntegrationUoPInputEndPointAccess() {
		return pIntegrationUoPInputEndPoint;
	}
	
	public ParserRule getIntegrationUoPInputEndPointRule() {
		return getIntegrationUoPInputEndPointAccess().getRule();
	}
	
	///** A UoPOutputEndPoint is a specialization of a UoPEndPoint providing an endpoint which is used to output data from a UoP. */
	//IntegrationUoPOutputEndPoint:
	//     connection=[UopConnection|QN]
	//;
	public IntegrationUoPOutputEndPointElements getIntegrationUoPOutputEndPointAccess() {
		return pIntegrationUoPOutputEndPoint;
	}
	
	public ParserRule getIntegrationUoPOutputEndPointRule() {
		return getIntegrationUoPOutputEndPointAccess().getRule();
	}
	
	///** A TransportNode is an abstraction of a node that performs a function along a path of communication from source UoPs to destination UoPs.  */
	//IntegrationTransportNode:
	//    IntegrationViewTransporter |
	//    IntegrationViewAggregation |
	//    IntegrationViewTransformation |
	//    IntegrationViewFilter |
	//    IntegrationViewSink |
	//    IntegrationViewSource
	//;
	public IntegrationTransportNodeElements getIntegrationTransportNodeAccess() {
		return pIntegrationTransportNode;
	}
	
	public ParserRule getIntegrationTransportNodeRule() {
		return getIntegrationTransportNodeAccess().getRule();
	}
	
	//// EXTENSION: Technically, the IntegrationTSNodeConnection rule sidesteps any need for this rule.
	///** A TSNodePort is a port that provides a connection point to a TransportNode. A TSNodePort is typed by the “view” it references. */
	////IntegrationTSNodePort:
	////    IntegrationTSNodeOutputPort |
	////    IntegrationTSNodeInputPort
	////;
	///** A TSNodeInputPort is a specialization of a TSNodePort providing an endpoint which is used to input data to a TransportNode. */
	//IntegrationTSNodeInputPort:
	//     view=[UopMessageType|QN]
	//;
	public IntegrationTSNodeInputPortElements getIntegrationTSNodeInputPortAccess() {
		return pIntegrationTSNodeInputPort;
	}
	
	public ParserRule getIntegrationTSNodeInputPortRule() {
		return getIntegrationTSNodeInputPortAccess().getRule();
	}
	
	///** A TSNodeOutputPort is a specialization of a TSNodePort providing an endpoint which is used to output data from a TransportNode. */
	//IntegrationTSNodeOutputPort:
	//     view=[UopMessageType|QN]
	//;
	public IntegrationTSNodeOutputPortElements getIntegrationTSNodeOutputPortAccess() {
		return pIntegrationTSNodeOutputPort;
	}
	
	public ParserRule getIntegrationTSNodeOutputPortRule() {
		return getIntegrationTSNodeOutputPortAccess().getRule();
	}
	
	///** A ViewAggregation represents of an instance of aggregation of data from multiple incoming views into a single outgoing view type, including transformation of input data to that required by the output view type. */
	//IntegrationViewAggregation:
	//    'agg' name=ID description=STRING '{'
	//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
	//        'out:'  outPort=IntegrationTSNodeOutputPort
	//    '};'
	//;
	public IntegrationViewAggregationElements getIntegrationViewAggregationAccess() {
		return pIntegrationViewAggregation;
	}
	
	public ParserRule getIntegrationViewAggregationRule() {
		return getIntegrationViewAggregationAccess().getRule();
	}
	
	///** A ViewFilter represents of an instance of a filter of data allowing a view to either pass through a filter, or to be filtered out (i.e., not passed through). A ViewFilter performs no transformation of data. */
	//IntegrationViewFilter:
	//    'filter' name=ID description=STRING '{'
	//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
	//        ('out:'  outPort=IntegrationTSNodeOutputPort )?
	//    '};'
	//;
	public IntegrationViewFilterElements getIntegrationViewFilterAccess() {
		return pIntegrationViewFilter;
	}
	
	public ParserRule getIntegrationViewFilterRule() {
		return getIntegrationViewFilterAccess().getRule();
	}
	
	///** A ViewSource is a TransportNode that only provides a View. */
	//IntegrationViewSource:
	//    'src' name=ID description=STRING '{'
	//        ('in:' '[' inPort+=IntegrationTSNodeInputPort+ ']')?
	//        'out:'  outPort=IntegrationTSNodeOutputPort
	//    '};'
	//;
	public IntegrationViewSourceElements getIntegrationViewSourceAccess() {
		return pIntegrationViewSource;
	}
	
	public ParserRule getIntegrationViewSourceRule() {
		return getIntegrationViewSourceAccess().getRule();
	}
	
	///** A ViewSink is a TransportNode that only receives a View. */
	//IntegrationViewSink:
	//    'sink' name=ID description=STRING '{'
	//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
	//        ('out:'  outPort=IntegrationTSNodeOutputPort )?
	//    '};'
	//;
	public IntegrationViewSinkElements getIntegrationViewSinkAccess() {
		return pIntegrationViewSink;
	}
	
	public ParserRule getIntegrationViewSinkRule() {
		return getIntegrationViewSinkAccess().getRule();
	}
	
	///** A ViewTransformation represents an instance of transformation of data from one view type to another. */
	//IntegrationViewTransformation:
	//    'xform' name=ID description=STRING '{'
	//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
	//        'out:'  outPort=IntegrationTSNodeOutputPort
	//    '};'
	//;
	public IntegrationViewTransformationElements getIntegrationViewTransformationAccess() {
		return pIntegrationViewTransformation;
	}
	
	public ParserRule getIntegrationViewTransformationRule() {
		return getIntegrationViewTransformationAccess().getRule();
	}
	
	///** A ViewTransporter represents the use of a TransportChannel with the intent of moving a view over it. */
	//IntegrationViewTransporter:
	//    'xport' name=ID description=STRING '{'
	//        'in:' '[' inPort+=IntegrationTSNodeInputPort+ ']'
	//        'out:'  outPort=IntegrationTSNodeOutputPort
	//        'chan:' channel=[IntegrationTransportChannel|QN]
	//    '};'
	//;
	public IntegrationViewTransporterElements getIntegrationViewTransporterAccess() {
		return pIntegrationViewTransporter;
	}
	
	public ParserRule getIntegrationViewTransporterRule() {
		return getIntegrationViewTransporterAccess().getRule();
	}
	
	///** A TransportChannel is a placeholder for an integrator supplied configuration between transport endpoints. */
	//IntegrationTransportChannel:
	//    'itc' name=ID description=STRING ';'
	//;
	public IntegrationTransportChannelElements getIntegrationTransportChannelAccess() {
		return pIntegrationTransportChannel;
	}
	
	public ParserRule getIntegrationTransportChannelRule() {
		return getIntegrationTransportChannelAccess().getRule();
	}
	
	////// Starter rule comes first
	////ModelFile:
	////    includes+=Include*
	////    dataModel=DataModel
	////;
	///** A DataModel is a container for ConceptualDataModels, LogicalDataModels, and PlatformDataModels */
	//DataModel:
	//    'dm' name=ID (description=STRING)? '{'
	//        (cdm+=ConceptualDataModel |
	//        ldm+=LogicalDataModel |
	//        pdm+=PlatformDataModel)*
	//    '}'
	//    ;
	public UddlGrammarAccess.DataModelElements getDataModelAccess() {
		return gaUddl.getDataModelAccess();
	}
	
	public ParserRule getDataModelRule() {
		return getDataModelAccess().getRule();
	}
	
	//// A few generic rules
	//terminal fragment DEC:  ('0'..'9')+;
	public TerminalRule getDECRule() {
		return gaUddl.getDECRule();
	}
	
	//// TODO: This needs code to process the +|- when creating int or float?
	///** INT override causing ambiguity with XBase */
	//@Override
	//terminal INT returns ecore::EInt:  ('+'|'-')? DEC;
	public TerminalRule getINTRule() {
		return gaUddl.getINTRule();
	}
	
	////LONG returns ecore::ELong: INT ("L"|"l");
	//terminal FLOAT returns ecore::EFloat : ('+'|'-')? DEC '.' DEC;
	public TerminalRule getFLOATRule() {
		return gaUddl.getFLOATRule();
	}
	
	////DOUBLE returns ecore::EDouble : INT '.' INT ('D'|'d');
	//QN:
	//    ID ('.' ID)*;
	public UddlGrammarAccess.QNElements getQNAccess() {
		return gaUddl.getQNAccess();
	}
	
	public ParserRule getQNRule() {
		return getQNAccess().getRule();
	}
	
	///**
	// * Use 'include' because 'import' is an XBase keyword
	// */
	//Include:
	//    'include' importedNamespace=QualifiedNameWithWildcard;
	public UddlGrammarAccess.IncludeElements getIncludeAccess() {
		return gaUddl.getIncludeAccess();
	}
	
	public ParserRule getIncludeRule() {
		return getIncludeAccess().getRule();
	}
	
	///**
	// * Already defined in XBase
	// */
	//QualifiedNameWithWildcard:
	//    QN '.*'?;
	public UddlGrammarAccess.QualifiedNameWithWildcardElements getQualifiedNameWithWildcardAccess() {
		return gaUddl.getQualifiedNameWithWildcardAccess();
	}
	
	public ParserRule getQualifiedNameWithWildcardRule() {
		return getQualifiedNameWithWildcardAccess().getRule();
	}
	
	// // Metamodel concepts starts here
	///** An Element is the root type for defining all named elements in the DataModel. The “name” attribute captures the name of the Element in the model. The “description” attribute captures a description for the Element. */
	//UddlElement:  // This is datamodel.Element but it's too much hassle to fix after the fact.
	//    DataModel |
	//    ConceptualDataModel | LogicalDataModel | PlatformDataModel|
	//    ConceptualElement|
	//    LogicalElement |
	//    PlatformElement |
	//    LogicalReferencePoint |
	//    LogicalEnumerationLabel |
	//    LogicalConstraint
	//;
	public UddlGrammarAccess.UddlElementElements getUddlElementAccess() {
		return gaUddl.getUddlElementAccess();
	}
	
	public ParserRule getUddlElementRule() {
		return getUddlElementAccess().getRule();
	}
	
	///** A ConceptualDataModel is a container for CDM Elements. */
	//ConceptualDataModel:
	//    'cdm'    name=ID (description=STRING)? '{'
	//        (element+=ConceptualElement | cdm+=ConceptualDataModel)*
	//    '}'
	//;
	public UddlGrammarAccess.ConceptualDataModelElements getConceptualDataModelAccess() {
		return gaUddl.getConceptualDataModelAccess();
	}
	
	public ParserRule getConceptualDataModelRule() {
		return getConceptualDataModelAccess().getRule();
	}
	
	///** A LogicalDataModel is a container for LDM Elements. */
	//LogicalDataModel:
	//    'ldm'    name=ID (description=STRING)? '{'
	//        (element+=LogicalElement | ldm+=LogicalDataModel)*
	//    '}'
	//;
	public UddlGrammarAccess.LogicalDataModelElements getLogicalDataModelAccess() {
		return gaUddl.getLogicalDataModelAccess();
	}
	
	public ParserRule getLogicalDataModelRule() {
		return getLogicalDataModelAccess().getRule();
	}
	
	///** A PlatformDataModel is a container for platform Data Model elements. */
	//PlatformDataModel:
	//    'pdm'    name=ID (description=STRING)? '{'
	//        (element+=PlatformElement | pdm+=PlatformDataModel)*
	//    '}'
	//;
	public UddlGrammarAccess.PlatformDataModelElements getPlatformDataModelAccess() {
		return gaUddl.getPlatformDataModelAccess();
	}
	
	public ParserRule getPlatformDataModelRule() {
		return getPlatformDataModelAccess().getRule();
	}
	
	///** A conceptual Element is the root type for defining the conceptual elements of a Data Model. */
	//ConceptualElement:
	//    ConceptualDomain |
	//    ConceptualBasisEntity |
	//    ConceptualComposableElement |
	//    ConceptualView
	//;
	public UddlGrammarAccess.ConceptualElementElements getConceptualElementAccess() {
		return gaUddl.getConceptualElementAccess();
	}
	
	public ParserRule getConceptualElementRule() {
		return getConceptualElementAccess().getRule();
	}
	
	///** A conceptual ComposableElement is a conceptual Element that is allowed to participate in a Composition relationship. In other words, these are the conceptual Elements that may be a characteristic of a conceptual Entity. */
	//ConceptualComposableElement:
	//    ConceptualEntity |
	//    ConceptualObservable
	//;
	public UddlGrammarAccess.ConceptualComposableElementElements getConceptualComposableElementAccess() {
		return gaUddl.getConceptualComposableElementAccess();
	}
	
	public ParserRule getConceptualComposableElementRule() {
		return getConceptualComposableElementAccess().getRule();
	}
	
	////NOTE: BasisElement has single inheritance - it has no independent functionality so it gets dropped
	//// A conceptual BasisElement is a conceptual data type that is independent of any specific data representation.
	///** A BasisEntity represents a unique domain concept and establishes a basis which can be used by conceptual Entities.  */
	//ConceptualBasisEntity:
	//    'basis' name=ID (description=STRING)? ';'
	//;
	public UddlGrammarAccess.ConceptualBasisEntityElements getConceptualBasisEntityAccess() {
		return gaUddl.getConceptualBasisEntityAccess();
	}
	
	public ParserRule getConceptualBasisEntityRule() {
		return getConceptualBasisEntityAccess().getRule();
	}
	
	///** A Domain represents a space defined by a set of BasisEntities relating to well understood concepts by practitioners within a particular domain.  */
	//ConceptualDomain:
	//    'domain' name=ID (description=STRING)? ';'
	//;
	public UddlGrammarAccess.ConceptualDomainElements getConceptualDomainAccess() {
		return gaUddl.getConceptualDomainAccess();
	}
	
	public ParserRule getConceptualDomainRule() {
		return getConceptualDomainAccess().getRule();
	}
	
	///** An Observable is something that can be observed but not further characterized, and is typically quantified through measurements of the physical world. An observable is independent of any specific data representation, units, or reference frame. For example, “length” may be thought of as an observable in that it can be measured, but at the conceptual level the nature of the measurement is not specified. */
	//ConceptualObservable:
	//    'observable' name=ID (description=STRING)? ';'
	//;
	public UddlGrammarAccess.ConceptualObservableElements getConceptualObservableAccess() {
		return gaUddl.getConceptualObservableAccess();
	}
	
	public ParserRule getConceptualObservableRule() {
		return getConceptualObservableAccess().getRule();
	}
	
	///** Either a ConceptualComposition or a ConceptualParticipant.
	// * A conceptual Characteristic contributes to the uniqueness of a conceptual Entity. The “rolename” attribute defines the name of the conceptual Characteristic within the scope of the conceptual Entity. The “lowerBound” and “upperBound” attributes define the multiplicity of the composed Characteristic. An “upperBound” multiplicity of –1 represents an unbounded sequence. */
	//ConceptualCharacteristic:
	//    ConceptualComposition |
	//    ConceptualParticipant
	//;
	public UddlGrammarAccess.ConceptualCharacteristicElements getConceptualCharacteristicAccess() {
		return gaUddl.getConceptualCharacteristicAccess();
	}
	
	public ParserRule getConceptualCharacteristicRule() {
		return getConceptualCharacteristicAccess().getRule();
	}
	
	///** A conceptual Entity represents a domain concept in terms of its Observables and other composed conceptual Entities. Since a conceptual Entity is built only from conceptual ComposableElements, it is independent of any specific data representation, units, or reference frame. */
	//ConceptualEntity:
	//    ConceptualAssociation |
	//    'centity' name=ID (description=STRING)? (':' specializes=[ConceptualEntity|QN])? '{'
	//        composition+=ConceptualComposition*
	//        ('basis:' '[' basisEntity+=[ConceptualBasisEntity|QN]+ ']')?
	//    '};'
	//;
	public UddlGrammarAccess.ConceptualEntityElements getConceptualEntityAccess() {
		return gaUddl.getConceptualEntityAccess();
	}
	
	public ParserRule getConceptualEntityRule() {
		return getConceptualEntityAccess().getRule();
	}
	
	///** A conceptual Composition is the mechanism that allows conceptual Entities to be constructed from other conceptual ComposableElements. The “type” of a Composition is the ComposableElement being used to construct the conceptual Entity. */
	//ConceptualComposition:
	//    type=[ConceptualComposableElement|QN]  rolename=ID ('[' (lowerBound=INT)? ':' (upperBound=INT)? ']')? (description=STRING)? (':' specializes=[ConceptualCharacteristic|QN])? ';'
	//;
	public UddlGrammarAccess.ConceptualCompositionElements getConceptualCompositionAccess() {
		return gaUddl.getConceptualCompositionAccess();
	}
	
	public ParserRule getConceptualCompositionRule() {
		return getConceptualCompositionAccess().getRule();
	}
	
	///** A conceptual Association represents a relationship between two or more conceptual Entities. The conceptual Entities participating in the conceptual Association may be specified locally or in its generalized types. In addition, there may be one or more conceptual ComposableElements that characterize the relationship. Conceptual Associations are conceptual Entities that may also participate in other conceptual Associations. */
	//ConceptualAssociation:
	//        'cassoc' name=ID (description=STRING)? (':' specializes=[ConceptualEntity|QN])? '{'
	//        composition+=ConceptualComposition*
	//        ('basis:' '[' ConceptualBasisEntity+=[ConceptualBasisEntity|QN]+ ']')?
	//        ('participants:' '[' participant+=ConceptualParticipant+ ']')?
	//    '};'
	//;
	public UddlGrammarAccess.ConceptualAssociationElements getConceptualAssociationAccess() {
		return gaUddl.getConceptualAssociationAccess();
	}
	
	public ParserRule getConceptualAssociationRule() {
		return getConceptualAssociationAccess().getRule();
	}
	
	///** A conceptual Participant is the mechanism that allows a conceptual Association to be constructed between two or more conceptual Entities. The “type” of a conceptual Participant is the conceptual Entity being used to construct the conceptual Association. The “sourceLowerBound” and “sourceUpperBound” attributes define the multiplicity of the conceptual Association relative to the Participant. A “sourceUpperBound” multiplicity of –1 represents an unbounded sequence. The “path” attribute of the Participant describes the chain of entity characteristics to traverse to reach the subject of the association beginning with the entity referenced by the “type” attribute.  */
	//ConceptualParticipant:
	//    type=[ConceptualEntity|QN]  rolename=ID ('[' (lowerBound=INT)? ':' (upperBound=INT)? ']')? (description=STRING)? (':' specializes=[ConceptualCharacteristic|QN])?
	//        '{'
	//            'src:' '['sourceLowerBound=INT ':' sourceUpperBound=INT ']'
	//            ('path:' path=ConceptualPathNode)?
	//        '}'
	//        ';'
	//;
	public UddlGrammarAccess.ConceptualParticipantElements getConceptualParticipantAccess() {
		return gaUddl.getConceptualParticipantAccess();
	}
	
	public ParserRule getConceptualParticipantRule() {
		return getConceptualParticipantAccess().getRule();
	}
	
	///** Either a ConceptualParticipantPathNode or a ConceptualCharacteristicPathNode.
	// * A conceptual PathNode is a single element in a chain that collectively forms a path specification. */
	//ConceptualPathNode:
	//    ConceptualParticipantPathNode |
	//    ConceptualCharacteristicPathNode
	//;
	public UddlGrammarAccess.ConceptualPathNodeElements getConceptualPathNodeAccess() {
		return gaUddl.getConceptualPathNodeAccess();
	}
	
	public ParserRule getConceptualPathNodeRule() {
		return getConceptualPathNodeAccess().getRule();
	}
	
	//// NOTE: There is something I did to set up the path resolution here that made things very succinct. I think it had to do
	//// with the NameProvider?
	///** A conceptual ParticipantPathNode is a conceptual PathNode that selects a Participant that references an Entity. This provides a mechanism for reverse navigation from an Entity that participates in an Association back to the Association. */
	//ConceptualParticipantPathNode:
	//    '/' projectedParticipant=[ConceptualParticipant|QN]
	//    ( node=ConceptualPathNode )?
	//;
	public UddlGrammarAccess.ConceptualParticipantPathNodeElements getConceptualParticipantPathNodeAccess() {
		return gaUddl.getConceptualParticipantPathNodeAccess();
	}
	
	public ParserRule getConceptualParticipantPathNodeRule() {
		return getConceptualParticipantPathNodeAccess().getRule();
	}
	
	///** A conceptual CharacteristicPathNode is a conceptual PathNode that selects a conceptual Characteristic which is directly contained in a conceptual Entity or Association. */
	//ConceptualCharacteristicPathNode:
	//    '#' projectedCharacteristic=[ConceptualCharacteristic|QN]
	//    ( node=ConceptualPathNode )?
	//;
	public UddlGrammarAccess.ConceptualCharacteristicPathNodeElements getConceptualCharacteristicPathNodeAccess() {
		return gaUddl.getConceptualCharacteristicPathNodeAccess();
	}
	
	public ParserRule getConceptualCharacteristicPathNodeRule() {
		return getConceptualCharacteristicPathNodeAccess().getRule();
	}
	
	///** Either a ConceptualQuery or a ConceptualCompositeQuery.
	// * A conceptual View is a conceptual Query or a conceptual CompositeQuery. */
	//ConceptualView:
	//    ConceptualQuery |
	//    ConceptualCompositeQuery
	//;
	public UddlGrammarAccess.ConceptualViewElements getConceptualViewAccess() {
		return gaUddl.getConceptualViewAccess();
	}
	
	public ParserRule getConceptualViewRule() {
		return getConceptualViewAccess().getRule();
	}
	
	///** A conceptual Query is a specification that defines the content of conceptual View as a set of conceptual Characteristics projected from a selected set of related conceptual Entities. The “specification” attribute captures the specification of a Query as defined by the Query grammar.  */
	//ConceptualQuery:
	//    'cquery' name=ID (description=STRING)? '{'
	//        'spec:' specification=STRING
	//    '};'
	//;
	public UddlGrammarAccess.ConceptualQueryElements getConceptualQueryAccess() {
		return gaUddl.getConceptualQueryAccess();
	}
	
	public ParserRule getConceptualQueryRule() {
		return getConceptualQueryAccess().getRule();
	}
	
	///** A conceptual CompositeQuery is a collection of two or more conceptual Views. The “isUnion” attribute specifies whether the composed Views are intended to be mutually exclusive or not. */
	//ConceptualCompositeQuery:
	//    'ccquery' name=ID (description=STRING)? '{'
	//        isUnion?='isUnion'
	//        composition+=ConceptualQueryComposition
	//        (composition+=ConceptualQueryComposition)+
	//    '};'
	//;
	public UddlGrammarAccess.ConceptualCompositeQueryElements getConceptualCompositeQueryAccess() {
		return gaUddl.getConceptualCompositeQueryAccess();
	}
	
	public ParserRule getConceptualCompositeQueryRule() {
		return getConceptualCompositeQueryAccess().getRule();
	}
	
	///** A conceptual QueryComposition is the mechanism that allows a conceptual CompositeQuery to be constructed from conceptual Queries and other conceptual CompositeQueries. The “rolename” attribute defines the name of the composed conceptual View within the scope of the composing conceptual CompositeQuery. The “type” of a conceptual QueryComposition is the conceptual View being used to construct the conceptual CompositeQuery. */
	//ConceptualQueryComposition:
	//    type=[ConceptualView|QN] rolename=ID ';'
	//;
	public UddlGrammarAccess.ConceptualQueryCompositionElements getConceptualQueryCompositionAccess() {
		return gaUddl.getConceptualQueryCompositionAccess();
	}
	
	public ParserRule getConceptualQueryCompositionRule() {
		return getConceptualQueryCompositionAccess().getRule();
	}
	
	///** A logical Element is the root type for defining the logical elements of a Data Model. */
	//LogicalElement:
	//    LogicalComposableElement |
	//    LogicalConversion | // LogicalConversion has a single inheritance of LogicalAffineConversion - so that is promoted to here
	//    LogicalUnit | //LogicalConvertibleElement | // LogicalConvertibleElement has a single inheritance of LogicalUnit - promote that to here
	//    LogicalCoordinateSystem |
	//    LogicalCoordinateSystemAxis |
	//    LogicalMeasurementConversion |
	//    LogicalMeasurementSystemConversion |
	//    LogicalMeasurementAxis | // Also derived from AbstractMeasurement
	//    LogicalAbstractMeasurementSystem| //LogicalMeasurementSystem |
	//    LogicalMeasurementSystemAxis |
	//    LogicalValueType | // Also derived from AbstractMeasurement
	//    LogicalView |
	//    LogicalLandmark |
	//    LogicalValueTypeUnit
	//;
	public UddlGrammarAccess.LogicalElementElements getLogicalElementAccess() {
		return gaUddl.getLogicalElementAccess();
	}
	
	public ParserRule getLogicalElementRule() {
		return getLogicalElementAccess().getRule();
	}
	
	//// NOTE: LogicalConvertibleElement has LogicalUnit as a single inheritance. Since it has nothing else, promote LogicalUnit directly
	//// to LogicalElement
	///** A ConvertibleElement is a Unit. */
	///** A Unit is a defined magnitude of quantity used as a standard for measurement.  */
	//LogicalUnit:
	//    'lunit' name=ID (description=STRING)? ';'
	//;
	public UddlGrammarAccess.LogicalUnitElements getLogicalUnitAccess() {
		return gaUddl.getLogicalUnitAccess();
	}
	
	public ParserRule getLogicalUnitRule() {
		return getLogicalUnitAccess().getRule();
	}
	
	//// NOTE: LogicalConversion has LogicalAffineConversion as a single inheritance. Since it has nothing else, promote LogicalAffineConversion directly
	//// to LogicalElement
	///** A Conversion is a relationship between two ConvertibleElements that describes how to transform measured quantities between two Units. */
	//LogicalConversion:
	//    'conv' name=ID  (description=STRING)? '{'
	//        source=[LogicalAssociation|QN] '-()>'  destination=[LogicalAssociation|QN]
	//        '};' |
	//    LogicalAffineConversion
	//;
	public UddlGrammarAccess.LogicalConversionElements getLogicalConversionAccess() {
		return gaUddl.getLogicalConversionAccess();
	}
	
	public ParserRule getLogicalConversionRule() {
		return getLogicalConversionAccess().getRule();
	}
	
	///** An AffineConversion is a relationship between two ConvertibleElements in the form mx+b. */
	//LogicalAffineConversion:
	//    'aconv' name=ID  (description=STRING)? '{'
	//        source=[LogicalAssociation|QN] '-(' 'm:' conversionFactor=FLOAT 'b:' offset=FLOAT ')->'  destination=[LogicalAssociation|QN]
	//    '};'
	//;
	public UddlGrammarAccess.LogicalAffineConversionElements getLogicalAffineConversionAccess() {
		return gaUddl.getLogicalAffineConversionAccess();
	}
	
	public ParserRule getLogicalAffineConversionRule() {
		return getLogicalAffineConversionAccess().getRule();
	}
	
	///** A ValueType specifies the logical representation of a MeasurementSystem or Measurement. Integer, Real, and String are examples of logical ValueTypes. */
	//LogicalValueType:
	//    LogicalBoolean |
	//    LogicalNumeric |
	//    LogicalCharacter |
	//    LogicalString |
	//    LogicalEnumeratedBase // EXTENSION
	//;
	public UddlGrammarAccess.LogicalValueTypeElements getLogicalValueTypeAccess() {
		return gaUddl.getLogicalValueTypeAccess();
	}
	
	public ParserRule getLogicalValueTypeRule() {
		return getLogicalValueTypeAccess().getRule();
	}
	
	///** A String is a value type that represents a variable length sequence of characters. */
	//LogicalString:                     'str'     name=ID (description=STRING)? ';'     ;
	public UddlGrammarAccess.LogicalStringElements getLogicalStringAccess() {
		return gaUddl.getLogicalStringAccess();
	}
	
	public ParserRule getLogicalStringRule() {
		return getLogicalStringAccess().getRule();
	}
	
	///** A Character is a value type representing characters from any character set. */
	//LogicalCharacter:                 'ch'     name=ID (description=STRING)? ';'    ;
	public UddlGrammarAccess.LogicalCharacterElements getLogicalCharacterAccess() {
		return gaUddl.getLogicalCharacterAccess();
	}
	
	public ParserRule getLogicalCharacterRule() {
		return getLogicalCharacterAccess().getRule();
	}
	
	///** A Boolean is a value type representing the two values TRUE and FALSE. */
	//LogicalBoolean:                    'bool'     name=ID (description=STRING)? ';'    ;
	public UddlGrammarAccess.LogicalBooleanElements getLogicalBooleanAccess() {
		return gaUddl.getLogicalBooleanAccess();
	}
	
	public ParserRule getLogicalBooleanRule() {
		return getLogicalBooleanAccess().getRule();
	}
	
	///** A Numeric is a numeric ValueType. */
	//LogicalNumeric:
	//    LogicalInteger |
	//    LogicalNatural |
	//    LogicalReal |
	//    LogicalNonNegativeReal
	//;
	public UddlGrammarAccess.LogicalNumericElements getLogicalNumericAccess() {
		return gaUddl.getLogicalNumericAccess();
	}
	
	public ParserRule getLogicalNumericRule() {
		return getLogicalNumericAccess().getRule();
	}
	
	///** An Integer is a value type representing integer numbers. */
	//LogicalInteger:                    'int'     name=ID (description=STRING)? ';'    ;
	public UddlGrammarAccess.LogicalIntegerElements getLogicalIntegerAccess() {
		return gaUddl.getLogicalIntegerAccess();
	}
	
	public ParserRule getLogicalIntegerRule() {
		return getLogicalIntegerAccess().getRule();
	}
	
	///** A Natural is a value type representing the non-negative integers. */
	//LogicalNatural:                    'nat'     name=ID (description=STRING)? ';'    ;
	public UddlGrammarAccess.LogicalNaturalElements getLogicalNaturalAccess() {
		return gaUddl.getLogicalNaturalAccess();
	}
	
	public ParserRule getLogicalNaturalRule() {
		return getLogicalNaturalAccess().getRule();
	}
	
	///** A Real is a value type representing real numbers. */
	//LogicalReal:                    'real'     name=ID (description=STRING)? ';'    ;
	public UddlGrammarAccess.LogicalRealElements getLogicalRealAccess() {
		return gaUddl.getLogicalRealAccess();
	}
	
	public ParserRule getLogicalRealRule() {
		return getLogicalRealAccess().getRule();
	}
	
	///** A NonNegativeReal is a value type representing non-negative real numbers. */
	//LogicalNonNegativeReal:            'real+' name=ID (description=STRING)? ';'    ;
	public UddlGrammarAccess.LogicalNonNegativeRealElements getLogicalNonNegativeRealAccess() {
		return gaUddl.getLogicalNonNegativeRealAccess();
	}
	
	public ParserRule getLogicalNonNegativeRealRule() {
		return getLogicalNonNegativeRealAccess().getRule();
	}
	
	///** An Enumerated is a value type representing a set of named values, each with specific meaning. */
	//LogicalEnumerated:
	//    'enum'     name=ID (description=STRING)?
	//        ('stdRef:' standardReference=STRING)?
	//        '['
	//        label+=(LogicalEnumerationLabel | LogicalEnumeratedSet) ','? (label+=(LogicalEnumerationLabel| LogicalEnumeratedSet) ','?)*
	//        ']'
	//        ';'
	//        ;
	public UddlGrammarAccess.LogicalEnumeratedElements getLogicalEnumeratedAccess() {
		return gaUddl.getLogicalEnumeratedAccess();
	}
	
	public ParserRule getLogicalEnumeratedRule() {
		return getLogicalEnumeratedAccess().getRule();
	}
	
	///**EXTENSION: The foundation for every taxonomic type hierarchy. Override and extend as needed */
	//Taxonomy:
	//    LogicalEnumeratedBase
	//;
	public UddlGrammarAccess.TaxonomyElements getTaxonomyAccess() {
		return gaUddl.getTaxonomyAccess();
	}
	
	public ParserRule getTaxonomyRule() {
		return getTaxonomyAccess().getRule();
	}
	
	///**EXTENSION: Creates the foundation for a hierarchy of enumerated values  */
	//LogicalEnumeratedBase:
	//    LogicalEnumeratedSet |
	//    LogicalEnumerationLabel |
	//    LogicalEnumerated
	//;
	public UddlGrammarAccess.LogicalEnumeratedBaseElements getLogicalEnumeratedBaseAccess() {
		return gaUddl.getLogicalEnumeratedBaseAccess();
	}
	
	public ParserRule getLogicalEnumeratedBaseRule() {
		return getLogicalEnumeratedBaseAccess().getRule();
	}
	
	///**EXTENSION: allowing label to be a LogicalEnumeratedSet enables taxonomy definitions via enumerations  */
	//LogicalEnumeratedSet:
	//        '(' name=ID (description=STRING)?
	//        '['
	//        label+=(LogicalEnumerationLabel | LogicalEnumeratedSet) ','? (label+=(LogicalEnumerationLabel| LogicalEnumeratedSet) ','?)*
	//        ']' ')'
	//        ;
	public UddlGrammarAccess.LogicalEnumeratedSetElements getLogicalEnumeratedSetAccess() {
		return gaUddl.getLogicalEnumeratedSetAccess();
	}
	
	public ParserRule getLogicalEnumeratedSetRule() {
		return getLogicalEnumeratedSetAccess().getRule();
	}
	
	///** An EnumerationLabel defines a named member of an Enumerated value set. */
	//LogicalEnumerationLabel:    name=ID |    '(' name=ID description=STRING ')' ;
	public UddlGrammarAccess.LogicalEnumerationLabelElements getLogicalEnumerationLabelAccess() {
		return gaUddl.getLogicalEnumerationLabelAccess();
	}
	
	public ParserRule getLogicalEnumerationLabelRule() {
		return getLogicalEnumerationLabelAccess().getRule();
	}
	
	///** A CoordinateSystem is a system which uses one or more coordinates to uniquely determine the position of a point in an N-dimensional space. The coordinate system is comprised of multiple CoordinateSystemAxis which completely span the space. Coordinates are quantified relative to the CoordinateSystemAxis. It is not required that the dimensions be ordered or continuous. */
	//LogicalCoordinateSystem:
	//    'coord' name=ID (description=STRING)? '{'
	//        ('axis:'         axisRelationshipDescription=STRING)?
	//        ('angleEq:'     angleEquation=STRING)?
	//        ('distanceEq:'     distanceEquation=STRING)?
	//        '['axis+=[LogicalCoordinateSystemAxis|QN]+ ']'
	//    '};'
	//;
	public UddlGrammarAccess.LogicalCoordinateSystemElements getLogicalCoordinateSystemAccess() {
		return gaUddl.getLogicalCoordinateSystemAccess();
	}
	
	public ParserRule getLogicalCoordinateSystemRule() {
		return getLogicalCoordinateSystemAccess().getRule();
	}
	
	///** A CoordinateSystemAxis represents a dimension within a CoordinateSystem. */
	//LogicalCoordinateSystemAxis:
	//    'csa' name=ID (description=STRING)? ';'
	//;
	public UddlGrammarAccess.LogicalCoordinateSystemAxisElements getLogicalCoordinateSystemAxisAccess() {
		return gaUddl.getLogicalCoordinateSystemAxisAccess();
	}
	
	public ParserRule getLogicalCoordinateSystemAxisRule() {
		return getLogicalCoordinateSystemAxisAccess().getRule();
	}
	
	///** An AbstractMeasurementSystem is an abstract parent for StandardMeasurementSystems and MeasurementSystems. It is used for structural simplicity in the metamodel.  */
	//LogicalAbstractMeasurementSystem:
	//    LogicalStandardMeasurementSystem |
	//    LogicalMeasurementSystem
	//;
	public UddlGrammarAccess.LogicalAbstractMeasurementSystemElements getLogicalAbstractMeasurementSystemAccess() {
		return gaUddl.getLogicalAbstractMeasurementSystemAccess();
	}
	
	public ParserRule getLogicalAbstractMeasurementSystemRule() {
		return getLogicalAbstractMeasurementSystemAccess().getRule();
	}
	
	///** A StandardMeasurementSystem is used to represent an open, referenced measurement system without requiring the detailed modeling of the measurement system. The reference should be unambiguous and allows for full comprehension of the underlying measurement system. */
	//LogicalStandardMeasurementSystem:
	//    'smsys' name=ID (description=STRING)? '{'
	//        'refStd:' referenceStandard=STRING
	//    '};'
	//;
	public UddlGrammarAccess.LogicalStandardMeasurementSystemElements getLogicalStandardMeasurementSystemAccess() {
		return gaUddl.getLogicalStandardMeasurementSystemAccess();
	}
	
	public ParserRule getLogicalStandardMeasurementSystemRule() {
		return getLogicalStandardMeasurementSystemAccess().getRule();
	}
	
	///** A Landmark is a named, recognizable or artificial feature used to locate a ReferencePoint in a measurable space. */
	//LogicalLandmark:
	//    'landmark' name=ID (description=STRING)? ';'
	//;
	public UddlGrammarAccess.LogicalLandmarkElements getLogicalLandmarkAccess() {
		return gaUddl.getLogicalLandmarkAccess();
	}
	
	public ParserRule getLogicalLandmarkRule() {
		return getLogicalLandmarkAccess().getRule();
	}
	
	///** A MeasurementSystem relates a CoordinateSystem to an origin and orientation for the purpose of establishing a common basis for describing points in an N-dimensional space. Defining a MeasurementSystem establishes additional properties of the CoordinateSystem including units and value types for each axis, and a set of reference points that can be used to establish an origin and indicate the direction of each axis. */
	//LogicalMeasurementSystem:
	//    'msys' name=ID (description=STRING)? '{'
	//        'maxis:' '[' measurementSystemAxis+=[LogicalMeasurementSystemAxis|QN]+ ']'
	//        'coord:' coordinateSystem=[LogicalCoordinateSystem|QN]
	//        ('extRefStd:' externalStandardReference=STRING)?
	//        ('orient:' orientation=STRING)?
	//        ('refPt:' '[' referencePoint+=LogicalReferencePoint+ ']')?
	//        ('![' constraint+=LogicalMeasurementConstraint+ ']')?
	//    '};'
	//;
	public UddlGrammarAccess.LogicalMeasurementSystemElements getLogicalMeasurementSystemAccess() {
		return gaUddl.getLogicalMeasurementSystemAccess();
	}
	
	public ParserRule getLogicalMeasurementSystemRule() {
		return getLogicalMeasurementSystemAccess().getRule();
	}
	
	///** A MeasurementSystemAxis establishes additional properties for a CoordinateSystemAxis including units and value types. */
	//LogicalMeasurementSystemAxis:
	//    'msa' name=ID (description=STRING)? '{'
	//        'axis:' axis=[LogicalCoordinateSystemAxis|QN]
	//        'vtu:' '[' defaultValueTypeUnit+=[LogicalValueTypeUnit|QN]+ ']'
	//        ('![' constraint+=LogicalMeasurementConstraint+ ']'    )?
	//    '};'
	//;
	public UddlGrammarAccess.LogicalMeasurementSystemAxisElements getLogicalMeasurementSystemAxisAccess() {
		return gaUddl.getLogicalMeasurementSystemAxisAccess();
	}
	
	public ParserRule getLogicalMeasurementSystemAxisRule() {
		return getLogicalMeasurementSystemAxisAccess().getRule();
	}
	
	///** A ReferencePoint is an identifiable point (landmark) that can be used to provide a basis for locating and/or orienting a MeasurementSystem. */
	//LogicalReferencePoint:
	//    '(' name=ID (description=STRING)?
	//        'landmark:' landmark=[LogicalLandmark|QN]
	//        '[' referencePointPart+=LogicalReferencePointPart+ ']'
	//    ')'
	//;
	public UddlGrammarAccess.LogicalReferencePointElements getLogicalReferencePointAccess() {
		return gaUddl.getLogicalReferencePointAccess();
	}
	
	public ParserRule getLogicalReferencePointRule() {
		return getLogicalReferencePointAccess().getRule();
	}
	
	///** A ReferencePointPart is a value for one ValueTypeUnit in a ValueTypeUnit set that is used to identify a specific point along an axis.  */
	//LogicalReferencePointPart:
	//    '(' (axis=[LogicalMeasurementSystemAxis|QN])?  value=STRING  (valueTypeUnit=[LogicalValueTypeUnit|QN])? ')'
	//;
	public UddlGrammarAccess.LogicalReferencePointPartElements getLogicalReferencePointPartAccess() {
		return gaUddl.getLogicalReferencePointPartAccess();
	}
	
	public ParserRule getLogicalReferencePointPartRule() {
		return getLogicalReferencePointPartAccess().getRule();
	}
	
	///** A ValueTypeUnit defines the logical representation of a MeasurementSystemAxis or MeasurementAxis value type in terms of a Unit and ValueType pair. */
	//LogicalValueTypeUnit:
	//    'vtu' valueType=[LogicalValueType|QN] unit=[LogicalUnit|QN] name=ID (description=STRING)?
	//    ('{' '!' constraint=LogicalConstraint '}')?
	//     ';'
	//;
	public UddlGrammarAccess.LogicalValueTypeUnitElements getLogicalValueTypeUnitAccess() {
		return gaUddl.getLogicalValueTypeUnitAccess();
	}
	
	public ParserRule getLogicalValueTypeUnitRule() {
		return getLogicalValueTypeUnitAccess().getRule();
	}
	
	///** A Constraint limits the set of possible values for the ValueType of a MeasurementSystem or Measurement. */
	//LogicalConstraint:
	//    LogicalStringConstraint |
	//    LogicalRealRangeConstraint | //LogicalRealConstraint | //LogicalRealConstraint has a single inheritance of LogicalRealRangeConstraint - promote that to here
	//    LogicalIntegerRangeConstraint | //LogicalIntegerConstraint | //LogicalIntegerConstraint has single inheritance of LogicalIntegerRangeConstraint
	//    LogicalEnumerationConstraint
	//;
	public UddlGrammarAccess.LogicalConstraintElements getLogicalConstraintAccess() {
		return gaUddl.getLogicalConstraintAccess();
	}
	
	public ParserRule getLogicalConstraintRule() {
		return getLogicalConstraintAccess().getRule();
	}
	
	///** An IntegerConstraint specifies a defined set of meaningful values for an Integer or Natural. */
	////LogicalIntegerConstraint:
	////    LogicalIntegerRangeConstraint
	////;
	///** An IntegerRangeConstraint specifies a defined range of meaningful values for an Integer or Natural. The “upperBound” is greater than or equal to the “lowerBound”. The defined range is inclusive of the “upperBound” and “lowerBound”. */
	//LogicalIntegerRangeConstraint:
	//    'irc'  name=ID '[' lowerBound=INT ':' upperBound=INT ']' (description=STRING)?  ';'
	//;
	public UddlGrammarAccess.LogicalIntegerRangeConstraintElements getLogicalIntegerRangeConstraintAccess() {
		return gaUddl.getLogicalIntegerRangeConstraintAccess();
	}
	
	public ParserRule getLogicalIntegerRangeConstraintRule() {
		return getLogicalIntegerRangeConstraintAccess().getRule();
	}
	
	///** A RealConstraint specifies a defined set of meaningful values for a Real or NonNegativeReal. */
	////LogicalRealConstraint:
	////    LogicalRealRangeConstraint
	////;
	//// TODO: There is a way to default this to handle the include exclude bounds - is this it?
	///** A RealRangeConstraint specifies a defined range of meaningful values for a Real or NonNegativeReal. The “upperBound” is greater than or equal to the “lowerBound”. */
	//LogicalRealRangeConstraint:
	//    'rrc' name=ID ( '(' | lowerBoundInclusive?='[') lowerBound=FLOAT ':' upperBound=FLOAT (')'| upperBoundInclusive?=']') (description=STRING)?  ';'
	//;
	public UddlGrammarAccess.LogicalRealRangeConstraintElements getLogicalRealRangeConstraintAccess() {
		return gaUddl.getLogicalRealRangeConstraintAccess();
	}
	
	public ParserRule getLogicalRealRangeConstraintRule() {
		return getLogicalRealRangeConstraintAccess().getRule();
	}
	
	///** A StringConstraint specifies a defined set of meaningful values for a String */
	//LogicalStringConstraint:
	//    LogicalRegularExpressionConstraint |
	//    LogicalFixedLengthStringConstraint
	//;
	public UddlGrammarAccess.LogicalStringConstraintElements getLogicalStringConstraintAccess() {
		return gaUddl.getLogicalStringConstraintAccess();
	}
	
	public ParserRule getLogicalStringConstraintRule() {
		return getLogicalStringConstraintAccess().getRule();
	}
	
	///** A RegularExpressionConstraint specifies a defined set of meaningful values for a String in the form of a regular expression. */
	//LogicalRegularExpressionConstraint:
	//    'rec' name=ID '[' expression=STRING ']'(description=STRING)? ';'
	//;
	public UddlGrammarAccess.LogicalRegularExpressionConstraintElements getLogicalRegularExpressionConstraintAccess() {
		return gaUddl.getLogicalRegularExpressionConstraintAccess();
	}
	
	public ParserRule getLogicalRegularExpressionConstraintRule() {
		return getLogicalRegularExpressionConstraintAccess().getRule();
	}
	
	///** A FixedLengthStringConstraint specifies a defined set of meaningful values for a String of a specific fixed length. The “length” attribute defines the fixed length, an integer value greater than 0. */
	//LogicalFixedLengthStringConstraint:
	//    'flsc' name=ID '[' length=INT ']' (description=STRING)? ';'
	//;
	public UddlGrammarAccess.LogicalFixedLengthStringConstraintElements getLogicalFixedLengthStringConstraintAccess() {
		return gaUddl.getLogicalFixedLengthStringConstraintAccess();
	}
	
	public ParserRule getLogicalFixedLengthStringConstraintRule() {
		return getLogicalFixedLengthStringConstraintAccess().getRule();
	}
	
	//// NOTE: While the spec technically allows zero labels, it makes no sense to have a constraint that doesn't
	//// actually constrain anything. It might be in dynamic cases that this list could end up being empty - but
	//// for now we assume it has to have at least 1 value
	///** An EnumerationConstraint identifies a subset of enumerated values (EnumerationLabel) considered valid for an Enumerated value type of a MeasurementAxis. */
	//LogicalEnumerationConstraint :
	//    {LogicalEnumerationConstraint} 'ec' name=ID (description=STRING)? ('[' (allowedValue+=[LogicalEnumerationLabel|QN])+ ']')?
	//;
	public UddlGrammarAccess.LogicalEnumerationConstraintElements getLogicalEnumerationConstraintAccess() {
		return gaUddl.getLogicalEnumerationConstraintAccess();
	}
	
	public ParserRule getLogicalEnumerationConstraintRule() {
		return getLogicalEnumerationConstraintAccess().getRule();
	}
	
	///** A MeasurementConstraint describes the constraints over the axes of a given MeasurementSystem or Measurement or over the value types of a MeasurementSystemAxis or MeasurementAxis. The constraints are described in the “constraintText” attribute. The specific format of “constraintText” is undefined. */
	//LogicalMeasurementConstraint:
	//     constraintText=STRING
	//;
	public UddlGrammarAccess.LogicalMeasurementConstraintElements getLogicalMeasurementConstraintAccess() {
		return gaUddl.getLogicalMeasurementConstraintAccess();
	}
	
	public ParserRule getLogicalMeasurementConstraintRule() {
		return getLogicalMeasurementConstraintAccess().getRule();
	}
	
	///** A MeasurementSystemConversion is a relationship between two MeasurementSystems that describes how to transform measured quantities between those MeasurementSystems. The conversion is captured as a set of equations in the “equation” attribute. The specific format of “equation” is undefined. The loss introduced by the conversion equations is captured in the “conversionLossDescription” attribute. The specific format of “conversionLossDescription” is undefined. */
	//LogicalMeasurementSystemConversion:
	//    'msc' name=ID  (description=STRING)? '{'
	//        source=[LogicalMeasurementSystem|QN] '-('equation+=STRING (',' equation+=STRING)? ')>' destination=[LogicalMeasurementSystem|QN]
	//        'loss:' conversionLossDescription=STRING
	//    '};'
	//;
	public UddlGrammarAccess.LogicalMeasurementSystemConversionElements getLogicalMeasurementSystemConversionAccess() {
		return gaUddl.getLogicalMeasurementSystemConversionAccess();
	}
	
	public ParserRule getLogicalMeasurementSystemConversionRule() {
		return getLogicalMeasurementSystemConversionAccess().getRule();
	}
	
	//// TODO: XText doesn't do multiple inheritance. Address this via a ScopeProvider
	//// See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
	//// Use a FilteringScope
	///** An AbstractMeasurement is a Measurement, MeasurementAxis, or a ValueTypeUnit. */
	////LogicalAbstractMeasurement:
	////    LogicalMeasurement |  // Use LogicalComposableElement
	////    LogicalMeasurementAxis | // Use LogicalElement
	////    LogicalValueTypeUnit  //Use LogicalElement
	////;
	///** A Measurement realizes an Observable as a set of quantities that can be recorded for each axis of a MeasurementSystem. A Measurement contains the specific implementation details optionally including an override of the default ValueType and Unit for each axis as well as the constraints over that space for which the MeasurementSystem is valid. */
	//LogicalMeasurement:
	//    'meas' name=ID  (description=STRING)? '->' realizes=[ConceptualObservable|QN] '{'
	//        attribute+=LogicalMeasurementAttribute*
	//        ('axis:' '[' measurementAxis+=[LogicalMeasurementAxis|QN]+ ']')?
	//        'sys:' measurementSystem=[LogicalAbstractMeasurementSystem|QN]
	//        ('![' constraint+=LogicalMeasurementConstraint ']')?
	//        '};'
	//;
	public UddlGrammarAccess.LogicalMeasurementElements getLogicalMeasurementAccess() {
		return gaUddl.getLogicalMeasurementAccess();
	}
	
	public ParserRule getLogicalMeasurementRule() {
		return getLogicalMeasurementAccess().getRule();
	}
	
	///** A MeasurementAxis optionally establishes constraints for a MeasurementSystemAxis and may optionally override its default units and value types. */
	//LogicalMeasurementAxis:
	//    'maxis' name=ID  (description=STRING)? ('->' realizes=[ConceptualObservable|QN])? '{'
	//        ('vtu:' '[' valueTypeUnit+=[LogicalValueTypeUnit|QN]+ ']')?
	//        'msaxis:' measurementSystemAxis=[LogicalMeasurementSystemAxis|QN]
	//        ('![' constraint+=LogicalMeasurementConstraint+ ']')?
	//    '};'
	//;
	public UddlGrammarAccess.LogicalMeasurementAxisElements getLogicalMeasurementAxisAccess() {
		return gaUddl.getLogicalMeasurementAxisAccess();
	}
	
	public ParserRule getLogicalMeasurementAxisRule() {
		return getLogicalMeasurementAxisAccess().getRule();
	}
	
	///** A MeasurementAttribute is supplemental data associated with a Measurement.  */
	//LogicalMeasurementAttribute:
	//    type=[LogicalMeasurement|QN] rolename=ID ';'
	//;
	public UddlGrammarAccess.LogicalMeasurementAttributeElements getLogicalMeasurementAttributeAccess() {
		return gaUddl.getLogicalMeasurementAttributeAccess();
	}
	
	public ParserRule getLogicalMeasurementAttributeRule() {
		return getLogicalMeasurementAttributeAccess().getRule();
	}
	
	///** A MeasurementConversion is a relationship between two Measurements that describes how to transform measured quantities between those Measurements. The conversion is captured as a set of equations in the “equation” attribute. The specific format of “equation” is undefined. The loss introduced by the conversion equations is captured in the “conversionLossDescription” attribute. The specific format of “conversionLossDescription” is undefined. */
	//LogicalMeasurementConversion:
	//    'mc' name=ID  (description=STRING)? '{'
	//        source=[LogicalMeasurementSystem|QN] '-(' equation+=STRING (',' equation+=STRING)? ')>' destination=[LogicalMeasurementSystem|QN]
	//        'loss:' conversionLossDescription=STRING
	//    '};'
	//;
	public UddlGrammarAccess.LogicalMeasurementConversionElements getLogicalMeasurementConversionAccess() {
		return gaUddl.getLogicalMeasurementConversionAccess();
	}
	
	public ParserRule getLogicalMeasurementConversionRule() {
		return getLogicalMeasurementConversionAccess().getRule();
	}
	
	///** A logical ComposableElement is a logical Element that is allowed to participate in a Composition relationship. In other words, these are the logical Elements that may be a characteristic of a logical Entity. */
	//LogicalComposableElement:
	//    LogicalEntity |
	//    LogicalMeasurement  // Also derived from AbstractMeasurement
	//;
	public UddlGrammarAccess.LogicalComposableElementElements getLogicalComposableElementAccess() {
		return gaUddl.getLogicalComposableElementAccess();
	}
	
	public ParserRule getLogicalComposableElementRule() {
		return getLogicalComposableElementAccess().getRule();
	}
	
	///** Either a LogicalComposition or a LogicalParticipant.
	// * A logical Characteristic contributes to the uniqueness of a logical Entity. The “rolename” attribute defines the name of the logical Characteristic within the scope of the logical Entity. The “lowerBound” and “upperBound” attributes define the multiplicity of the composed Characteristic. An “upperBound” multiplicity of –1 represents an unbounded sequence. */
	//LogicalCharacteristic:
	//    LogicalComposition |
	//    LogicalParticipant
	//;
	public UddlGrammarAccess.LogicalCharacteristicElements getLogicalCharacteristicAccess() {
		return gaUddl.getLogicalCharacteristicAccess();
	}
	
	public ParserRule getLogicalCharacteristicRule() {
		return getLogicalCharacteristicAccess().getRule();
	}
	
	///** A logical Entity “realizes” a conceptual Entity in terms of Measurements and other logical Entities. Since a logical Entity is built from logical Measurements, it is independent of any specific platform data representation. A logical Entity's composition hierarchy is consistent with the composition hierarchy of the conceptual Entity that it realizes. The logical Entity’s composed Entities realize one to one the conceptual Entity’s composed Entities; the logical Entity’s composed Measurements realize many to one the conceptual Entity’s composed Observables.  */
	//LogicalEntity:
	//    'lentity' name=ID  (description=STRING)? (':' specializes=[LogicalEntity|QN])? '->' realizes=[ConceptualEntity|QN] '{'
	//        composition+=LogicalComposition*
	//    '};'
	//    | LogicalAssociation
	//;
	public UddlGrammarAccess.LogicalEntityElements getLogicalEntityAccess() {
		return gaUddl.getLogicalEntityAccess();
	}
	
	public ParserRule getLogicalEntityRule() {
		return getLogicalEntityAccess().getRule();
	}
	
	///** A logical Composition is the mechanism that allows logical Entities to be constructed from other logical ComposableElements. The “type” of a Composition is the ComposableElement being used to construct the logical Entity. The “lowerBound” and “upperBound” define the multiplicity of the composed logical Entity. An “upperBound” multiplicity of –1 represents an unbounded sequence. */
	//LogicalComposition:
	//    type=[LogicalComposableElement|QN]  rolename=ID ('[' lowerBound=INT ':' upperBound=INT ']')? (description=STRING)? (':' specializes=[LogicalCharacteristic|QN])?  '->' realizes=[ConceptualComposition|QN] ';'
	//;
	public UddlGrammarAccess.LogicalCompositionElements getLogicalCompositionAccess() {
		return gaUddl.getLogicalCompositionAccess();
	}
	
	public ParserRule getLogicalCompositionRule() {
		return getLogicalCompositionAccess().getRule();
	}
	
	///** A logical Association represents a relationship between two or more logical Entities. The logical Entities participating in the logical Association may be specified locally or in its generalized types. In addition, there may be one or more logical ComposableElements that characterize the relationship. Logical Associations are logical Entities that may also participate in other logical Associations. */
	//LogicalAssociation:
	//    'lassoc' name=ID  (description=STRING)? (':' specializes=[LogicalEntity|QN])? '->' realizes=[ConceptualEntity|QN] '{'
	//        composition+=LogicalComposition*
	//        // While technically this is optional, it makes no sense to have an Association with less than 2 participants. However,
	//        // Those participants can be named anywhere in the inheritance/ specializes hierarchy - not just locally
	//        ('participants:' '[' participant+=LogicalParticipant+ ']')?
	//    '};'
	//;
	public UddlGrammarAccess.LogicalAssociationElements getLogicalAssociationAccess() {
		return gaUddl.getLogicalAssociationAccess();
	}
	
	public ParserRule getLogicalAssociationRule() {
		return getLogicalAssociationAccess().getRule();
	}
	
	///** A logical Participant is the mechanism that allows a logical Association to be constructed between two or more logical Entities. The “type” of a logical Participant is the logical Entity being used to construct the logical Association. The “sourceLowerBound” and “sourceUpperBound” attributes define the multiplicity of the logical Association relative to the Participant. A “sourceUpperBound” multiplicity of –1 represents an unbounded sequence. The “path” attribute of the Participant describes the chain of entity characteristics to traverse to reach the subject of the association beginning with the entity referenced by the “type” attribute. */
	//LogicalParticipant:
	//    type=[LogicalEntity|QN]  rolename=ID ('[' lowerBound=INT ':' upperBound=INT ']')? (description=STRING)? (':' specializes=[LogicalCharacteristic|QN])?  '->' realizes=[ConceptualParticipant|QN] '{'
	//        'source:' '[' sourceLowerBound=INT ':' sourceUpperBound=INT ']'
	//        ('path:' path=LogicalPathNode )?
	//    '};'
	//;
	public UddlGrammarAccess.LogicalParticipantElements getLogicalParticipantAccess() {
		return gaUddl.getLogicalParticipantAccess();
	}
	
	public ParserRule getLogicalParticipantRule() {
		return getLogicalParticipantAccess().getRule();
	}
	
	///** A logical PathNode is a single element in a chain that collectively forms a path specification. */
	//LogicalPathNode:
	//    LogicalParticipantPathNode |
	//    LogicalCharacteristicPathNode
	//;
	public UddlGrammarAccess.LogicalPathNodeElements getLogicalPathNodeAccess() {
		return gaUddl.getLogicalPathNodeAccess();
	}
	
	public ParserRule getLogicalPathNodeRule() {
		return getLogicalPathNodeAccess().getRule();
	}
	
	///** A logical ParticipantPathNode is a logical PathNode that selects a Participant that references an Entity. This provides a mechanism for reverse navigation from an Entity that participates in an Association back to the Association. */
	//LogicalParticipantPathNode:
	//    '/' projectedParticipant=[LogicalParticipant|QN]  ( node=LogicalPathNode)
	//;
	public UddlGrammarAccess.LogicalParticipantPathNodeElements getLogicalParticipantPathNodeAccess() {
		return gaUddl.getLogicalParticipantPathNodeAccess();
	}
	
	public ParserRule getLogicalParticipantPathNodeRule() {
		return getLogicalParticipantPathNodeAccess().getRule();
	}
	
	///** A logical CharacteristicPathNode is a logical PathNode that selects a logical Characteristic which is directly contained in a logical Entity or Association. */
	//LogicalCharacteristicPathNode:
	//    '#' projectedCharacteristic=[LogicalCharacteristic|QN]  ( node=LogicalPathNode)
	//;
	public UddlGrammarAccess.LogicalCharacteristicPathNodeElements getLogicalCharacteristicPathNodeAccess() {
		return gaUddl.getLogicalCharacteristicPathNodeAccess();
	}
	
	public ParserRule getLogicalCharacteristicPathNodeRule() {
		return getLogicalCharacteristicPathNodeAccess().getRule();
	}
	
	///** A logical View is a logical Query or a logical CompositeQuery. */
	//LogicalView:
	//    LogicalQuery |
	//    LogicalCompositeQuery
	//;
	public UddlGrammarAccess.LogicalViewElements getLogicalViewAccess() {
		return gaUddl.getLogicalViewAccess();
	}
	
	public ParserRule getLogicalViewRule() {
		return getLogicalViewAccess().getRule();
	}
	
	///** A logical Query is a specification that defines the content of logical View as a set of logical Characteristics projected from a selected set of related logical Entities. The “specification” attribute captures the specification of a Query as defined by the Query grammar. */
	//LogicalQuery:
	//    'lquery' name=ID  (description=STRING)? ('->' realizes=[ConceptualQuery|QN])? '{'
	//        'spec:' specification=STRING
	//        '};'
	//;
	public UddlGrammarAccess.LogicalQueryElements getLogicalQueryAccess() {
		return gaUddl.getLogicalQueryAccess();
	}
	
	public ParserRule getLogicalQueryRule() {
		return getLogicalQueryAccess().getRule();
	}
	
	///** A logical CompositeQuery is a collection of two or more logical Views. The “isUnion” attribute specifies whether the composed Views are intended to be mutually exclusive or not. */
	//LogicalCompositeQuery:
	//    'lcquery' name=ID  (description=STRING)? ('->' realizes=[ConceptualCompositeQuery|QN])? '{'
	//        isUnion?='isUnion'
	//        composition+=LogicalQueryComposition
	//        '};'
	//;
	public UddlGrammarAccess.LogicalCompositeQueryElements getLogicalCompositeQueryAccess() {
		return gaUddl.getLogicalCompositeQueryAccess();
	}
	
	public ParserRule getLogicalCompositeQueryRule() {
		return getLogicalCompositeQueryAccess().getRule();
	}
	
	///** A logical QueryComposition is the mechanism that allows a logical CompositeQuery to be constructed from logical Queries and other logical CompositeQueries. The “rolename” attribute defines the name of the composed logical View within the scope of the composing logical CompositeQuery. The “type” of a logical QueryComposition is the logical View being used to construct the logical CompositeQuery. */
	//LogicalQueryComposition:
	//    type=[LogicalView|QN] rolename=ID ( '->' realizes=[ConceptualQueryComposition|QN])?
	//;
	public UddlGrammarAccess.LogicalQueryCompositionElements getLogicalQueryCompositionAccess() {
		return gaUddl.getLogicalQueryCompositionAccess();
	}
	
	public ParserRule getLogicalQueryCompositionRule() {
		return getLogicalQueryCompositionAccess().getRule();
	}
	
	///* * * * * * * Platform Level Rules * * * * * *  */
	///** A platform Element is the root type for defining the platform elements of a Data Model. */
	//PlatformElement:
	//    PlatformComposableElement |
	//    PlatformView
	//;
	public UddlGrammarAccess.PlatformElementElements getPlatformElementAccess() {
		return gaUddl.getPlatformElementAccess();
	}
	
	public ParserRule getPlatformElementRule() {
		return getPlatformElementAccess().getRule();
	}
	
	///** A platform ComposableElement is a platform Element that is allowed to participate in a Composition relationship. In other words, these are the platform Elements that may be a characteristic of a platform Entity. */
	//PlatformComposableElement:
	//    PlatformEntity |
	//    PlatformDataType
	//;
	public UddlGrammarAccess.PlatformComposableElementElements getPlatformComposableElementAccess() {
		return gaUddl.getPlatformComposableElementAccess();
	}
	
	public ParserRule getPlatformComposableElementRule() {
		return getPlatformComposableElementAccess().getRule();
	}
	
	///** A PlatformDataType is a platform realization of a logical AbstractMeasurement and is either a Primitive or a Struct. */
	//PlatformDataType:
	//    PlatformPrimitive |
	//    PlatformStruct
	//;
	public UddlGrammarAccess.PlatformDataTypeElements getPlatformDataTypeAccess() {
		return gaUddl.getPlatformDataTypeAccess();
	}
	
	public ParserRule getPlatformDataTypeRule() {
		return getPlatformDataTypeAccess().getRule();
	}
	
	///** A platform Primitive realizes a logical AbstractMeasurement in terms of a simple data type. */
	//PlatformPrimitive:
	//    PlatformSequence |
	//    PlatformBoolean |
	//    PlatformChar | //PlatformCharType | // skip single inheritance
	//    PlatformNumber |
	//    PlatformOctet |
	//    PlatformEnumeration |
	//    PlatformStringType |
	//    PlatformArray
	//;
	public UddlGrammarAccess.PlatformPrimitiveElements getPlatformPrimitiveAccess() {
		return gaUddl.getPlatformPrimitiveAccess();
	}
	
	public ParserRule getPlatformPrimitiveRule() {
		return getPlatformPrimitiveAccess().getRule();
	}
	
	///** A Boolean is a data type that represents the values TRUE and FALSE. */
	//PlatformBoolean:            'bool'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformBooleanElements getPlatformBooleanAccess() {
		return gaUddl.getPlatformBooleanAccess();
	}
	
	public ParserRule getPlatformBooleanRule() {
		return getPlatformBooleanAccess().getRule();
	}
	
	///** An Octet is an 8-bit quantity that is guaranteed not to undergo any conversion during transfer between systems. */
	//PlatformOctet:                'octet'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformOctetElements getPlatformOctetAccess() {
		return gaUddl.getPlatformOctetAccess();
	}
	
	public ParserRule getPlatformOctetRule() {
		return getPlatformOctetAccess().getRule();
	}
	
	//// Skip single inheritance - XText doesn't float attributes up when there is single inheritance.
	/////** A CharType is a Char. */
	////PlatformCharType:
	////    PlatformChar
	//////    | PlatformWChar // NOTE: WChar was removed from the spec. Not clear is we want it
	////;
	///** A Char is a data type that represents characters from any single byte character set. */
	//PlatformChar:                'char'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformCharElements getPlatformCharAccess() {
		return gaUddl.getPlatformCharAccess();
	}
	
	public ParserRule getPlatformCharRule() {
		return getPlatformCharAccess().getRule();
	}
	
	////PlatformWChar:                'wchar'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	///** A StringType is a BoundedString, an unbounded String, or a CharArray. */
	//PlatformStringType:
	//    PlatformString |
	//    PlatformBoundedString |
	//    PlatformCharArray
	//;
	public UddlGrammarAccess.PlatformStringTypeElements getPlatformStringTypeAccess() {
		return gaUddl.getPlatformStringTypeAccess();
	}
	
	public ParserRule getPlatformStringTypeRule() {
		return getPlatformStringTypeAccess().getRule();
	}
	
	///** A String is a data type that represents a variable length sequence of Char (all 8-bit quantities except NULL). The length is a non-negative integer, and is available at run-time. */
	//PlatformString:                'string'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformStringElements getPlatformStringAccess() {
		return gaUddl.getPlatformStringAccess();
	}
	
	public ParserRule getPlatformStringRule() {
		return getPlatformStringAccess().getRule();
	}
	
	///** A BoundedString is a data type that represents a variable length sequence of Char (all 8-bit quantities except NULL). The length is a non-negative integer, and is available at run-time. The “maxLength” attribute defines the maximum length of the BoundedString, an integer value greater than 0. */
	//PlatformBoundedString:        'string[' maxLength=INT ']'      name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformBoundedStringElements getPlatformBoundedStringAccess() {
		return gaUddl.getPlatformBoundedStringAccess();
	}
	
	public ParserRule getPlatformBoundedStringRule() {
		return getPlatformBoundedStringAccess().getRule();
	}
	
	///** A CharArray is a data type that represents a fixed length sequence of Char (all 8-bit quantities except NULL). The length is a positive integer, and is available at run-time. The “length” attribute defines the length of the CharArray, an integer value greater than 0. */
	//PlatformCharArray:            'char['   length=INT ']'          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformCharArrayElements getPlatformCharArrayAccess() {
		return gaUddl.getPlatformCharArrayAccess();
	}
	
	public ParserRule getPlatformCharArrayRule() {
		return getPlatformCharArrayAccess().getRule();
	}
	
	///** An Enumeration is a data type that represents an ordered list of identifiers. */
	//PlatformEnumeration:        'enum'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformEnumerationElements getPlatformEnumerationAccess() {
		return gaUddl.getPlatformEnumerationAccess();
	}
	
	public ParserRule getPlatformEnumerationRule() {
		return getPlatformEnumerationAccess().getRule();
	}
	
	///** A Number is an abstract meta-class from which all meta-classes representing numeric values derive. */
	//PlatformNumber:
	//    PlatformReal |
	//    PlatformInteger
	//;
	public UddlGrammarAccess.PlatformNumberElements getPlatformNumberAccess() {
		return gaUddl.getPlatformNumberAccess();
	}
	
	public ParserRule getPlatformNumberRule() {
		return getPlatformNumberAccess().getRule();
	}
	
	///** An Integer is an abstract meta-class from which all meta-classes representing whole numbers derive. */
	//PlatformInteger:
	//    PlatformLong |
	//    PlatformShort |
	//    PlatformUnsignedInteger |
	//    PlatformLongLong
	//;
	public UddlGrammarAccess.PlatformIntegerElements getPlatformIntegerAccess() {
		return gaUddl.getPlatformIntegerAccess();
	}
	
	public ParserRule getPlatformIntegerRule() {
		return getPlatformIntegerAccess().getRule();
	}
	
	///** A Short is an integer data type that represents integer values in the range –2^15 to (2^15 – 1). */
	//PlatformShort:                'short'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformShortElements getPlatformShortAccess() {
		return gaUddl.getPlatformShortAccess();
	}
	
	public ParserRule getPlatformShortRule() {
		return getPlatformShortAccess().getRule();
	}
	
	///** A Long is an integer data type that represents integer values in the range –2^31 to (2^31 – 1). */
	//PlatformLong:                'long'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformLongElements getPlatformLongAccess() {
		return gaUddl.getPlatformLongAccess();
	}
	
	public ParserRule getPlatformLongRule() {
		return getPlatformLongAccess().getRule();
	}
	
	///** A LongLong is an integer data type that represents integer values in the range –2^63 to (2^63 – 1). */
	//PlatformLongLong:            'llong'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformLongLongElements getPlatformLongLongAccess() {
		return gaUddl.getPlatformLongLongAccess();
	}
	
	public ParserRule getPlatformLongLongRule() {
		return getPlatformLongLongAccess().getRule();
	}
	
	///** A Real is an abstract meta-class from which all meta-classes representing real numbers derive. */
	//PlatformReal:
	//    PlatformFixed |
	//    PlatformFloat |
	//    PlatformDouble |
	//    PlatformLongDouble
	//;
	public UddlGrammarAccess.PlatformRealElements getPlatformRealAccess() {
		return gaUddl.getPlatformRealAccess();
	}
	
	public ParserRule getPlatformRealRule() {
		return getPlatformRealAccess().getRule();
	}
	
	///** A Double is a real data type that represents an IEEE double precision floating-point number.  */
	//PlatformDouble:                'double'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformDoubleElements getPlatformDoubleAccess() {
		return gaUddl.getPlatformDoubleAccess();
	}
	
	public ParserRule getPlatformDoubleRule() {
		return getPlatformDoubleAccess().getRule();
	}
	
	///** A LongDouble is a real data type that represents an IEEE extended double precision floating- point number (having a signed fraction of at least 64 bits and an exponent of at least 15 bits) */
	//PlatformLongDouble:            'ldouble'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformLongDoubleElements getPlatformLongDoubleAccess() {
		return gaUddl.getPlatformLongDoubleAccess();
	}
	
	public ParserRule getPlatformLongDoubleRule() {
		return getPlatformLongDoubleAccess().getRule();
	}
	
	///** A Float is a real data type that represents an IEEE single precision floating-point number. */
	//PlatformFloat:                'float'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformFloatElements getPlatformFloatAccess() {
		return gaUddl.getPlatformFloatAccess();
	}
	
	public ParserRule getPlatformFloatRule() {
		return getPlatformFloatAccess().getRule();
	}
	
	///** A Fixed is a real data type that represents a fixed-point decimal number of up to 31 significant digits. The “digits” attribute defines the total number of digits, a non-negative integer value less than or equal to 31. The “scale” attribute defines the position of the decimal point in the number, and cannot be greater than “digits”. */
	//PlatformFixed:                'fixed[' digits=INT '.' scale=INT ']'
	//                                                            name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';'
	//;
	public UddlGrammarAccess.PlatformFixedElements getPlatformFixedAccess() {
		return gaUddl.getPlatformFixedAccess();
	}
	
	public ParserRule getPlatformFixedRule() {
		return getPlatformFixedAccess().getRule();
	}
	
	///** An UnsignedInteger is an abstract meta-class from which all meta-classes representing unsigned whole numbers derive. */
	//PlatformUnsignedInteger:
	//    PlatformUShort |
	//    PlatformULong |
	//    PlatformULongLong
	//;
	public UddlGrammarAccess.PlatformUnsignedIntegerElements getPlatformUnsignedIntegerAccess() {
		return gaUddl.getPlatformUnsignedIntegerAccess();
	}
	
	public ParserRule getPlatformUnsignedIntegerRule() {
		return getPlatformUnsignedIntegerAccess().getRule();
	}
	
	///** A UShort is an integer data type that represents integer values in the range 0 to (2^16 – 1).  */
	//PlatformUShort:                'ushort'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformUShortElements getPlatformUShortAccess() {
		return gaUddl.getPlatformUShortAccess();
	}
	
	public ParserRule getPlatformUShortRule() {
		return getPlatformUShortAccess().getRule();
	}
	
	///** A ULong is an integer data type that represents integer values in the range 0 to (2^32 – 1). */
	//PlatformULong:                'ulong'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformULongElements getPlatformULongAccess() {
		return gaUddl.getPlatformULongAccess();
	}
	
	public ParserRule getPlatformULongRule() {
		return getPlatformULongAccess().getRule();
	}
	
	///** A ULongLong is an integer data type that represents integer values in the range 0 to (2^64 – 1). */
	//PlatformULongLong:            'ullong'                          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformULongLongElements getPlatformULongLongAccess() {
		return gaUddl.getPlatformULongLongAccess();
	}
	
	public ParserRule getPlatformULongLongRule() {
		return getPlatformULongLongAccess().getRule();
	}
	
	///** A Sequence is used to represent a sequence of Octets. This can be used to realize a StandardMeasurementSystem. */
	//PlatformSequence:            'seq' ('[' maxSize=INT ']')?      name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformSequenceElements getPlatformSequenceAccess() {
		return gaUddl.getPlatformSequenceAccess();
	}
	
	public ParserRule getPlatformSequenceRule() {
		return getPlatformSequenceAccess().getRule();
	}
	
	///** An Array is used to represent an array of Octets. This can be used to realize a StandardMeasurementSystem. */
	//PlatformArray:                'arr' ('[' size=INT ']')?          name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] ';' ;
	public UddlGrammarAccess.PlatformArrayElements getPlatformArrayAccess() {
		return gaUddl.getPlatformArrayAccess();
	}
	
	public ParserRule getPlatformArrayRule() {
		return getPlatformArrayAccess().getRule();
	}
	
	///** A platform Struct is a structured realization of a logical AbstractMeasurement. It is composed of PlatformDataTypes (i.e., Primitives and other Structs composed of Primitives). A platform Struct’s composition hierarchy is consistent with the composition hierarchy of the logical AbstractMeasurement that it realizes. */
	//PlatformStruct:
	//    'struct' name=ID  (description=STRING)? '->' realizes=[/*LogicalAbstractMeasurement*/LogicalElement|QN] '{'
	//        member+=PlatformStructMember
	//        member+=PlatformStructMember
	//        (member+=PlatformStructMember)?
	//    '}'
	//;
	public UddlGrammarAccess.PlatformStructElements getPlatformStructAccess() {
		return gaUddl.getPlatformStructAccess();
	}
	
	public ParserRule getPlatformStructRule() {
		return getPlatformStructAccess().getRule();
	}
	
	///** A StructMember is the mechanism that allows Structs to be constructed from other PlatformDataTypes. The “type” of a StructMember is the PlatformDataType being used to construct the Struct. If “type” is a Primitive, the “precision” attribute specifies a measure of the detail in which a quantity is captured. */
	//PlatformStructMember:
	//    type=[PlatformDataType|QN] rolename=ID '(' precision=FLOAT ')' ('->' realizes=[LogicalMeasurementAttribute|QN] ';')?
	//;
	public UddlGrammarAccess.PlatformStructMemberElements getPlatformStructMemberAccess() {
		return gaUddl.getPlatformStructMemberAccess();
	}
	
	public ParserRule getPlatformStructMemberRule() {
		return getPlatformStructMemberAccess().getRule();
	}
	
	///** A platform Characteristic contributes to the uniqueness of a platform Entity. The “rolename” attribute defines the name of the platform Characteristic within the scope of the platform Entity. The “lowerBound” and “upperBound” attributes define the multiplicity of the composed Characteristic. An “upperBound” multiplicity of –1 represents an unbounded sequence. */
	//PlatformCharacteristic:
	//    PlatformComposition |
	//    PlatformParticipant
	//;
	public UddlGrammarAccess.PlatformCharacteristicElements getPlatformCharacteristicAccess() {
		return gaUddl.getPlatformCharacteristicAccess();
	}
	
	public ParserRule getPlatformCharacteristicRule() {
		return getPlatformCharacteristicAccess().getRule();
	}
	
	///** A platform Entity “realizes” a logical Entity in terms of PhysicalDataTypes and other platform Entities composed of PhysicalDataTypes. A platform Entity’s composition hierarchy is consistent with the composition hierarchy of the logical Entity that it realizes. The platform Entity’s composed Entities realize one to one the logical Entity’s composed Entities; the platform Entity’s composed PhysicalDataTypes realize many to one the logical Entity’s composed Measurements. */
	//PlatformEntity:
	//    'pentity' name=ID  (description=STRING)? (':' specializes=[PlatformEntity|QN])? '->' realizes=[LogicalEntity|QN] '{'
	//        composition+=PlatformComposition*
	//    '};'
	//    | PlatformAssociation
	//;
	public UddlGrammarAccess.PlatformEntityElements getPlatformEntityAccess() {
		return gaUddl.getPlatformEntityAccess();
	}
	
	public ParserRule getPlatformEntityRule() {
		return getPlatformEntityAccess().getRule();
	}
	
	///** A platform Composition is the mechanism that allows platform Entities to be constructed from other platform ComposableElements. The “type” of a Composition is the ComposableElement being used to construct the platform Entity. The “lowerBound” and “upperBound” define the multiplicity of the composed platform Entity. An “upperBound” multiplicity of –1 represents an unbounded sequence. If “type” is a Primitive, the “precision” attribute specifies a measure of the detail in which a quantity is captured.  */
	//PlatformComposition:
	//    type=[PlatformComposableElement|QN]  rolename=ID ('[' lowerBound=INT ':' upperBound=INT ']')? (description=STRING)? (':' specializes=[PlatformCharacteristic|QN])?  '->' realizes=[LogicalComposition|QN]
	//        ('{'
	//            'prec:' precision=FLOAT
	//        '}')? ';'
	//;
	public UddlGrammarAccess.PlatformCompositionElements getPlatformCompositionAccess() {
		return gaUddl.getPlatformCompositionAccess();
	}
	
	public ParserRule getPlatformCompositionRule() {
		return getPlatformCompositionAccess().getRule();
	}
	
	///** A platform Association represents a relationship between two or more platform Entities. The platform Entities participating in the platform Association may be specified locally or in its generalized types. In addition, there may be one or more platform ComposableElements that characterize the relationship. Platform Associations are platform Entities that may also participate in other platform Associations. */
	//PlatformAssociation:
	//    'passoc' name=ID  (description=STRING)? (':' specializes=[PlatformEntity|QN])? '->' realizes=[LogicalEntity|QN] '{'
	//        composition+=PlatformComposition*
	//        // While technically this is optional, it makes no sense to have an Association with less than 2 participants. However,
	//        // Those participants can be named anywhere in the inheritance/ specializes hierarchy - not just locally
	//        ('participants:' '[' participant+=PlatformParticipant+ ']')?
	//    '};'
	//;
	public UddlGrammarAccess.PlatformAssociationElements getPlatformAssociationAccess() {
		return gaUddl.getPlatformAssociationAccess();
	}
	
	public ParserRule getPlatformAssociationRule() {
		return getPlatformAssociationAccess().getRule();
	}
	
	///** A platform Participant is the mechanism that allows a platform Association to be constructed between two or more platform Entities. The “type” of a platform Participant is the platform Entity being used to construct the platform Association. The “sourceLowerBound” and “sourceUpperBound” attributes define the multiplicity of the platform Association relative to the Participant. A “sourceUpperBound” multiplicity of –1 represents an unbounded sequence. The “path” attribute of the Participant describes the chain of entity characteristics to traverse to reach the subject of the association beginning with the entity referenced by the “type” attribute.  */
	//PlatformParticipant:
	//    type=[PlatformEntity|QN]  rolename=ID ('[' lowerBound=INT ':' upperBound=INT ']')? (description=STRING)? (':' specializes=[PlatformCharacteristic|QN])?  '->' realizes=[LogicalParticipant|QN] '{'
	//        'source:' '[' sourceLowerBound=INT ':' sourceUpperBound=INT ']'
	//        ('path:' path=PlatformPathNode )?
	//    '};'
	//;
	public UddlGrammarAccess.PlatformParticipantElements getPlatformParticipantAccess() {
		return gaUddl.getPlatformParticipantAccess();
	}
	
	public ParserRule getPlatformParticipantRule() {
		return getPlatformParticipantAccess().getRule();
	}
	
	///** A platform PathNode is a single element in a chain that collectively forms a path specification. */
	//PlatformPathNode:
	//    PlatformParticipantPathNode |
	//    PlatformCharacteristicPathNode
	//;
	public UddlGrammarAccess.PlatformPathNodeElements getPlatformPathNodeAccess() {
		return gaUddl.getPlatformPathNodeAccess();
	}
	
	public ParserRule getPlatformPathNodeRule() {
		return getPlatformPathNodeAccess().getRule();
	}
	
	///** A platform ParticipantPathNode is a platform PathNode that selects a Participant that references an Entity. This provides a mechanism for reverse navigation from an Entity that participates in an Association back to the Association. */
	//PlatformParticipantPathNode:
	//    '/' projectedParticipant=[PlatformParticipant|QN]  ( node=PlatformPathNode)
	//;
	public UddlGrammarAccess.PlatformParticipantPathNodeElements getPlatformParticipantPathNodeAccess() {
		return gaUddl.getPlatformParticipantPathNodeAccess();
	}
	
	public ParserRule getPlatformParticipantPathNodeRule() {
		return getPlatformParticipantPathNodeAccess().getRule();
	}
	
	///** A platform CharacteristicPathNode is a platform PathNode that selects a platform Characteristic which is directly contained in a platform Entity or Association. */
	//PlatformCharacteristicPathNode:
	//    '#' projectedCharacteristic=[PlatformCharacteristic|QN]  ( node=PlatformPathNode)
	//;
	public UddlGrammarAccess.PlatformCharacteristicPathNodeElements getPlatformCharacteristicPathNodeAccess() {
		return gaUddl.getPlatformCharacteristicPathNodeAccess();
	}
	
	public ParserRule getPlatformCharacteristicPathNodeRule() {
		return getPlatformCharacteristicPathNodeAccess().getRule();
	}
	
	///** A platform View is a platform Query or a platform CompositeQuery. */
	//PlatformView:
	//    PlatformQuery |
	//    PlatformCompositeQuery
	//;
	public UddlGrammarAccess.PlatformViewElements getPlatformViewAccess() {
		return gaUddl.getPlatformViewAccess();
	}
	
	public ParserRule getPlatformViewRule() {
		return getPlatformViewAccess().getRule();
	}
	
	///** A platform Query is a specification that defines the content of platform View as a set of platform Characteristics projected from a selected set of related platform Entities. The “specification” attribute captures the specification of a Query as defined by the Query grammar. */
	//PlatformQuery:
	//    'pquery' name=ID  (description=STRING)? ('->' realizes=[LogicalQuery|QN])? '{'
	//        'spec:' specification=STRING
	//        '};'
	//;
	public UddlGrammarAccess.PlatformQueryElements getPlatformQueryAccess() {
		return gaUddl.getPlatformQueryAccess();
	}
	
	public ParserRule getPlatformQueryRule() {
		return getPlatformQueryAccess().getRule();
	}
	
	///** A platform CompositeQuery is a collection of two or more platform Views. The “isUnion” attribute specifies whether the composed Views are intended to be mutually exclusive or not. */
	//PlatformCompositeQuery:
	//    'pcquery' name=ID  (description=STRING)? ('->' realizes=[LogicalQuery|QN])? '{'
	//        isUnion?='isUnion'
	//        composition+=PlatformQueryComposition
	//        '};'
	//;
	public UddlGrammarAccess.PlatformCompositeQueryElements getPlatformCompositeQueryAccess() {
		return gaUddl.getPlatformCompositeQueryAccess();
	}
	
	public ParserRule getPlatformCompositeQueryRule() {
		return getPlatformCompositeQueryAccess().getRule();
	}
	
	///** A platform QueryComposition is the mechanism that allows a platform CompositeQuery to be constructed from platform Queries and other platform CompositeQueries. The “rolename” attribute defines the name of the composed platform View within the scope of the composing platform CompositeQuery. The “type” of a platform QueryComposition is the platform View being used to construct the platform CompositeQuery. */
	//PlatformQueryComposition:
	//    type=[PlatformView|QN] rolename=ID ( '->' realizes=[LogicalQueryComposition|QN])?
	//;
	public UddlGrammarAccess.PlatformQueryCompositionElements getPlatformQueryCompositionAccess() {
		return gaUddl.getPlatformQueryCompositionAccess();
	}
	
	public ParserRule getPlatformQueryCompositionRule() {
		return getPlatformQueryCompositionAccess().getRule();
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
